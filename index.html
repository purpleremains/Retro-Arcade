<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroArcade - Play Games Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            color: #00ff41;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll for the body */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Enhanced visual effects */
            background-attachment: fixed;
            user-select: none; /* Prevent text selection for better mobile experience */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            /* Touch optimizations */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        .container {
            position: relative;
            z-index: 2;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        header {
            text-align: center;
            margin-bottom: clamp(25px, 6vh, 40px);
            padding: clamp(12px, 3vw, 20px);
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff41;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            width: 100%;
            max-width: clamp(300px, 90%, 650px);
        }
        h1 {
            font-size: clamp(2rem, 6vw, 3.5rem);
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff41;
            animation: glow 2s ease-in-out infinite alternate;
            word-break: break-word;
        }
        @keyframes glow {
            from { 
                text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff41; 
                filter: brightness(1);
            }
            to { 
                text-shadow: 0 0 20px #00ff41, 0 0 30px #00ff41, 0 0 40px #00ff41; 
                filter: brightness(1.1);
            }
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(350px, 100%), 1fr));
            gap: clamp(15px, 3vw, 30px);
            margin-bottom: clamp(20px, 5vw, 40px);
            width: 100%;
            padding: 0 clamp(10px, 2vw, 20px);
        }
        .game-card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            /* Enhanced mobile touch support */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            /* Improved visual depth */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        .game-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 65, 0.1), transparent);
            transform: rotate(45deg) translateX(-100%) translateY(-100%); /* Start off-screen */
            opacity: 0;
            transition: none; /* Animation will control the visual properties */
        }
        @keyframes shine {
            0% { transform: rotate(45deg) translateX(-100%) translateY(-100%); opacity: 0; }
            1% { opacity: 1; } /* Make it visible at the start of the sweep */
            99% { opacity: 1; } /* Keep it visible during the sweep */
            100% { transform: rotate(45deg) translateX(100%) translateY(100%); opacity: 0; } /* End off-screen and fade out */
        }
        .game-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 30px rgba(0, 255, 65, 0.4);
            border-color: #00ffff;
        }
        .game-card:hover::before {
            animation: shine 1.5s linear infinite; /* Play animation continuously while hovered */
        }
        .game-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #00ffff;
        }
        .game-description {
            margin-bottom: 20px;
            opacity: 0.9;
            line-height: 1.4;
        }
        .play-btn {
            background: linear-gradient(45deg, #00ff41, #00ffff);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: #000;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            /* Enhanced mobile touch support */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            /* Improved visual appeal */
            position: relative;
            overflow: hidden;
        }
        .play-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }
        .play-btn:hover::before {
            left: 100%;
        }
        .play-btn:hover, .play-btn:active {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.5);
        }
        /* Mobile-friendly active state */
        .play-btn:active {
            transform: scale(0.98);
        }
        .game-area {
            display: none; /* Initially hidden, now controlled more strictly by JS */
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            width: 100%;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.1); 
            flex-direction: column; /* Still flex container for its children */
            align-items: center;
        }
        .game-canvas {
            display: none; /* Initially hidden, JS will set to block/flex */
            border: 2px solid #00ffff;
            border-radius: 10px;
            background: #000;
            margin: 20px auto; /* Centering and spacing */
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }

        .game-controls {
            margin: 20px 0;
            text-align: center;
            color: #00ff41;
        }
        .control-btn {
            background: #00ff41;
            border: none;
            padding: 15px 25px; /* Larger touch targets */
            margin: 8px;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            /* Enhanced mobile support */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px; /* iOS minimum touch target */
            min-width: 44px;
            /* Improved visual feedback */
            position: relative;
            overflow: hidden;
        }
        .control-btn:hover, .control-btn:active {
            background: #00ffff;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.5);
        }
        .control-btn:active {
            transform: scale(0.95);
            transition: all 0.1s ease;
        }

        .score {
            display: none; /* Initially hidden */
            font-size: 1.3rem;
            margin: 10px 0;
            color: #00ffff;
            margin-left: 25px;
        }
        /* Minesweeper specific controls for flags/timer */
        #minesweeperInfo {
            display: none; /* Initially hidden */
            justify-content: space-between;
            width: 100%;
            min-width: 300px;
            max-width: 600px;
            margin-top: 10px;
            color: #00ffff;
            font-size: 1.1rem;
            margin-left: auto;
            margin-right: auto;
        }
        /* Pong Difficulty Selection */
        #pongDifficultySelection {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            margin: 20px auto;
            text-align: center;
            max-width: 400px;
            width: 100%;
            /* display: none; */ /* Now controlled by JS explicitly */
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #pongDifficultySelection h3 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #00ff41;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }
        #pongDifficultySelection label {
            font-size: 1.2rem;
            margin: 10px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            color: #00ffff;
        }
        #pongDifficultySelection input[type="radio"] {
            margin-right: 10px;
            transform: scale(1.5);
            accent-color: #00ff41;
            cursor: pointer;
        }
        #pongDifficultySelection button {
            margin-top: 25px;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
        }


        .action-buttons {
            /* display: none; */ /* Initially hidden, now controlled by JS explicitly */
            margin-top: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        .back-btn {
            background: #ff4444;
            border: none;
            padding: 15px 25px; /* Larger touch targets */
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            /* Enhanced mobile support */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
            min-width: 44px;
        }
        .back-btn:hover, .back-btn:active {
            background: #ff6666;
            transform: scale(1.05);
        }
        .back-btn:active {
            transform: scale(0.95);
            transition: all 0.1s ease;
        }
        
        /* Game Over Overlay Styles */
        .game-over-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            z-index: 100;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #00ff41;
            text-align: center;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(5px);
        }
        .game-over-overlay.active {
            display: flex;
        }
        .game-over-content {
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff0041;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 0 30px rgba(255, 0, 65, 0.6);
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: translateY(-20px) scale(0.9); 
                filter: blur(5px);
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
                filter: blur(0px);
            }
        }
        .game-over-content h2 {
            font-size: 3rem;
            color: #ff0041;
            text-shadow: 0 0 15px #ff0041;
            margin-bottom: 20px;
            animation: heartbeat 1.5s infinite;
        }
        @keyframes heartbeat {
            0% { 
                transform: scale(1); 
                filter: drop-shadow(0 0 10px currentColor);
            }
            50% { 
                transform: scale(1.05); 
                filter: drop-shadow(0 0 20px currentColor);
            }
            100% { 
                transform: scale(1); 
                filter: drop-shadow(0 0 10px currentColor);
            }
        }
        .game-over-content p {
            font-size: 1.8rem;
            margin-bottom: 10px; /* Reduced margin to make space for high score */
            color: #00ffff;
        }
        .game-over-buttons button {
            background: linear-gradient(45deg, #00ff41, #00ffff);
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            color: #000;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .game-over-buttons button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        }

        /* Message Box Style */
        .message-box {
            background: rgba(0, 0, 0, 1);
            border: 2px solid #ffeb3b;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
            font-size: 1.1rem;
            color: #ffeb3b;
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.5);
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            max-width: 80%;
            box-sizing: border-box; /* Include padding in max-width calculation */
        }
        /* Style for the "Start Game" / "OK" button within the message box */
        #messageBoxOkBtn {
            margin-top: 20px; /* Add some space above the button */
            padding: 15px 30px; /* Make it bigger */
            font-size: 1.2rem; /* Increase font size */
            background: linear-gradient(45deg, #00ff41, #00ffff);
            border: none;
            border-radius: 25px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.5); /* Add initial shadow */
        }
        #messageBoxOkBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 255, 65, 0.7); /* Enhance shadow on hover */
        }

        /* Styling for the Galactic Invaders info bar */
        #galacticInvadersInfo {
            display: none; /* Initially hidden */
            justify-content: space-around; /* Distribute items evenly */
            width: 100%;
            min-width: 300px;
            max-width: 600px;
            margin-top: 10px;
            color: #00ffff;
            font-size: 1.1rem;
            margin-left: auto;
            margin-right: auto;
        }
        #galacticInvadersInfo span {
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff41;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>

    <div class="container">
        <header id="mainHeader">
            <h1>🎮 RETROARCADE 🎮</h1>
            <p class="subtitle">Classic Games Reimagined for the Web</p>
        </header>

        <div id="gameSelection" class="games-grid">
            <div class="game-card">
                <h3 class="game-title">🦖 Prehistoric Run</h3>
                <p class="game-description">Leap over cacti and dodge pterodactyls in this endless runner classic. How long can you survive the ancient world? Press SPACE to jump!</p>
                <button class="play-btn" onclick="startGame('dino')">Play Now</button>
            </div>
            <div class="game-card">
                <h3 class="game-title">🐍 Neon Snake</h3>
                <p class="game-description">Guide the glowing serpent through the digital void. Collect energy orbs to grow longer, but don't crash into yourself! Use WASD or Arrow Keys.</p>
                <button class="play-btn" onclick="startGame('snake')">Play Now</button>
            </div>
            <div class="game-card">
                <h3 class="game-title">⚡ Cyber Pong</h3>
                <p class="game-description">The classic paddle game with a futuristic twist. Can you beat the AI opponent in this high-speed digital duel? Use W/S or ↑/↓ arrows.</p>
                <button class="play-btn" onclick="startGame('pong')">Play Now</button>
            </div>
            <div class="game-card">
                <h3 class="game-title">💫 Space Rocks</h3>
                <p class="game-description">Navigate your ship through a dangerous asteroid field. Blast the rocks to survive and rack up points! Use WASD to move, SPACE to shoot.</p>
                <button class="play-btn" onclick="startGame('asteroids')">Play Now</button>
            </div>
            <div class="game-card">
                <h3 class="game-title">🧱 Block Destroyer</h3>
                <p class="game-description">Break through the neon barrier with your energy ball. Clear all blocks to advance to the next level! Use A/D or ←/→ arrows.</p>
                <button class="play-btn" onclick="startGame('breakout')">Play Now</button>
            </div>
            <div class="game-card">
                <h3 class="game-title">🟦 Pixel Tetris</h3>
                <p class="game-description">Arrange falling blocks to form complete lines and clear them. Don't let the stack reach the top! Use Arrow Keys or WASD to move and rotate.</p>
                <button class="play-btn" onclick="startGame('tetris')">Play Now</button>
            </div>
            <div class="game-card">
                <h3 class="game-title">💣 Hidden Grid</h3>
                <p class="game-description">Clear the minefield without detonating any hidden mines! Click to reveal a square; if a number appears, it tells you how many mines are adjacent. Right-click (or Ctrl+Click) to flag suspected mine locations. Reveal all non-mine squares to win!</p>
                <button class="play-btn" onclick="startGame('minesweeper')">Play Now</button>
            </div>
            <div class="game-card">
                <h3 class="game-title">🚀 Galactic Invaders</h3>
                <p class="game-description">Defend your galaxy from waves of alien invaders! Move your ship left and right, and fire lasers to destroy them. Don't let them reach the bottom!</p>
                <button class="play-btn" onclick="startGame('galacticInvaders')">Play Now</button>
            </div>
            <!-- NEW FLAPPY BIRD GAME CARD -->
            <div class="game-card">
                <h3 class="game-title">🐦 Flappy Flight</h3>
                <p class="game-description">Guide the bird through a treacherous landscape of pipes! Press **SPACEBAR** to flap your wings and avoid obstacles. How far can you fly?</p>
                <button class="play-btn" onclick="startGame('flappyBird')">Play Now</button>
            </div>
            <!-- END NEW FLAPPY BIRD GAME CARD -->
        </div>

        <div id="gameArea" class="game-area">
            <h2 id="gameTitle"></h2>
            <!-- Generic score display, hidden for Minesweeper/GalacticInvaders which have custom info bars -->
            <div class="score" id="scoreDisplay">Score: 0</div> 

            <!-- Minesweeper specific info display -->
            <div id="minesweeperInfo">
                <span id="mineCountDisplay">Mines: 0</span>
                <span id="timerDisplay">Time: 0s</span>
            </div>

            <!-- Galactic Invaders specific info display -->
            <div id="galacticInvadersInfo">
                <span id="galacticScoreDisplay">Score: 0</span>
                <span id="galacticLivesDisplay">Lives: 3</span>
                <span id="galacticWaveDisplay">Wave: 1</span>
            </div>

            <!-- Pong Difficulty Selection -->
            <div id="pongDifficultySelection">
                <h3>Choose Difficulty:</h3>
                <label>
                    <input type="radio" name="pongDifficulty" value="easy" checked> Easy
                </label>
                <label>
                    <input type="radio" name="pongDifficulty" value="hard"> Hard
                </label>
                <button class="play-btn" onclick="startSelectedPongDifficulty()">Start Cyber Pong</button>
            </div>
            <canvas id="gameCanvas" class="game-canvas"></canvas>
            <div class="game-controls" id="gameControls"></div>
            <div class="action-buttons">
                <button class="control-btn" id="restartGameButton" onclick="restartGame()" style="background: #ffaa00;">🔄 Restart Game</button>
                <button class="back-btn" id="backToMenuButton" onclick="backToMenu()">← Back to Games</button>
            </div>
        </div>
    </div>

    <!-- Message box for start instructions or in-game messages -->
    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageBoxOkBtn">OK</button>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay">
        <div class="game-over-content">
            <h2>GAME OVER!</h2>
            <p id="finalScoreDisplay">Final Score: 0</p>
            <div class="game-over-buttons">
                <button onclick="restartGameFromGameOver()">Play Again</button>
                <button onclick="backToMenuFromGameOver()">Back to Menu</button>
            </div>
        </div>
    </div>

    <script>
        // === SOUND SYSTEM ===
        class SoundManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.masterVolume = 0.3;
                this.soundEnabled = true;
                this.initAudioContext();
                this.generateSounds();
            }

            initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.soundEnabled = false;
                }
            }

            generateSounds() {
                if (!this.audioContext) return;

                // Jump/Flap sound (quick chirp)
                this.sounds.jump = this.createChirpSound(200, 400, 0.1);
                this.sounds.flap = this.createChirpSound(300, 500, 0.08);
                
                // Collision/Hit sounds
                this.sounds.hit = this.createNoiseSound(0.15, 'brown');
                this.sounds.explosion = this.createExplosionSound();
                
                // Pickup/Score sounds
                this.sounds.pickup = this.createPickupSound();
                this.sounds.score = this.createScoreSound();
                this.sounds.levelUp = this.createLevelUpSound();
                
                // Game sounds
                this.sounds.shoot = this.createShootSound();
                this.sounds.bounce = this.createBounceSound();
                this.sounds.block = this.createBlockSound();
                this.sounds.paddle = this.createPaddleSound();
                
                // UI sounds
                this.sounds.select = this.createUISound(600, 800, 0.05);
                this.sounds.back = this.createUISound(400, 300, 0.08);
                
                // Win/Lose sounds
                this.sounds.win = this.createWinSound();
                this.sounds.gameOver = this.createGameOverSound();
            }

            createChirpSound(startFreq, endFreq, duration) {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * duration, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const freq = startFreq + (endFreq - startFreq) * (t / duration);
                    data[i] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 8) * 0.3;
                }
                return buffer;
            }

            createNoiseSound(duration, type = 'white') {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * duration, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    let noise = Math.random() * 2 - 1;
                    if (type === 'brown') noise *= Math.exp(-t * 10);
                    data[i] = noise * 0.2;
                }
                return buffer;
            }

            createExplosionSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.5, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const noise = Math.random() * 2 - 1;
                    const envelope = Math.exp(-t * 3);
                    data[i] = noise * envelope * 0.4;
                }
                return buffer;
            }

            createPickupSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.2, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const freq1 = 400 + 200 * Math.sin(t * 50);
                    const freq2 = 600 + 100 * Math.sin(t * 30);
                    data[i] = (Math.sin(2 * Math.PI * freq1 * t) + Math.sin(2 * Math.PI * freq2 * t)) * Math.exp(-t * 5) * 0.2;
                }
                return buffer;
            }

            createScoreSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.3, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const noteIndex = Math.floor(t * 9) % notes.length;
                    const freq = notes[noteIndex];
                    data[i] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 3) * 0.25;
                }
                return buffer;
            }

            createLevelUpSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.8, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                const notes = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const noteIndex = Math.floor(t * 4) % notes.length;
                    const freq = notes[noteIndex];
                    data[i] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 2) * 0.3;
                }
                return buffer;
            }

            createShootSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.1, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const freq = 800 - t * 400;
                    data[i] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 20) * 0.2;
                }
                return buffer;
            }

            createBounceSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.1, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const freq = 200 + 100 * Math.sin(t * 100);
                    data[i] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 15) * 0.25;
                }
                return buffer;
            }

            createBlockSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.15, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const freq1 = 400;
                    const freq2 = 600;
                    data[i] = (Math.sin(2 * Math.PI * freq1 * t) + Math.sin(2 * Math.PI * freq2 * t)) * Math.exp(-t * 8) * 0.15;
                }
                return buffer;
            }

            createPaddleSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.08, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const freq = 150 + 50 * Math.sin(t * 20);
                    data[i] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 20) * 0.2;
                }
                return buffer;
            }

            createUISound(startFreq, endFreq, duration) {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * duration, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const freq = startFreq + (endFreq - startFreq) * (t / duration);
                    data[i] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 10) * 0.15;
                }
                return buffer;
            }

            createWinSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 1.5, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                const melody = [523.25, 587.33, 659.25, 698.46, 783.99]; // C5, D5, E5, F5, G5
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const noteIndex = Math.floor(t * 3) % melody.length;
                    const freq = melody[noteIndex];
                    data[i] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 1.5) * 0.3;
                }
                return buffer;
            }

            createGameOverSound() {
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 1, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const freq = 200 - t * 150; // Descending tone
                    data[i] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 2) * 0.25;
                }
                return buffer;
            }

            play(soundName, volume = 1) {
                if (!this.soundEnabled || !this.audioContext || !this.sounds[soundName]) return;
                
                try {
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    
                    source.buffer = this.sounds[soundName];
                    gainNode.gain.value = this.masterVolume * volume;
                    
                    source.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    source.start();
                } catch (e) {
                    console.warn('Failed to play sound:', soundName, e);
                }
            }

            setMasterVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
            }

            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                return this.soundEnabled;
            }
        }

        // === PARTICLE SYSTEM ===
        class ParticleSystem {
            constructor(ctx) {
                this.ctx = ctx;
                this.particles = [];
            }

            createExplosion(x, y, color = '#ff4444', count = 15) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 400,
                        vy: (Math.random() - 0.5) * 400,
                        life: 1,
                        decay: Math.random() * 0.02 + 0.02,
                        size: Math.random() * 4 + 2,
                        color: color,
                        type: 'explosion'
                    });
                }
            }

            createTrail(x, y, color = '#00ffff', count = 3) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 10,
                        y: y + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 50,
                        vy: (Math.random() - 0.5) * 50,
                        life: 1,
                        decay: Math.random() * 0.05 + 0.05,
                        size: Math.random() * 2 + 1,
                        color: color,
                        type: 'trail'
                    });
                }
            }

            createPickupEffect(x, y, color = '#ffff00') {
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 150,
                        vy: Math.sin(angle) * 150,
                        life: 1,
                        decay: 0.03,
                        size: 3,
                        color: color,
                        type: 'pickup'
                    });
                }
            }

            update(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx * deltaTime;
                    particle.y += particle.vy * deltaTime;
                    particle.life -= particle.decay;
                    
                    if (particle.type === 'explosion') {
                        particle.vy += 200 * deltaTime; // gravity
                        particle.vx *= 0.98; // air resistance
                    }
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            draw() {
                this.ctx.save();
                for (const particle of this.particles) {
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.restore();
            }

            clear() {
                this.particles = [];
            }
        }

        // Initialize global systems
        let soundManager;
        let particleSystem;
        
        // Error handling and state management
        class GameStateManager {
            constructor() {
                this.isTransitioning = false;
                this.errorCount = 0;
                this.maxErrors = 10;
            }
            
            safeExecute(fn, context = 'Unknown', fallback = null) {
                try {
                    return fn();
                } catch (error) {
                    this.handleError(error, context);
                    return fallback;
                }
            }
            
            handleError(error, context) {
                this.errorCount++;
                console.error(`[RetroArcade Error in ${context}]:`, error);
                
                if (this.errorCount > this.maxErrors) {
                    console.error('Too many errors detected. Attempting emergency recovery.');
                    this.emergencyRecovery();
                }
            }
            
            emergencyRecovery() {
                try {
                    // Cancel any running animations
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    
                    // Reset game state
                    gameActive = false;
                    currentGame = null;
                    gameState = {};
                    
                    // Return to menu
                    document.getElementById('gameOverOverlay').classList.remove('active');
                    document.getElementById('messageBox').style.display = 'none';
                    document.getElementById('gameArea').style.display = 'none';
                    document.getElementById('gameSelection').style.display = 'grid';
                    document.getElementById('mainHeader').style.display = 'block';
                    
                    // Reset error count
                    this.errorCount = 0;
                    
                    console.log('Emergency recovery completed. Returned to main menu.');
                } catch (recoveryError) {
                    console.error('Emergency recovery failed:', recoveryError);
                    // Last resort: reload the page
                    setTimeout(() => location.reload(), 1000);
                }
            }
            
            validateGameState() {
                if (!currentGame) return true;
                
                const requiredElements = {
                    canvas: document.getElementById('gameCanvas'),
                    ctx: ctx,
                    gameArea: document.getElementById('gameArea')
                };
                
                for (const [name, element] of Object.entries(requiredElements)) {
                    if (!element) {
                        console.warn(`Missing required element: ${name}`);
                        return false;
                    }
                }
                
                return true;
            }
        }
        
        const gameStateManager = new GameStateManager();

        // Define global constants for original canvas dimensions
        // These are assumed based on the scaling ratios used in your code (e.g., /600, /400)
        const ORIGINAL_CANVAS_WIDTH = 600;
        const ORIGINAL_CANVAS_HEIGHT = 400;

        // Create animated stars background
        function createStars() {
            const starsContainer = document.getElementById('stars');
            starsContainer.innerHTML = ''; // Clear existing stars
            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = Math.random() * 3 + 1 + 'px';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        let currentGame = null;
        let animationFrameId = null; // Stores the requestAnimationFrame ID for the active game
        let canvas, ctx; // Main canvas and context

        let score = 0; // General score for games that only have one
        let gameState = {}; // Holds game-specific variables for the current game

        let gameActive = false; // Global flag to control game loop

        // Global variables for tracking previous canvas size for scaling active game elements
        // These track the size *after* the previous successful resize/initialization.
        let previousCanvasWidth = 0;
        let previousCanvasHeight = 0;

        // Get references to message box elements early to ensure they are defined
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageBoxOkBtn = document.getElementById('messageBoxOkBtn');

        // New helper function to reset canvas dimensions and display
        function resetCanvasDimensions() {
            if (canvas) {
                // Set internal canvas resolution to a reasonable default for initial calculations.
                // The actual desired resolution will be set by resizeCanvas() later.
                canvas.width = ORIGINAL_CANVAS_WIDTH; 
                canvas.height = ORIGINAL_CANVAS_HEIGHT;

                // Reset CSS dimensions to allow flexbox/auto sizing to correctly calculate
                // available space before resizeCanvas sets explicit pixel sizes.
                canvas.style.width = ''; // Clear explicit width
                canvas.style.height = ''; // Clear explicit height
                canvas.style.display = 'none'; // Ensure it's initially hidden for proper measurement later
            }
        }

        // New function to handle starting game from the overlay's "Start Game" button
        function startGameFromOverlay() {
            messageBox.style.display = 'none';
            gameActive = true;
            
            // Explicitly show game area and relevant UI elements AFTER 'Start Game' clicked
            document.getElementById('gameArea').style.display = 'flex'; 
            document.getElementById('gameTitle').style.display = 'block';
            document.getElementById('gameTitle').textContent = getGameTitle(currentGame); // Ensure title is set
            document.getElementById('restartGameButton').style.display = 'block';
            document.querySelector('.action-buttons').style.display = 'flex';

            // Show game-specific info bars
            if (currentGame === 'minesweeper') {
                document.getElementById('minesweeperInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none'; // Ensure generic score is hidden
                document.getElementById('galacticInvadersInfo').style.display = 'none'; // Ensure GI score is hidden
                canvas.addEventListener('click', handleMinesweeperClick);
                canvas.addEventListener('contextmenu', handleMinesweeperRightClick);
            } else if (currentGame === 'galacticInvaders') {
                document.getElementById('galacticInvadersInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none'; // Ensure generic score is hidden
                document.getElementById('minesweeperInfo').style.display = 'none'; // Ensure MS score is hidden
                updateGalacticInvadersScoreAndLives();
            } else { // All other games use generic score
                document.getElementById('minesweeperInfo').style.display = 'none';
                document.getElementById('galacticInvadersInfo').style.display = 'none';
                document.getElementById('scoreDisplay').style.display = 'block';
                updateScore(); // Ensure score is updated for single-score games
            }

            // NOW, with all relevant UI elements visible, resize the canvas
            // This call will set canvas.width/height to the correct dimensions for the game's aspect ratio.
            resizeCanvas();
            canvas.style.display = 'block'; // Make canvas visible after sizing

            // *** CRITICAL FIX: Re-position player ship for Galactic Invaders after canvas resize ***
            if (currentGame === 'galacticInvaders' && gameState.player) {
                const gameScale = canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH;
                // Position player such that the bottom of its drawn shape (which extends 15*scale below player.y)
                // is GI_PLAYER_Y_OFFSET * gameScale pixels from the canvas bottom.
                gameState.player.y = canvas.height - (GI_PLAYER_Y_OFFSET * gameScale) - (GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * gameScale); 
                gameState.player.x = canvas.width / 2; // Also recenter
            }
            // *** END CRITICAL FIX ***

            setupControls(currentGame);
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Modified showMessage to distinguish start overlay messages
        function showMessage(msg, isStartOverlay = false) {
            messageText.innerHTML = msg;
            
            if (isStartOverlay) {
                messageBoxOkBtn.textContent = 'Start Game';
                messageBoxOkBtn.onclick = startGameFromOverlay; // Attach specific start function
            } else { // Regular in-game message
                messageBoxOkBtn.textContent = 'OK';
                messageBoxOkBtn.onclick = hideMessage;
            }
            messageBox.style.display = 'block'; // This makes the message box visible
            gameActive = false; // Pause game logic
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // Ensure loop stops when message is shown
                animationFrameId = null;
            }
        }
        
        // hideMessage function
        function hideMessage() {
            messageBox.style.display = 'none';
            // Reset messageBoxOkBtn's onclick in case it was modified for a start overlay
            messageBoxOkBtn.onclick = hideMessage;
            messageBoxOkBtn.textContent = 'OK'; 

            gameActive = true; // Resume/start game logic
            
            // This hideMessage is primarily for non-start message boxes.
            // If it happens to be called after a start message, it just resumes the loop.
            // The canvas and other elements are made visible by startGameFromOverlay/startSelectedPongDifficulty.
            
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }


        // --- Keyboard Input Tracking (Centralized) ---
        const keysPressed = new Set(); // Tracks which keys are currently held down

        document.addEventListener('keydown', (e) => {
            // Only process input if a game is active AND the game over/start overlays are NOT active
            if (gameActive && 
                !document.getElementById('gameOverOverlay').classList.contains('active') &&
                document.getElementById('messageBox').style.display !== 'block') { 
                
                const lowerKey = e.key.toLowerCase();
                // Prevent default browser behavior for relevant keys
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd'].includes(lowerKey)) {
                    e.preventDefault();
                }
                keysPressed.add(lowerKey);

                // --- Game-specific input handling ---
                switch (currentGame) {
                    case 'dino':
                        if (lowerKey === ' ' && !gameState.dino.isJumping) {
                            gameState.dino.jump();
                        }
                        break;
                    case 'snake':
                        if (lowerKey === 'arrowup' || lowerKey === 'w') {
                            changeDirection('up');
                        } else if (lowerKey === 'arrowdown' || lowerKey === 's') {
                            changeDirection('down');
                        } else if (lowerKey === 'arrowleft' || lowerKey === 'a') {
                            changeDirection('left');
                        } else if (lowerKey === 'arrowright' || lowerKey === 'd') {
                            changeDirection('right');
                        }
                        break;
                    case 'asteroids':
                         if (lowerKey === ' ') {
                            shootBulletAsteroids();
                        }
                        break;
                    case 'tetris':
                        if (lowerKey === 'arrowup' || lowerKey === 'w') {
                            if (!e.repeat) { // Prevent multiple rotations on hold
                                rotatePiece(gameState.currentPiece, 1);
                            }
                        } else if (lowerKey === ' ') { // Hard drop
                            if (!e.repeat) {
                                while (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY + 1)) {
                                    gameState.pieceY++;
                                }
                                lockPiece();
                            }
                        }
                        break;
                    case 'galacticInvaders':
                        if (lowerKey === ' ' && gameState.player.canShoot) {
                            firePlayerBullet();
                        }
                        break;
                    case 'flappyBird':
                        if (lowerKey === ' ' && !gameState.isGameOver && !gameState.gameStarted) {
                            // First flap starts the game
                            gameState.gameStarted = true;
                        }
                        if (lowerKey === ' ' && !gameState.isGameOver && gameState.gameStarted) {
                            flapBird();
                        }
                        break;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed.delete(e.key.toLowerCase());
        });

        // --- Main Game Loop (requestAnimationFrame) - PERFORMANCE OPTIMIZED ---
        let lastFrameTime = 0;
        let frameCount = 0;
        let fpsUpdateTime = 0;
        
        // Performance monitoring
        let averageFrameTime = 16.67; // Target 60fps
        
        function gameLoop(currentTime) {
            // Stop if no game is selected or if game is not active
            if (!currentGame || !gameActive) return; 

            const deltaTime = (currentTime - lastFrameTime) / 1000; // DeltaTime in seconds
            
            // Performance monitoring
            frameCount++;
            if (currentTime - fpsUpdateTime >= 1000) {
                averageFrameTime = 1000 / frameCount;
                frameCount = 0;
                fpsUpdateTime = currentTime;
            }
            
            // Cap delta time to prevent spiral of death
            const clampedDeltaTime = Math.min(deltaTime, 1/30); // Max 30fps minimum
            lastFrameTime = currentTime;

            // Only clear canvas once per frame
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw specific game with error handling
            gameStateManager.safeExecute(() => {
                switch(currentGame) {
                    case 'dino': 
                        updateDino(clampedDeltaTime); 
                        drawDino(); 
                        break;
                    case 'snake': 
                        updateSnake(clampedDeltaTime); 
                        drawSnake(); 
                        break;
                    case 'pong': 
                        updatePong(clampedDeltaTime); 
                        drawPong(); 
                        break;
                    case 'asteroids': 
                        updateAsteroids(clampedDeltaTime); 
                        drawAsteroids(); 
                        break;
                    case 'breakout': 
                        updateBreakout(clampedDeltaTime); 
                        drawBreakout(); 
                        break;
                    case 'tetris': 
                        updateTetris(clampedDeltaTime); 
                        drawTetris(); 
                        break;
                    case 'minesweeper': 
                        updateMinesweeper(clampedDeltaTime); 
                        drawMinesweeper(); 
                        break;
                    case 'galacticInvaders': 
                        updateGalacticInvaders(clampedDeltaTime); 
                        drawGalacticInvaders(); 
                        break;
                    case 'flappyBird': 
                        updateFlappyBird(clampedDeltaTime); 
                        drawFlappyBird(); 
                        break;
                }
                
                // Update particle system if it exists
                if (particleSystem) {
                    particleSystem.update(clampedDeltaTime);
                    particleSystem.draw();
                }
            }, 'gameLoop', false);

            // Continue the loop only if game is active and not showing a message or game over screen
            if (gameActive && !document.getElementById('gameOverOverlay').classList.contains('active') &&
                document.getElementById('messageBox').style.display !== 'block') {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // Global function to handle canvas resizing and drawing - PERFORMANCE OPTIMIZED
        function resizeCanvas() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            const gameAreaElement = document.getElementById('gameArea');

            // Temporarily set canvas display to block to ensure it's part of the layout for clientWidth/Height calculations of its parent.
            // Store original display to restore it later if needed (e.g., if canvas was hidden before this call).
            // This is crucial for getting accurate clientWidth/Height from gameAreaElement
            const originalCanvasDisplay = canvas.style.display;
            canvas.style.display = 'block'; 

            // Get the current calculated dimensions of the game area container
            // These will reflect the space *after* other UI elements are shown/hidden.
            let availableWidth = gameAreaElement.clientWidth;
            let availableHeight = gameAreaElement.clientHeight;

            // Subtract heights of elements that are *siblings* to the canvas within gameArea
            // and positioned vertically (due to flex-direction: column).
            const elementsToSubtractHeight = [
                document.getElementById('gameTitle'),
                document.getElementById('scoreDisplay'),
                document.getElementById('minesweeperInfo'),
                document.getElementById('galacticInvadersInfo'),
                // document.getElementById('pongDifficultySelection'), // This should be hidden when canvas is shown
                document.querySelector('.action-buttons')
            ];

            elementsToSubtractHeight.forEach(el => {
                // Only subtract if the element is currently visible (not display:none)
                if (el && getComputedStyle(el).display !== 'none') {
                    availableHeight -= el.offsetHeight;
                    availableHeight -= parseFloat(getComputedStyle(el).marginTop) || 0;
                    availableHeight -= parseFloat(getComputedStyle(el).marginBottom) || 0;
                }
            });

            // If pong difficulty is visible, also subtract its height
            const pongDifficultySection = document.getElementById('pongDifficultySelection');
            if (pongDifficultySection && pongDifficultySection.style.display !== 'none') {
                 availableHeight -= pongDifficultySection.offsetHeight;
                 availableHeight -= parseFloat(getComputedStyle(pongDifficultySection).marginTop) || 0;
                 availableHeight -= parseFloat(getComputedStyle(pongDifficultySection).marginBottom) || 0;
            }


            // Subtract canvas's own vertical margins
            availableHeight -= parseFloat(getComputedStyle(canvas).marginTop) || 0;
            availableHeight -= parseFloat(getComputedStyle(canvas).marginBottom) || 0;

            // Ensure available dimensions are positive
            availableWidth = Math.max(10, availableWidth);
            availableHeight = Math.max(10, availableHeight);

            // Define target resolution for each game to maintain aspect ratio
            const giOriginalWidth = 600;
            const giOriginalHeight = 700;
            const fbOriginalWidth = 600;
            const fbOriginalHeight = 400;
            const tetrisOriginalCols = TETRIS_COLS;
            const tetrisOriginalRows = TETRIS_ROWS;
            const minesweeperOriginalCols = MINESWEEPER_DEFAULT_COLS;
            const minesweeperOriginalRows = MINESWEEPER_DEFAULT_ROWS;

            let targetWidth, targetHeight;
            let calculatedBlockSize; // For grid-based games

            switch (currentGame) {
                case 'tetris':
                    const maxBlockSizeTetrisX = Math.floor(availableWidth / tetrisOriginalCols);
                    const maxBlockSizeTetrisY = Math.floor(availableHeight / tetrisOriginalRows);
                    calculatedBlockSize = Math.min(maxBlockSizeTetrisX, maxBlockSizeTetrisY);
                    calculatedBlockSize = Math.max(10, calculatedBlockSize); // Minimum block size to ensure visibility

                    targetWidth = calculatedBlockSize * tetrisOriginalCols;
                    targetHeight = calculatedBlockSize * tetrisOriginalRows;
                    break;

                case 'minesweeper':
                    const maxCellSizeMinesweeperX = Math.floor(availableWidth / minesweeperOriginalCols);
                    const maxCellSizeMinesweeperY = Math.floor(availableHeight / minesweeperOriginalRows);
                    calculatedBlockSize = Math.min(maxCellSizeMinesweeperX, maxCellSizeMinesweeperY);
                    calculatedBlockSize = Math.max(10, calculatedBlockSize); // Minimum cell size

                    targetWidth = calculatedBlockSize * minesweeperOriginalCols;
                    targetHeight = calculatedBlockSize * minesweeperOriginalRows;
                    break;

                case 'galacticInvaders':
                    const giAspectRatio = giOriginalWidth / giOriginalHeight;
                    // Prioritize fitting width or height based on which is more constrained
                    if (availableWidth / giAspectRatio <= availableHeight) {
                        targetWidth = availableWidth;
                        targetHeight = availableWidth / giAspectRatio;
                    } else {
                        targetWidth = availableHeight * giAspectRatio;
                        targetHeight = availableHeight;
                    }
                    break;

                case 'flappyBird':
                    const fbAspectRatio = fbOriginalWidth / fbOriginalHeight;
                    if (availableWidth / fbAspectRatio <= availableHeight) {
                        targetWidth = availableWidth;
                        targetHeight = availableWidth / fbAspectRatio;
                    } else {
                        targetWidth = availableHeight * fbAspectRatio;
                        targetHeight = availableHeight;
                    }
                    break;

                default: // For Pong, Dino, Snake, Asteroids, Breakout
                    const defaultAspectRatio = ORIGINAL_CANVAS_WIDTH / ORIGINAL_CANVAS_HEIGHT;
                    if (availableWidth / defaultAspectRatio <= availableHeight) {
                        targetWidth = availableWidth;
                        targetHeight = availableWidth / defaultAspectRatio;
                    } else {
                        targetWidth = availableHeight * defaultAspectRatio;
                        targetHeight = availableHeight;
                    }
                    break;
            }

            // Ensure dimensions are positive
            targetWidth = Math.max(10, targetWidth);
            targetHeight = Math.max(10, targetHeight);

            // Set the internal canvas resolution (attributes)
            canvas.width = targetWidth;
            canvas.height = targetHeight;

            // Set the CSS display size to match the internal resolution, preventing stretching/blurriness
            canvas.style.width = `${targetWidth}px`;
            canvas.style.height = `${targetHeight}px`;

            // Restore canvas display if it was originally hidden, or keep it block if it was already block
            canvas.style.display = originalCanvasDisplay;

            // Update game-specific global sizes for drawing/logic based on new canvas size
            if (currentGame === 'tetris') {
                window.TETRIS_BLOCK_SIZE = calculatedBlockSize; // Use the calculated integer block size
            } else if (currentGame === 'minesweeper') {
                window.MINE_CELL_SIZE = calculatedBlockSize; // Use the calculated integer cell size
            }

            // --- Condition for Scaling Existing Game Elements ---
            // Scaling should only happen if:
            // 1. A game is active (gameActive and gameState exist).
            // 2. There was a *meaningful* previous size (previousCanvasWidth > 0).
            // 3. The canvas dimensions have genuinely changed from that meaningful previous size.
            // This explicitly handles window resizes *during* active gameplay.
            // It should NOT run for the initial setup of a new game.
            if (gameActive && gameState && previousCanvasWidth > 0 && previousCanvasHeight > 0 && 
                (canvas.width !== previousCanvasWidth || canvas.height !== previousCanvasHeight)) {
                
                const scaleX = canvas.width / previousCanvasWidth;
                const scaleY = canvas.height / previousCanvasHeight;

                switch (currentGame) {
                    case 'dino':
                        if (gameState.dino) {
                            gameState.dino.x *= scaleX;
                            gameState.dino.y *= scaleY;
                            gameState.dino.width *= scaleX;
                            gameState.dino.height *= scaleY;
                            gameState.dino.gravity *= scaleY;
                            gameState.dino.jumpStrength *= scaleY;
                            GROUND_LINE_Y = canvas.height - (canvas.height * DINO_Y_OFFSET_RATIO); // Recalculate based on new height
                        }
                        gameState.obstacles.forEach(obstacle => {
                            obstacle.x *= scaleX;
                            obstacle.y *= scaleY;
                            obstacle.width *= scaleX;
                            obstacle.height *= scaleY;
                        });
                        gameState.gameSpeed *= scaleX;
                        break;
                    case 'snake':
                        if (gameState.snake) {
                            gameState.gridSize *= scaleX; // Scale grid size
                            gameState.snake.forEach(segment => {
                                segment.x = Math.round(segment.x * scaleX); // Round to nearest grid cell
                                segment.y = Math.round(segment.y * scaleY);
                            });
                            gameState.food.x = Math.round(gameState.food.x * scaleX);
                            gameState.food.y = Math.round(gameState.food.y * scaleY);
                        }
                        break;
                    case 'pong':
                        if (gameState.paddle1) {
                            // Scale existing paddle properties
                            gameState.paddle1.x = Math.round(gameState.paddle1.x * scaleX);
                            gameState.paddle1.y = Math.round(gameState.paddle1.y * scaleY);
                            gameState.paddle1.width = Math.round(gameState.paddle1.width * scaleX);
                            gameState.paddle1.height = Math.round(gameState.paddle1.height * scaleY);
                            gameState.paddle1.speed *= scaleY;

                            // Recalculate paddle2's X based on new canvas width and paddle1's new position
                            // Paddle2's width should also be scaled first before calculating its X.
                            gameState.paddle2.width = Math.round(gameState.paddle2.width * scaleX);
                            gameState.paddle2.height = Math.round(gameState.paddle2.height * scaleY);
                            gameState.paddle2.speed *= scaleY;
                            
                            // The distance from the left for paddle1 is `gameState.paddle1.x`.
                            // So, paddle2's X should be `canvas.width - gameState.paddle2.width - gameState.paddle1.x`.
                            // This line ensures paddle2's x is re-calculated based on the new canvas width and its own scaled width.
                            // The initial paddleXOffset already dictates the margin, so using it again for paddle2's x is correct.
                            const paddleXOffset = Math.round(10 * scaleX); 
                            gameState.paddle2.x = Math.round(canvas.width - gameState.paddle2.width - paddleXOffset);
                            gameState.paddle2.y = Math.round(gameState.paddle2.y * scaleY); // Scale Y for paddle2
                            
                            gameState.ball.x *= scaleX;
                            gameState.ball.y *= scaleY;
                            gameState.ball.dx *= scaleX;
                            gameState.ball.dy *= scaleY;
                            gameState.ball.radius *= Math.min(scaleX, scaleY); // Keep ball round
                            gameState.initialBallSpeed *= scaleX;
                        }
                        break;
                    case 'asteroids':
                        if (gameState.ship) {
                            gameState.ship.x *= scaleX;
                            gameState.ship.y *= scaleY;
                            gameState.ship.thrust *= Math.min(scaleX, scaleY); // Scale thrust proportionally
                        }
                        gameState.bullets.forEach(bullet => {
                            bullet.x *= scaleX;
                            bullet.y *= scaleY;
                            bullet.vx *= scaleX;
                            bullet.vy *= scaleY;
                        });
                        gameState.asteroids.forEach(asteroid => {
                            asteroid.x *= scaleX;
                            asteroid.y *= scaleY;
                            asteroid.vx *= Math.min(scaleX, scaleY); // Scale asteroid speeds
                            asteroid.vy *= Math.min(scaleX, scaleY);
                            asteroid.radius *= Math.min(scaleX, scaleY);
                        });
                        break;
                    case 'breakout':
                        if (gameState.paddle) {
                            gameState.paddle.x *= scaleX;
                            gameState.paddle.y *= scaleY;
                            gameState.paddle.width *= scaleX;
                            gameState.paddle.height *= scaleY;
                            gameState.paddle.speed *= scaleX;
                        }
                        if (gameState.ball) {
                            gameState.ball.x *= scaleX;
                            gameState.ball.y *= scaleY;
                            gameState.ball.prevX *= scaleX;
                            gameState.ball.prevY *= scaleY;
                            gameState.ball.vx *= scaleX;
                            gameState.ball.vy *= scaleY;
                            gameState.ball.radius *= Math.min(scaleX, scaleY);
                        }
                        // Re-initialize block positions and dimensions based on the *new* canvas size
                        // instead of scaling individual block properties from their old values.
                        // This ensures they always fit the new canvas proportions correctly from a "fresh grid" perspective.
                        const blocksPerRow = 10;
                        const numRows = 5;
                        const originalBlockDesignHeight = 15; // Only needed for height calculation
                        const originalTopOffset = 60; // Offset from canvas top to the first row of blocks

                        // --- FIX FOR BREAKOUT: New aggressive approach to ensure blocks cover the entire width ---
                        // Calculate block width by dividing the total canvas width by blocksPerRow.
                        // This makes the blocks fill the entire width as much as possible.
                        const calculatedBlockWidth = Math.round(canvas.width / blocksPerRow);

                        // Explicitly set padding between blocks to 0 for maximum coverage
                        const calculatedBlockPadding = 0;

                        // Calculate the actual total width of the block grid with zero padding and rounded block width.
                        // This is necessary because `currentCanvasWidth` might not be perfectly divisible by `blocksPerRow`.
                        const actualTotalBlockGridWidth = blocksPerRow * calculatedBlockWidth;

                        // Calculate the left offset to center the grid of blocks within the canvas.
                        // This will distribute any tiny residual space (e.g., 0.5 pixels) from `Math.round` evenly.
                        const blockOffsetLeft = (canvas.width - actualTotalBlockGridWidth) / 2;

                        // Calculate the top offset for the blocks, scaled by the vertical canvas scale
                        const blockOffsetTop = Math.floor(originalTopOffset * (canvas.height / ORIGINAL_CANVAS_HEIGHT));

                        // Calculate the block height, scaled by the vertical canvas scale
                        const blockHeight = Math.floor(originalBlockDesignHeight * (canvas.height / ORIGINAL_CANVAS_HEIGHT));

                        // For vertical padding, you can choose:
                        // 1. Same as horizontal (which is now 0)
                        // 2. A small, fixed, scaled value (e.g., Math.floor(5 * scaleFactorY))
                        // Let's use a small, scaled value to have some vertical separation.
                        const verticalPaddingBetweenRows = Math.floor(5 * scaleY); // Use scaleY here

                        gameState.blocks.forEach((block, index) => {
                            const row = Math.floor(index / blocksPerRow);
                            const col = index % blocksPerRow;
                            block.x = blockOffsetLeft + col * (calculatedBlockWidth + calculatedBlockPadding);
                            block.y = blockOffsetTop + row * (blockHeight + verticalPaddingBetweenRows); // Use calculatedBlockPadding for vertical too
                            block.width = calculatedBlockWidth;
                            block.height = blockHeight;
                        });
                        break;
                    case 'galacticInvaders':
                        // When scaling elements in Galactic Invaders during a canvas resize,
                        // we must also re-evaluate the elements' dimensions relative to the new canvas size.
                        // The player and enemy ships' internal drawing uses a `entityScale` derived from the canvas width
                        // to maintain aspect ratio for their geometry. So we only need to update positions.
                        if (gameState.player) {
                            gameState.player.x *= scaleX;
                            // Recalculate player Y based on the new canvas height and original offset
                            const currentScale = canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH;
                            const playerActualDrawnBottomOffsetFromCenter = 15; // As defined in drawPlayerShip
                            gameState.player.y = canvas.height - (GI_PLAYER_Y_OFFSET * currentScale) - (GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * currentScale);
                        }
                        gameState.playerBullets.forEach(bullet => {
                            bullet.x *= scaleX;
                            bullet.y *= scaleY;
                            bullet.radius *= Math.min(scaleX, scaleY);
                            bullet.vy *= scaleY;
                        });
                        gameState.enemies.forEach(enemy => {
                            enemy.x *= scaleX;
                            enemy.y *= scaleY;
                            enemy.initialY *= scaleY;
                            enemy.diveTargetX *= scaleX;
                        });
                        gameState.enemyBullets.forEach(bullet => {
                            bullet.x *= scaleX;
                            bullet.y *= scaleY;
                            bullet.radius *= Math.min(scaleX, scaleY);
                            bullet.vy *= scaleY;
                        });
                        gameState.explosions.forEach(explosion => {
                            explosion.x *= scaleX;
                            explosion.y *= scaleY;
                        });
                        gameState.waveOscillationAmplitude *= scaleY;
                        break;
                    case 'flappyBird':
                        if (gameState.bird) {
                            gameState.bird.x *= scaleX;
                            gameState.bird.y *= scaleY;
                            gameState.bird.width *= scaleX;
                            gameState.bird.height *= scaleY;
                            gameState.bird.dy *= scaleY;
                            gameState.gravity *= scaleY;
                            gameState.jumpStrength *= scaleY;
                        }
                        gameState.pipes.forEach(pipe => {
                            pipe.x *= scaleX;
                            pipe.width *= scaleX;
                            pipe.topHeight *= scaleY;
                            pipe.gap *= scaleY; // Adjusted gap, scales with Y
                            pipe.speed *= scaleX;
                        });
                        gameState.groundHeight *= scaleY;
                        break;
                    case 'tetris':
                        if (gameState.currentPiece) {
                            gameState.pieceX = Math.floor(TETRIS_COLS / 2) - Math.floor(gameState.currentPiece[0].length / 2);
                        }
                        break;
                    case 'minesweeper':
                        break;
                }
            }
            
            // --- Update previousCanvasWidth/Height for the next resize event ---
            // ALWAYS update this to the NEW current canvas dimensions.
            // This ensures that `previousCanvasWidth`/`Height` always reflects the actual size of the canvas
            // after the *most recent* resize operation (whether it was an initial setup or a dynamic resize).
            previousCanvasWidth = canvas.width;
            previousCanvasHeight = canvas.height;

            // Force a redraw if game is active, regardless of whether scaling happened or not
            if (gameActive && ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // Use safe execution for resize redraws too
                gameStateManager.safeExecute(() => {
                    switch(currentGame) {
                        case 'dino': drawDino(); break;
                        case 'snake': drawSnake(); break;
                        case 'pong': drawPong(); break;
                        case 'asteroids': drawAsteroids(); break;
                        case 'breakout': drawBreakout(); break;
                        case 'tetris': drawTetris(); break;
                        case 'minesweeper': drawMinesweeper(); break;
                        case 'galacticInvaders': drawGalacticInvaders(); break;
                        case 'flappyBird': drawFlappyBird(); break;
                    }
                }, 'resizeCanvasRedraw', false);
            }
        }


        function startGame(gameType, difficulty = null) {
            return gameStateManager.safeExecute(() => {
                // Cancel any existing animation frame to prevent multiple loops
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }

            // Hide main game selection grid and the header
            document.getElementById('gameSelection').style.display = 'none'; 
            document.getElementById('mainHeader').style.display = 'none';
            
            // Hide all overlays that might be active
            document.getElementById('gameOverOverlay').classList.remove('active');
            document.getElementById('messageBox').style.display = 'none'; 

            currentGame = gameType; // Set current game
            
            // Initially hide the entire game area. It will be shown AFTER the "Start Game" button is clicked.
            document.getElementById('gameArea').style.display = 'none'; 

            // Reset previous canvas dimensions to 0. This is crucial for initial setup.
            previousCanvasWidth = 0; 
            previousCanvasHeight = 0;

            // *** IMPORTANT STEP: Reset canvas to a known small/default state ***
            resetCanvasDimensions();

            // Initialize game state *after* the canvas dimensions are reset.
            gameState = {}; // Clear game state for a fresh start
            switch(gameType) {
                case 'dino': initDino(); break;
                case 'snake': initSnake(); break;
                case 'asteroids': initAsteroids(); break;
                case 'breakout': initBreakout(); break;
                case 'tetris': initTetris(); break;
                case 'minesweeper': initMinesweeper(); break;
                case 'galacticInvaders': initGalacticInvaders(); break;
                case 'flappyBird': initFlappyBird(); break;
            }

            // Clear the canvas explicitly to remove any lingering drawings (important after init)
            // Note: Canvas is still display:none at this point due to resetCanvasDimensions. This just clears previous contents.
            if (ctx) { // Check if ctx is defined
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Clear general score and input keys for a fresh start.
            // Game-specific scores will be reset in their init functions.
            score = 0; 
            keysPressed.clear();

            // Remove previous game-specific listeners (if any)
            canvas.removeEventListener('click', handleMinesweeperClick);
            canvas.removeEventListener('contextmenu', handleMinesweeperRightClick);


            // Game-specific initializations for Pong or general message
            if (gameType === 'pong' && difficulty === null) {
                // For Pong, show difficulty selection immediately within the game area container
                document.getElementById('gameArea').style.display = 'flex'; // Show game area as container
                document.getElementById('pongDifficultySelection').style.display = 'flex';
                // Hide action buttons and ALL score displays during difficulty selection
                document.getElementById('restartGameButton').style.display = 'none';
                document.querySelector('.action-buttons').style.display = 'none';
                document.getElementById('scoreDisplay').style.display = 'none'; // Explicitly hide generic score
                document.getElementById('minesweeperInfo').style.display = 'none'; // Explicitly hide minesweeper info
                document.getElementById('galacticInvadersInfo').style.display = 'none'; // Explicitly hide GI info
                document.getElementById('gameTitle').style.display = 'none'; // Hide title during selection

                // The startSelectedPongDifficulty will handle the final resizeCanvas() call and canvas visibility.
            } else {
                // For other games, show the start instructions message.
                // The messageBox is absolutely positioned, so it does not need gameArea to be flex.
                const controlsText = getControlsText(gameType);
                showMessage(`**Controls:** ${controlsText}<br><br>Click 'Start Game' to begin the challenge!`, true);
                // startGameFromOverlay will handle showing gameArea and its.
            }
            }, 'startGame', false);
        }

        function startSelectedPongDifficulty() {
            const selectedDifficulty = document.querySelector('input[name="pongDifficulty"]:checked').value;
            
            // Initialize Pong after difficulty selected, ensures game state has correct difficulty
            initPong(selectedDifficulty); 

            document.getElementById('pongDifficultySelection').style.display = 'none'; // Hide difficulty selection

            // Explicitly show relevant UI elements AFTER difficulty is selected
            document.getElementById('gameArea').style.display = 'flex'; // Show the game area
            document.getElementById('gameTitle').style.display = 'block';
            document.getElementById('gameTitle').textContent = getGameTitle('pong');
            
            // Ensure only the correct score display is shown for Pong
            document.getElementById('galacticInvadersInfo').style.display = 'none';
            document.getElementById('minesweeperInfo').style.display = 'none';
            document.getElementById('scoreDisplay').style.display = 'block'; // Ensure generic score display is visible
            updateScore(); // Update Pong's specific score display
            
            document.getElementById('restartGameButton').style.display = 'block';
            document.querySelector('.action-buttons').style.display = 'flex';

            // Now, with all relevant UI elements visible, resize the canvas
            resizeCanvas();
            canvas.style.display = 'block'; // Make canvas visible after sizing

            setupControls('pong');
            gameActive = true;
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }


        function gameOver(status = 'lost') {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameActive = false; // Stop game logic

            // Get references to elements
            const finalScoreDisplay = document.getElementById('finalScoreDisplay');
            const gameOverH2 = document.getElementById('gameOverOverlay').querySelector('h2');
            const gameOverContent = document.getElementById('gameOverOverlay').querySelector('.game-over-content');

            if (currentGame === 'minesweeper') {
                if (status === 'won') {
                    gameOverH2.textContent = 'YOU WON!';
                    gameOverH2.style.color = '#00ff41';
                    gameOverH2.style.textShadow = '0 0 15px #00ff41';
                    gameOverContent.style.borderColor = '#00ff41';
                    finalScoreDisplay.textContent = `Time: ${gameState.timer}s`;
                } else {
                    gameOverH2.textContent = 'GAME OVER!';
                    gameOverH2.style.color = '#ff0041';
                    gameOverH2.style.textShadow = '0 0 15px #ff0041';
                    gameOverContent.style.borderColor = '#ff0041';
                    finalScoreDisplay.textContent = `You hit a mine!`;
                }
            } else if (currentGame === 'galacticInvaders') {
                gameOverH2.textContent = 'GAME OVER!';
                gameOverH2.style.color = '#ff0077'; // Galaga-like specific color
                gameOverH2.style.textShadow = '0 0 15px #ff0077';
                gameOverContent.style.borderColor = '#ff0077';
                finalScoreDisplay.textContent = `Final Score: ${gameState.score} (Wave ${gameState.wave})`; // Include wave in final score
            } else if (currentGame === 'pong') {
                gameOverH2.textContent = 'GAME OVER!';
                gameOverH2.style.color = '#ff0041';
                // textShadow: '0 0 15px #ff0041'; // Corrected syntax
                gameOverContent.style.borderColor = '#ff0041';
                finalScoreDisplay.textContent = `Player 1: ${gameState.player1Score} | Player 2: ${gameState.player2Score}`;
            }
            // For all other traditional score games
            else {
                gameOverH2.textContent = 'GAME OVER!';
                gameOverH2.style.color = '#ff0041';
                // textShadow: '0 0 15px #ff0041'; // Corrected syntax
                gameOverContent.style.borderColor = '#ff0041';
                finalScoreDisplay.textContent = `Final Score: ${score}`;
            }

            document.getElementById('gameOverOverlay').classList.add('active');
        }

        function restartGame() {
            // Cancel any running game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameActive = false; // Ensure game is marked inactive before re-init

            // Reset general score. Game-specific scores will be reset in their init functions.
            score = 0; 
            keysPressed.clear(); // Clear any pressed keys
            console.log(`[Game Restart] Current general score reset to: ${score}`); // Log for debugging

            // Hide all game-related UI elements explicitly before re-initializing or showing message box
            document.getElementById('restartGameButton').style.display = 'none'; 
            document.querySelector('.action-buttons').style.display = 'none'; 
            document.getElementById('scoreDisplay').style.display = 'none'; // Hide generic score
            document.getElementById('minesweeperInfo').style.display = 'none'; 
            document.getElementById('galacticInvadersInfo').style.display = 'none'; // Hide Galactic Invaders info
            document.getElementById('gameTitle').style.display = 'none'; // Explicitly hide game title
            document.getElementById('pongDifficultySelection').style.display = 'none'; // Hide pong difficulty if it was visible
            document.getElementById('gameArea').style.display = 'none'; // Hide the entire game area container

            // Reset previous canvas dimensions to 0. This is crucial for restarts.
            previousCanvasWidth = 0;
            previousCanvasHeight = 0;

            // *** IMPORTANT STEP: Reset canvas to a known small/default state ***
            resetCanvasDimensions();

            // Remove game specific listeners if any were added
            canvas.removeEventListener('click', handleMinesweeperClick); // For Minesweeper
            canvas.removeEventListener('contextmenu', handleMinesweeperRightClick);

            // Clear canvas explicitly before re-initializing (uses reset canvas dimensions)
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000'; // Fill with black
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            if (currentGame === 'pong') {
                // For Pong, go back to difficulty selection, which correctly calls startGame
                startGame('pong', null); 
            } else {
                // For other games, re-initialize and show the start message again.
                initializeGame(currentGame); 
                const controlsText = getControlsText(currentGame);
                showMessage(`**Controls:** ${controlsText}<br><br>Click 'Start Game' to begin the challenge!`, true); 
            }
        }

        function restartGameFromGameOver() {
            document.getElementById('gameOverOverlay').classList.remove('active');
            // Call restartGame for the current game, which handles all necessary resets and setup.
            restartGame(); 
        }


        function backToMenuFromGameOver() {
            document.getElementById('gameOverOverlay').classList.remove('active');
            backToMenu();
        }

        function backToMenu() {
            // Cancel any running game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameActive = false; // Reset gameActive when returning to menu

            // Clear canvas explicitly when going back to menu
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000'; // Fill with black
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Hide all game displays and overlays
            document.getElementById('gameArea').style.display = 'none'; // Ensure gameArea is hidden
            document.getElementById('pongDifficultySelection').style.display = 'none';
            document.getElementById('messageBox').style.display = 'none';
            document.getElementById('gameOverOverlay').classList.remove('active');

            // Show main menu and header
            document.getElementById('gameSelection').style.display = 'grid'; 
            document.getElementById('mainHeader').style.display = 'block';
            
            currentGame = null; // Clear current game selection
            score = 0; // Reset general score for the menu
            updateScore(); // Update the generic score display (will show Score: 0)
            keysPressed.clear(); // Clear any pressed keys

            // Reset previous canvas dimensions when returning to menu. This ensures that when a new game
            // starts, the `resizeCanvas` scaling logic is correctly bypassed on the *first* resize call.
            previousCanvasWidth = 0; 
            previousCanvasHeight = 0;

            // *** IMPORTANT STEP: Reset canvas dimensions when going back to menu ***
            resetCanvasDimensions();

            // Remove Minesweeper specific listeners
            canvas.removeEventListener('click', handleMinesweeperClick);
            canvas.removeEventListener('contextmenu', handleMinesweeperRightClick);
        }

        function updateScore() {
            // This function handles the scoreboard for ALL games, adapting its display.
            const scoreDisplayElement = document.getElementById('scoreDisplay');
            if (currentGame === 'pong') {
                // Pong uses separate player scores stored in gameState
                scoreDisplayElement.textContent = `Player: ${gameState.player1Score} | Computer: ${gameState.player2Score}`;
                scoreDisplayElement.style.display = 'block';
                document.getElementById('galacticInvadersInfo').style.display = 'none'; // Hide Galactic invaders info if active
                document.getElementById('minesweeperInfo').style.display = 'none'; // Hide minesweeper info if active
            } else if (currentGame === 'minesweeper') {
                // Minesweeper has its own info bar, so hide generic score
                scoreDisplayElement.style.display = 'none';
                document.getElementById('minesweeperInfo').style.display = 'flex'; // Ensure minesweeper info is visible
            } else if (currentGame === 'galacticInvaders') {
                // Galactic Invaders has its own info bar, so hide generic score
                scoreDisplayElement.style.display = 'none';
                // Call specific update for Galactic Invaders to ensure its elements are correctly shown
                updateGalacticInvadersScoreAndLives();
                document.getElementById('galacticInvadersInfo').style.display = 'flex'; // Ensure Galactic Invaders info is visible
            } else {
                // All other games use the single 'score' variable
                scoreDisplayElement.textContent = 'Score: ' + score;
                scoreDisplayElement.style.display = 'block';
                document.getElementById('minesweeperInfo').style.display = 'none'; // Hide if not minesweeper
                document.getElementById('galacticInvadersInfo').style.display = 'none'; // Hide if not galactic invaders
            }
        }

        // Helper function to initialize game state without starting the loop immediately
        function initializeGame(gameType, difficulty = null) {
            // This function now only handles the initial setup for traditional games
            // Canvas/context is already set up by startGame for the correct game type.

            // No clearRect here, it's handled when canvas is about to be drawn on
            
            switch(gameType) {
                case 'dino': initDino(); break;
                case 'snake': initSnake(); break;
                case 'pong': initPong(difficulty); break;
                case 'asteroids': initAsteroids(); break;
                case 'breakout': initBreakout(); break;
                case 'tetris': initTetris(); break;
                case 'minesweeper': initMinesweeper(); break;
                case 'galacticInvaders': initGalacticInvaders(); break;
                case 'flappyBird': initFlappyBird(); break;
            }
        }

        function getGameTitle(gameType) {
            const titles = {
                dino: '🦖 Prehistoric Run',
                snake: '🐍 Neon Snake',
                pong: '⚡ Cyber Pong',
                asteroids: '💫 Space Rocks',
                breakout: '🧱 Block Destroyer',
                tetris: '🟦 Pixel Tetris',
                minesweeper: '💣 Hidden Grid',
                galacticInvaders: '🚀 Galactic Invaders',
                flappyBird: '🐦 Flappy Flight'
            };
            return titles[gameType];
        }

        function getControlsText(gameType) {
            let instructions = '';
            switch (gameType) {
                case 'dino': instructions = 'Press **SPACEBAR** to jump over obstacles.'; break;
                case 'snake': instructions = 'Use **WASD** or **Arrow Keys** to change snake direction.'; break;
                case 'pong': instructions = 'Use **W** (Up) and **S** (Down) or **↑ Arrow** (Up) and **↓ Arrow** (Down) to move your paddle.'; break;
                case 'asteroids': instructions = 'Use **W** or **↑ Arrow** for thrust. Use **A** or **← Arrow** to rotate left. Use **D** (Right) or **→ Arrow** to rotate right. Press **SPACEBAR** to shoot.'; break;
                case 'breakout': instructions = 'Use **A** (Left) and **D** (Right) or **← Arrow** (Left) and **→ Arrow** (Right) to move your paddle.'; break;
                case 'tetris': instructions = 'Use **← Arrow / A** (Left), **→ Arrow / D** (Right), **↓ Arrow / S** (Soft Drop). Use **↑ Arrow / W** (Rotate). Press **SPACEBAR** for Hard Drop.'; break;
                case 'minesweeper': instructions = 'Click a square to reveal it. Right-click (or Ctrl+Click) to flag a mine. Clear all non-mine squares to win.'; break;
                case 'galacticInvaders': instructions = 'Use **A** (Left) and **D** (Right) or **← Arrow** (Left) and **→ Arrow** (Right) to move your ship. Press **SPACEBAR** to shoot.'; break;
                case 'flappyBird': instructions = 'Press **SPACEBAR** to make the bird flap. Avoid the pipes!'; break;
                default: instructions = 'Keyboard controls.';
            }
            return instructions;
        }

        function setupControls(gameType) {
            const controlsDiv = document.getElementById('gameControls');
            controlsDiv.innerHTML = ''; // Clear the content of the controls div
        }


        // --- Dino Game ---
        // GROUND_LINE_Y will now be relative to dynamic canvas.height
        let GROUND_LINE_Y;
        const DINO_Y_OFFSET_RATIO = 0.0125; // 5 / 400 = 0.0125 (original offset / original canvas height)
        const DINO_HEIGHT_RATIO = 0.125; // 50 / 400 = 0.125
        const DINO_WIDTH_RATIO = 0.05; // 30 / 600 = 0.05

        function initDino() {
            // Update constants based on current canvas size.
            // At this point, canvas.width/height reflect the *default* (e.g. 600x400) or
            // the last *correctly* set size if a window resize happened.
            const currentCanvasWidth = canvas.width;
            const currentCanvasHeight = canvas.height;

            const currentDinoHeight = currentCanvasHeight * DINO_HEIGHT_RATIO;
            const currentDinoWidth = currentCanvasWidth * DINO_WIDTH_RATIO;
            GROUND_LINE_Y = currentCanvasHeight - (currentCanvasHeight * DINO_Y_OFFSET_RATIO);

            gameState.dino = {
                x: 50 * (currentCanvasWidth / ORIGINAL_CANVAS_WIDTH), // Scale initial x based on the current canvas width
                y: GROUND_LINE_Y - currentDinoHeight, // Use scaled height
                width: currentDinoWidth,
                height: currentDinoHeight,
                dy: 0, 
                gravity: 2400 * (currentCanvasHeight / ORIGINAL_CANVAS_HEIGHT), // Scale gravity with height
                jumpStrength: -600 * (currentCanvasHeight / ORIGINAL_CANVAS_HEIGHT), // Scale jump strength with height
                isJumping: false,
                draw() {
                    if (!ctx) return;
                    const time = performance.now() * 0.01;
                    const bounce = this.isJumping ? Math.sin(time * 0.5) * 2 : 0;
                    
                    ctx.save();
                    ctx.translate(this.x + this.width/2, this.y + this.height/2);
                    
                    // Add shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(0, this.height/2 + 5, this.width * 0.8, this.height * 0.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Main body with gradient
                    const bodyGradient = ctx.createLinearGradient(-this.width/2, -this.height/2, this.width/2, this.height/2);
                    bodyGradient.addColorStop(0, '#32CD32');
                    bodyGradient.addColorStop(0.5, '#00ff41');
                    bodyGradient.addColorStop(1, '#228B22');
                    ctx.fillStyle = bodyGradient;
                    
                    // Body with slight animation
                    ctx.beginPath();
                    ctx.roundRect(-this.width/2, -this.height/2 + bounce, this.width * 0.8, this.height, 5);
                    ctx.fill();
                    
                    // Add body outline
                    ctx.strokeStyle = '#006400';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Head with animation
                    const headGradient = ctx.createRadialGradient(this.width * 0.3, -this.height * 0.3 + bounce, 0, this.width * 0.3, -this.height * 0.3 + bounce, this.width * 0.4);
                    headGradient.addColorStop(0, '#90EE90');
                    headGradient.addColorStop(1, '#32CD32');
                    ctx.fillStyle = headGradient;
                    
                    ctx.beginPath();
                    ctx.arc(this.width * 0.3, -this.height * 0.3 + bounce, this.width * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#006400';
                    ctx.stroke();
                    
                    // Eye with blinking animation
                    const eyeSize = Math.abs(Math.sin(time * 0.1)) > 0.95 ? 1 : 3; // Blink occasionally
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(this.width * 0.4, -this.height * 0.35 + bounce, eyeSize * (currentCanvasWidth / ORIGINAL_CANVAS_WIDTH), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Nostril
                    ctx.beginPath();
                    ctx.arc(this.width * 0.5, -this.height * 0.25 + bounce, 1 * (currentCanvasWidth / ORIGINAL_CANVAS_WIDTH), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Legs with running animation
                    const legOffset = Math.sin(time * 0.3) * 3;
                    ctx.fillStyle = '#228B22';
                    ctx.lineWidth = 3 * (currentCanvasWidth / ORIGINAL_CANVAS_WIDTH);
                    ctx.strokeStyle = '#228B22';
                    
                    // Left leg
                    ctx.beginPath();
                    ctx.moveTo(-this.width * 0.2, this.height * 0.3);
                    ctx.lineTo(-this.width * 0.2 + legOffset, this.height * 0.5);
                    ctx.stroke();
                    
                    // Right leg  
                    ctx.beginPath();
                    ctx.moveTo(this.width * 0.1, this.height * 0.3);
                    ctx.lineTo(this.width * 0.1 - legOffset, this.height * 0.5);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            };
            gameState.dino.jump = function() { if (!this.isJumping) { this.dy = this.jumpStrength; this.isJumping = true; soundManager.play('jump'); } };
            gameState.dino.update = function(deltaTime) {
                this.dy += this.gravity * deltaTime; // Apply gravity over time
                this.y += this.dy * deltaTime; // Apply vertical movement over time
                if (this.y + this.height > GROUND_LINE_Y) { this.y = GROUND_LINE_Y - this.height; this.dy = 0; this.isJumping = false; }
            };

            gameState.obstacles = [];
            gameState.gameSpeed = 500 * (currentCanvasWidth / ORIGINAL_CANVAS_WIDTH); // Initial speed, scaled
            gameState.obstacleSpawnTimer = 0; // In seconds
            gameState.obstacleSpawnInterval = 0.7; // Initial interval
        }

        function createDinoObstacle() {
            const scaleFactor = canvas.width / ORIGINAL_CANVAS_WIDTH;
            const obstacleTypes = [
                { width: 20 * scaleFactor, height: 40 * scaleFactor, color: '#ff0041' },
                { width: 30 * scaleFactor, height: 60 * scaleFactor, color: '#ff0041' },
                { width: 45 * scaleFactor, height: 25 * scaleFactor, color: '#ff0041', isFlying: true, yOffset: 100 * scaleFactor }
            ];
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            gameState.obstacles.push({
                x: canvas.width, y: type.isFlying ? (GROUND_LINE_Y - type.height - type.yOffset) : (GROUND_LINE_Y - type.height),
                width: type.width, height: type.height, color: type.color,
                draw() {
                    if (!ctx) return;
                    const time = performance.now() * 0.005;
                    
                    ctx.save();
                    ctx.translate(this.x + this.width/2, this.y + this.height/2);
                    
                    if (type.isFlying) {
                        // Flying pterodactyl with wing animation
                        const wingFlap = Math.sin(time * 8) * 0.3;
                        const hover = Math.sin(time * 3) * 2;
                        
                        ctx.translate(0, hover);
                        
                        // Body
                        const bodyGradient = ctx.createLinearGradient(-this.width/2, -this.height/2, this.width/2, this.height/2);
                        bodyGradient.addColorStop(0, '#8B0000');
                        bodyGradient.addColorStop(0.5, '#FF0041');
                        bodyGradient.addColorStop(1, '#DC143C');
                        ctx.fillStyle = bodyGradient;
                        
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.width * 0.3, this.height * 0.4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Wings
                        ctx.fillStyle = '#B22222';
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-this.width * 0.4, -this.height * 0.3 + wingFlap);
                        ctx.lineTo(-this.width * 0.6, this.height * 0.1 + wingFlap);
                        ctx.lineTo(-this.width * 0.2, this.height * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(this.width * 0.4, -this.height * 0.3 - wingFlap);
                        ctx.lineTo(this.width * 0.6, this.height * 0.1 - wingFlap);
                        ctx.lineTo(this.width * 0.2, this.height * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Beak
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.moveTo(this.width * 0.3, 0);
                        ctx.lineTo(this.width * 0.5, -this.height * 0.1);
                        ctx.lineTo(this.width * 0.5, this.height * 0.1);
                        ctx.closePath();
                        ctx.fill();
                        
                    } else {
                        // Ground cactus with spikes
                        const sway = Math.sin(time * 2) * 1;
                        
                        // Main cactus body
                        const cactusGradient = ctx.createLinearGradient(-this.width/2, -this.height/2, this.width/2, this.height/2);
                        cactusGradient.addColorStop(0, '#8B0000');
                        cactusGradient.addColorStop(0.5, this.color);
                        cactusGradient.addColorStop(1, '#8B0000');
                        ctx.fillStyle = cactusGradient;
                        
                        ctx.beginPath();
                        ctx.roundRect(-this.width/2 + sway, -this.height/2, this.width, this.height, 3);
                        ctx.fill();
                        
                        // Add spikes
                        ctx.fillStyle = '#654321';
                        for (let i = 0; i < 6; i++) {
                            const spikeY = -this.height/2 + (i * this.height/5);
                            ctx.beginPath();
                            ctx.moveTo(-this.width/2 + sway, spikeY);
                            ctx.lineTo(-this.width/2 - 3 + sway, spikeY - 2);
                            ctx.lineTo(-this.width/2 + sway, spikeY + 2);
                            ctx.fill();
                            
                            ctx.beginPath();
                            ctx.moveTo(this.width/2 + sway, spikeY);
                            ctx.lineTo(this.width/2 + 3 + sway, spikeY - 2);
                            ctx.lineTo(this.width/2 + sway, spikeY + 2);
                            ctx.fill();
                        }
                        
                        // Add some texture lines
                        ctx.strokeStyle = 'rgba(139, 0, 0, 0.5)';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(-this.width/3 + sway, -this.height/2 + i * this.height/3);
                            ctx.lineTo(-this.width/3 + sway, -this.height/2 + (i + 1) * this.height/3);
                            ctx.stroke();
                        }
                    }
                    
                    ctx.restore();
                }
            });
        }

        function updateDino(deltaTime) {
            // Cache frequently accessed values
            const obstacles = gameState.obstacles;
            const dino = gameState.dino;
            const gameSpeed = gameState.gameSpeed;
            
            // Update obstacles and collision detection in single pass
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.x -= gameSpeed * deltaTime;
                
                // Remove off-screen obstacles immediately
                if (obstacle.x + obstacle.width <= 0) {
                    obstacles.splice(i, 1);
                    continue;
                }
                
                // Collision detection
                if (dino.x < obstacle.x + obstacle.width && 
                    dino.x + dino.width > obstacle.x && 
                    dino.y < obstacle.y + obstacle.height && 
                    dino.y + dino.height > obstacle.y) {
                    soundManager.play('hit');
                    particleSystem.createExplosion(dino.x + dino.width/2, dino.y + dino.height/2, '#ff0041', 10);
                    gameOver(); 
                    return;
                }
            }
            
            // Obstacle spawning with performance checks
            gameState.obstacleSpawnTimer += deltaTime;
            if (gameState.obstacleSpawnTimer > gameState.obstacleSpawnInterval && obstacles.length < 3) {
                createDinoObstacle();
                gameState.obstacleSpawnTimer = 0;
                gameState.gameSpeed += 5 * deltaTime * (canvas.width / ORIGINAL_CANVAS_WIDTH);
                gameState.obstacleSpawnInterval = Math.max(0.3, gameState.obstacleSpawnInterval - (0.02 * deltaTime)); 
            }
            
            dino.update(deltaTime);
            // Reduce score increment frequency for performance
            if (Math.floor(performance.now() / 100) % 2 === 0) {
                score++; 
                updateScore();
            }
        }

        function drawDino() {
            if (!ctx) return;
            
            // Enhanced background with parallax effect
            const time = performance.now() * 0.001;
            
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#E0F6FF');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, GROUND_LINE_Y);
            
            // Moving clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 3; i++) {
                const cloudX = ((time * 20 + i * 200) % (canvas.width + 100)) - 50;
                const cloudY = 50 + i * 30;
                drawCloud(cloudX, cloudY, 40 + i * 10);
            }
            
            // Enhanced ground with texture
            const groundGradient = ctx.createLinearGradient(0, GROUND_LINE_Y, 0, canvas.height);
            groundGradient.addColorStop(0, '#8B4513');
            groundGradient.addColorStop(0.3, '#D2691E');
            groundGradient.addColorStop(1, '#CD853F');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, GROUND_LINE_Y, canvas.width, canvas.height - GROUND_LINE_Y);
            
            // Ground line with glow effect
            ctx.shadowColor = '#00ff41';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#00ff41';
            ctx.lineWidth = 3 * (canvas.width / ORIGINAL_CANVAS_WIDTH);
            ctx.beginPath();
            ctx.moveTo(0, GROUND_LINE_Y);
            ctx.lineTo(canvas.width, GROUND_LINE_Y);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Ground texture dots
            ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
            for (let x = 0; x < canvas.width; x += 20) {
                for (let y = GROUND_LINE_Y + 10; y < canvas.height; y += 15) {
                    if (Math.random() > 0.7) {
                        ctx.beginPath();
                        ctx.arc(x + Math.random() * 20, y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            gameState.dino.draw();
            for (let obstacle of gameState.obstacles) { 
                obstacle.draw(); 
            }
            
            // Speed lines effect when running fast
            if (gameState.gameSpeed > 600) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    const lineY = GROUND_LINE_Y - 50 - i * 20;
                    const lineX = (time * 500 + i * 100) % (canvas.width + 50);
                    ctx.beginPath();
                    ctx.moveTo(lineX, lineY);
                    ctx.lineTo(lineX - 30, lineY);
                    ctx.stroke();
                }
            }
        }
        
        function drawCloud(x, y, size) {
            ctx.save();
            ctx.translate(x, y);
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
            ctx.arc(size * 0.4, 0, size * 0.4, 0, Math.PI * 2);
            ctx.arc(-size * 0.4, 0, size * 0.4, 0, Math.PI * 2);
            ctx.arc(0, -size * 0.3, size * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        // --- End Dino Game ---


        // --- Snake Game ---
        const SNAKE_INITIAL_GRID_SIZE = 20; // Original grid size for scaling

        function initSnake() {
            const currentCanvasWidth = canvas.width;
            const currentCanvasHeight = canvas.height;
            const scaleFactor = currentCanvasWidth / ORIGINAL_CANVAS_WIDTH;
            const currentGridSize = SNAKE_INITIAL_GRID_SIZE * scaleFactor;
            gameState = {
                snake: [{x: 10, y: 10}], food: {x: 15, y: 15}, direction: {x: 1, y: 0}, nextDirection: {x: 1, y: 0},
                gridSize: currentGridSize,
                speed: 10, // Speed in terms of grid cells per second
                timeSinceLastMove: 0
            };
            spawnFood();
        }

        function updateSnake(deltaTime) {
            const moveInterval = 1 / gameState.speed;
            gameState.timeSinceLastMove += deltaTime;
            
            if (gameState.timeSinceLastMove >= moveInterval) {
                gameState.timeSinceLastMove -= moveInterval;
                gameState.direction = gameState.nextDirection;
                
                // Cache frequently used values
                const snake = gameState.snake;
                const head = {
                    x: snake[0].x + gameState.direction.x, 
                    y: snake[0].y + gameState.direction.y
                };
                
                // Pre-calculate grid boundaries
                const maxGridX = Math.floor(canvas.width / gameState.gridSize);
                const maxGridY = Math.floor(canvas.height / gameState.gridSize);
                
                // Boundary check
                if (head.x < 0 || head.x >= maxGridX || head.y < 0 || head.y >= maxGridY) {
                    gameOver(); 
                    return;
                }
                
                // Self-collision check (skip head at index 0)
                for (let i = 1; i < snake.length; i++) {
                    const segment = snake[i];
                    if (head.x === segment.x && head.y === segment.y) {
                        gameOver(); 
                        return;
                    }
                }
                
                snake.unshift(head);
                
                // Food collision and growth
                const food = gameState.food;
                if (head.x === food.x && head.y === food.y) {
                    score += 10; 
                    updateScore(); 
                    if (gameState.speed < 20) gameState.speed += 0.5; 
                    spawnFood();
                } else {
                    snake.pop();
                }
            }
        }

        function spawnFood() {
            const maxGridX = Math.floor(canvas.width / gameState.gridSize);
            const maxGridY = Math.floor(canvas.height / gameState.gridSize);
            do {
                gameState.food = {x: Math.floor(Math.random() * maxGridX), y: Math.floor(Math.random() * maxGridY)};
            } while (gameState.snake.some(segment => segment.x === gameState.food.x && segment.y === gameState.food.y));
        }

        function drawSnake() {
            if (!ctx) return;
            
            const time = performance.now() * 0.003;
            const padding = 2 * (canvas.width / ORIGINAL_CANVAS_WIDTH);
            
            // Draw grid background with subtle pattern
            ctx.fillStyle = 'rgba(30, 30, 50, 0.1)';
            const gridSize = gameState.gridSize;
            for (let x = 0; x < Math.ceil(canvas.width / gridSize); x++) {
                for (let y = 0; y < Math.ceil(canvas.height / gridSize); y++) {
                    if ((x + y) % 2 === 0) {
                        ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                    }
                }
            }
            
            // Draw snake with enhanced graphics
            for (let i = 0; i < gameState.snake.length; i++) {
                const segment = gameState.snake[i];
                const x = segment.x * gridSize;
                const y = segment.y * gridSize;
                const size = gridSize - padding;
                
                ctx.save();
                ctx.translate(x + gridSize/2, y + gridSize/2);
                
                if (i === 0) {
                    // Head with gradient and eyes
                    const headGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size/2);
                    headGradient.addColorStop(0, '#90EE90');
                    headGradient.addColorStop(0.7, '#00ff41');
                    headGradient.addColorStop(1, '#008000');
                    ctx.fillStyle = headGradient;
                    
                    ctx.beginPath();
                    ctx.roundRect(-size/2, -size/2, size, size, size/4);
                    ctx.fill();
                    
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-size/4, -size/4, size/8, 0, Math.PI * 2);
                    ctx.arc(size/4, -size/4, size/8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye highlights
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(-size/4 + 1, -size/4 - 1, size/16, 0, Math.PI * 2);
                    ctx.arc(size/4 + 1, -size/4 - 1, size/16, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    // Body segments with gradient and slight animation
                    const segmentIntensity = 1 - (i / gameState.snake.length) * 0.5;
                    const pulse = 1 + Math.sin(time + i * 0.5) * 0.05;
                    
                    const bodyGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size/2);
                    bodyGradient.addColorStop(0, `rgba(144, 238, 144, ${segmentIntensity})`);
                    bodyGradient.addColorStop(0.7, `rgba(0, 255, 65, ${segmentIntensity})`);
                    bodyGradient.addColorStop(1, `rgba(0, 128, 0, ${segmentIntensity})`);
                    ctx.fillStyle = bodyGradient;
                    
                    ctx.scale(pulse, pulse);
                    ctx.beginPath();
                    ctx.roundRect(-size/2, -size/2, size, size, size/6);
                    ctx.fill();
                    
                    // Add scale pattern
                    ctx.strokeStyle = `rgba(0, 100, 0, ${segmentIntensity * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, size/3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // Draw food with pulsing glow effect
            const foodX = gameState.food.x * gridSize;
            const foodY = gameState.food.y * gridSize;
            const foodSize = gridSize - padding;
            const glowIntensity = 0.5 + Math.sin(time * 4) * 0.3;
            
            ctx.save();
            ctx.translate(foodX + gridSize/2, foodY + gridSize/2);
            
            // Glow effect
            ctx.shadowColor = '#ff0041';
            ctx.shadowBlur = 15 * glowIntensity;
            
            // Food gradient
            const foodGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, foodSize/2);
            foodGradient.addColorStop(0, '#FFB6C1');
            foodGradient.addColorStop(0.5, '#FF69B4');
            foodGradient.addColorStop(0.8, '#ff0041');
            foodGradient.addColorStop(1, '#8B0000');
            ctx.fillStyle = foodGradient;
            
            const foodScale = 1 + Math.sin(time * 6) * 0.1;
            ctx.scale(foodScale, foodScale);
            
            ctx.beginPath();
            ctx.arc(0, 0, foodSize/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Food highlight
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(-foodSize/6, -foodSize/6, foodSize/6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function changeDirection(dir) {
            if (!gameState || !gameState.direction) return;
            const directions = { up: {x: 0, y: -1}, down: {x: 0, y: 1}, left: {x: -1, y: 0}, right: {x: 1, y: 0} };
            const newDir = directions[dir];
            if (newDir && (newDir.x !== -gameState.direction.x || newDir.y !== -gameState.direction.y)) { gameState.nextDirection = newDir; }
        }
        // --- End Snake Game ---


        // --- Asteroids Game ---
        const ASTEROIDS_SHOOT_COOLDOWN = 0.2;
        let lastShotTimeAsteroids = 0;

        function initAsteroids() {
            const currentCanvasWidth = canvas.width;
            const currentCanvasHeight = canvas.height;
            const scaleFactor = currentCanvasWidth / ORIGINAL_CANVAS_WIDTH;
            gameState = {
                ship: {x: currentCanvasWidth/2, y: currentCanvasHeight/2, angle: -Math.PI/2, vx: 0, vy: 0, thrust: 150 * scaleFactor, rotationSpeed: 3},
                bullets: [], asteroids: []
            };
            for (let i = 0; i < 5; i++) { spawnAsteroid(3); }
            score = 0; updateScore();
        }

        function updateAsteroids(deltaTime) {
            // Cache references for performance
            const ship = gameState.ship;
            const bullets = gameState.bullets;
            const asteroids = gameState.asteroids;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Ship controls and movement
            if (keysPressed.has('arrowup') || keysPressed.has('w')) {
                const cos = Math.cos(ship.angle);
                const sin = Math.sin(ship.angle);
                ship.vx += cos * ship.thrust * deltaTime;
                ship.vy += sin * ship.thrust * deltaTime;
            }
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) ship.angle -= ship.rotationSpeed * deltaTime;
            if (keysPressed.has('arrowright') || keysPressed.has('d')) ship.angle += ship.rotationSpeed * deltaTime;
            
            // Update ship position with damping
            ship.x += ship.vx * deltaTime;
            ship.y += ship.vy * deltaTime;
            const damping = 1 - 0.5 * deltaTime;
            ship.vx *= damping;
            ship.vy *= damping;
            
            // Screen wrapping for ship
            if (ship.x < 0) ship.x = canvasWidth;
            else if (ship.x > canvasWidth) ship.x = 0;
            if (ship.y < 0) ship.y = canvasHeight;
            else if (ship.y > canvasHeight) ship.y = 0;
            
            // Update bullets with boundary filtering
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;
                
                // Remove out-of-bounds bullets
                if (bullet.x < -10 || bullet.x > canvasWidth + 10 || 
                    bullet.y < -10 || bullet.y > canvasHeight + 10) {
                    bullets.splice(i, 1);
                }
            }
            
            // Update asteroids with screen wrapping
            for (const asteroid of asteroids) {
                asteroid.x += asteroid.vx * deltaTime;
                asteroid.y += asteroid.vy * deltaTime;
                
                if (asteroid.x < 0) asteroid.x = canvasWidth;
                else if (asteroid.x > canvasWidth) asteroid.x = 0;
                if (asteroid.y < 0) asteroid.y = canvasHeight;
                else if (asteroid.y > canvasHeight) asteroid.y = 0;
            }
            
            // Collision detection: bullets vs asteroids
            for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = bullets[bIndex];
                for (let aIndex = asteroids.length - 1; aIndex >= 0; aIndex--) {
                    const asteroid = asteroids[aIndex];
                    const dx = bullet.x - asteroid.x;
                    const dy = bullet.y - asteroid.y;
                    const distanceSq = dx * dx + dy * dy;
                    
                    if (distanceSq < asteroid.radius * asteroid.radius) {
                        bullets.splice(bIndex, 1);
                        score += 100;
                        updateScore();
                        
                        if (asteroid.size > 1) {
                            spawnAsteroid(asteroid.size - 1, asteroid.x, asteroid.y);
                            spawnAsteroid(asteroid.size - 1, asteroid.x, asteroid.y);
                        }
                        asteroids.splice(aIndex, 1);
                        break;
                    }
                }
            }
            
            // Ship collision with asteroids
            const shipDetectionRadius = 10 * (canvasWidth / ORIGINAL_CANVAS_WIDTH);
            for (const asteroid of asteroids) {
                const dx = ship.x - asteroid.x;
                const dy = ship.y - asteroid.y;
                const distanceSq = dx * dx + dy * dy;
                const totalRadius = asteroid.radius + shipDetectionRadius;
                
                if (distanceSq < totalRadius * totalRadius) {
                    gameOver();
                    return;
                }
            }
            
            // Spawn new wave if all asteroids destroyed
            if (asteroids.length === 0) {
                const levelMultiplier = Math.floor(score / 500) + 1;
                const asteroidsToSpawn = 5 + levelMultiplier;
                for (let i = 0; i < asteroidsToSpawn; i++) {
                    spawnAsteroid(3);
                }
            }
        }

        function drawAsteroids() {
            if (!ctx) return;
            const scaleFactor = canvas.width / ORIGINAL_CANVAS_WIDTH;
            const time = performance.now() * 0.001;
            
            // Space background with stars
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Twinkling stars
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 50; i++) {
                const starX = (i * 47) % canvas.width;
                const starY = (i * 73) % canvas.height;
                const twinkle = 0.3 + Math.sin(time * 3 + i) * 0.7;
                ctx.globalAlpha = twinkle;
                ctx.beginPath();
                ctx.arc(starX, starY, 1, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            // Enhanced ship with thruster effects
            ctx.save();
            ctx.translate(gameState.ship.x, gameState.ship.y);
            ctx.rotate(gameState.ship.angle);
            
            // Ship body with gradient
            const shipGradient = ctx.createLinearGradient(-10 * scaleFactor, 0, 15 * scaleFactor, 0);
            shipGradient.addColorStop(0, '#006400');
            shipGradient.addColorStop(0.5, '#00ff41');
            shipGradient.addColorStop(1, '#90EE90');
            ctx.fillStyle = shipGradient;
            
            ctx.beginPath();
            ctx.moveTo(15 * scaleFactor, 0);
            ctx.lineTo(-10 * scaleFactor, -8 * scaleFactor);
            ctx.lineTo(-5 * scaleFactor, 0);
            ctx.lineTo(-10 * scaleFactor, 8 * scaleFactor);
            ctx.closePath();
            ctx.fill();
            
            // Ship outline
            ctx.strokeStyle = '#00aa00';
            ctx.lineWidth = 2 * scaleFactor;
            ctx.stroke();
            
            // Thruster glow when moving
            if (keysPressed.has('arrowup') || keysPressed.has('w')) {
                const thrusterIntensity = 0.7 + Math.sin(time * 20) * 0.3;
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 10 * scaleFactor;
                
                const thrusterGradient = ctx.createLinearGradient(-5 * scaleFactor, 0, -15 * scaleFactor, 0);
                thrusterGradient.addColorStop(0, `rgba(255, 69, 0, ${thrusterIntensity})`);
                thrusterGradient.addColorStop(0.7, `rgba(255, 165, 0, ${thrusterIntensity * 0.7})`);
                thrusterGradient.addColorStop(1, `rgba(255, 255, 0, ${thrusterIntensity * 0.3})`);
                ctx.fillStyle = thrusterGradient;
                
                ctx.beginPath();
                ctx.moveTo(-8 * scaleFactor, -4 * scaleFactor);
                ctx.lineTo(-15 * scaleFactor + Math.random() * 3, 0);
                ctx.lineTo(-8 * scaleFactor, 4 * scaleFactor);
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            
            ctx.restore();
            
            // Enhanced bullets with trails
            gameState.bullets.forEach((bullet, index) => {
                // Bullet trail
                ctx.strokeStyle = `rgba(0, 255, 255, 0.3)`;
                ctx.lineWidth = 3 * scaleFactor;
                ctx.beginPath();
                ctx.moveTo(bullet.x, bullet.y);
                ctx.lineTo(bullet.x - bullet.vx * 0.02, bullet.y - bullet.vy * 0.02);
                ctx.stroke();
                
                // Bullet glow
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 8 * scaleFactor;
                
                const bulletGradient = ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, 4 * scaleFactor);
                bulletGradient.addColorStop(0, '#ffffff');
                bulletGradient.addColorStop(0.5, '#00ffff');
                bulletGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                ctx.fillStyle = bulletGradient;
                
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3 * scaleFactor, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            });
            
            // Enhanced asteroids with rotation and detail
            gameState.asteroids.forEach((asteroid, index) => {
                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(time * 0.5 + index);
                
                // Asteroid gradient
                const asteroidGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, asteroid.radius);
                asteroidGradient.addColorStop(0, '#8B4513');
                asteroidGradient.addColorStop(0.6, '#CD853F');
                asteroidGradient.addColorStop(1, '#654321');
                ctx.fillStyle = asteroidGradient;
                
                // Irregular asteroid shape
                ctx.beginPath();
                const points = 8;
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const radiusVariation = 0.7 + Math.sin(angle * 3 + index) * 0.3;
                    const x = Math.cos(angle) * asteroid.radius * radiusVariation;
                    const y = Math.sin(angle) * asteroid.radius * radiusVariation;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
                
                // Asteroid outline
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2 * scaleFactor;
                ctx.stroke();
                
                // Add some surface detail
                ctx.fillStyle = 'rgba(139, 69, 19, 0.5)';
                for (let j = 0; j < 3; j++) {
                    const craterAngle = (j / 3) * Math.PI * 2 + index;
                    const craterX = Math.cos(craterAngle) * asteroid.radius * 0.5;
                    const craterY = Math.sin(craterAngle) * asteroid.radius * 0.5;
                    ctx.beginPath();
                    ctx.arc(craterX, craterY, asteroid.radius * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }

        function shootBulletAsteroids() {
            const currentTime = performance.now() / 1000;
            if (currentTime - lastShotTimeAsteroids > ASTEROIDS_SHOOT_COOLDOWN) {
                const scaleFactor = canvas.width / ORIGINAL_CANVAS_WIDTH;
                gameState.bullets.push({
                    x: gameState.ship.x + Math.cos(gameState.ship.angle) * 15 * scaleFactor, y: gameState.ship.y + Math.sin(gameState.ship.angle) * 15 * scaleFactor,
                    vx: Math.cos(gameState.ship.angle) * 300 * scaleFactor + gameState.ship.vx, vy: Math.sin(gameState.ship.angle) * 300 * scaleFactor + gameState.ship.vy
                });
                lastShotTimeAsteroids = currentTime;
            }
        }

        function spawnAsteroid(size, x = null, y = null) {
            const scaleFactor = canvas.width / ORIGINAL_CANVAS_WIDTH;
            const radiusMap = { 3: 40, 2: 25, 1: 15 }; const speedMap = { 3: 60, 2: 90, 1: 120 };
            const asteroidRadius = radiusMap[size] * scaleFactor;
            const asteroidSpeed = speedMap[size] * scaleFactor;
            let asteroidX = x !== null ? x : Math.random() * canvas.width; let asteroidY = y !== null ? y : Math.random() * canvas.height;
            if (size === 3 && x === null && gameState.ship) {
                while (Math.sqrt(Math.pow(asteroidX - gameState.ship.x, 2) + Math.pow(asteroidY - gameState.ship.y, 2)) < 150 * scaleFactor) { // Scaled initial distance
                    asteroidX = Math.random() * canvas.width; asteroidY = Math.random() * canvas.height;
                }
            }
            gameState.asteroids.push({ x: asteroidX, y: asteroidY, vx: (Math.random() - 0.5) * asteroidSpeed, vy: (Math.random() - 0.5) * asteroidSpeed, radius: asteroidRadius, size: size });
        }
        // --- End Asteroids Game ---

        // --- Pong Game (Keeping your latest fix for reference) ---
        function initPong(difficulty) {
            gameState.difficulty = difficulty;
            const currentCanvasWidth = canvas.width;
            const currentCanvasHeight = canvas.height;

            const scaleFactorX = currentCanvasWidth / ORIGINAL_CANVAS_WIDTH;
            const scaleFactorY = currentCanvasHeight / ORIGINAL_CANVAS_HEIGHT;

            const paddleXOffset = Math.round(10 * scaleFactorX);
            const paddleWidth = Math.round(10 * scaleFactorX);
            const paddleHeight = Math.round(100 * scaleFactorY);

            let initialBallSpeed = 350 * scaleFactorX;
            if (difficulty === 'hard') {
                initialBallSpeed = 415 * scaleFactorX;
            }

            const randomXDir = Math.random() < 0.5 ? 1 : -1;
            const randomYDir = Math.random() < 0.5 ? 1 : -1;
            let aiPaddleSpeed;
            if (difficulty === 'easy') {
                aiPaddleSpeed = 275 * scaleFactorY;
            } else {
                aiPaddleSpeed = 300 * scaleFactorY;
            }

            gameState = {
                ...gameState,
                paddle1: {
                    x: paddleXOffset,
                    y: Math.round(currentCanvasHeight / 2 - (paddleHeight / 2)),
                    width: paddleWidth,
                    height: paddleHeight,
                    dy: 0,
                    speed: 212.5 * scaleFactorY
                },
                paddle2: {
                    x: Math.round(currentCanvasWidth - paddleWidth - paddleXOffset) + 42.5,
                    y: Math.round(currentCanvasHeight / 2 - (paddleHeight / 2)),
                    width: paddleWidth,
                    height: paddleHeight,
                    speed: aiPaddleSpeed
                },
                ball: {
                    x: currentCanvasWidth / 2,
                    y: currentCanvasHeight / 2,
                    dx: initialBallSpeed * randomXDir,
                    dy: initialBallSpeed * randomYDir,
                    radius: 8 * Math.min(scaleFactorX, scaleFactorY)
                },
                initialBallSpeed: initialBallSpeed,
                player1Score: 0,
                player2Score: 0
            };
            updateScore();

            /* Debug logs removed for performance */
            /* Canvas Width: */
            /* Calculated paddleXOffset (rounded): */
            /* Calculated paddleWidth (rounded): */
            /* Paddle1 and Paddle2 positions logged previously */
            /* Distances from edges logged previously */
            /* --------------------------------------------------------------- */
            /* --------------------------------------------------------------- */
            /* --------------------------------------------------------------- */
            /* --------------------------------------------------------------- */
        }

        function updatePong(deltaTime) {
            const scaleFactorY = canvas.height / ORIGINAL_CANVAS_HEIGHT;

            if (keysPressed.has('arrowup') || keysPressed.has('w')) { gameState.paddle1.y = Math.max(0, gameState.paddle1.y - gameState.paddle1.speed * deltaTime); }
            if (keysPressed.has('arrowdown') || keysPressed.has('s')) { gameState.paddle1.y = Math.min(canvas.height - gameState.paddle1.height, gameState.paddle1.y + gameState.paddle1.speed * deltaTime); }
            gameState.ball.x += gameState.ball.dx * deltaTime; gameState.ball.y += gameState.ball.dy * deltaTime;
            if (gameState.ball.y - gameState.ball.radius <= 0) { gameState.ball.y = gameState.ball.radius; gameState.ball.dy = -gameState.ball.dy; }
            else if (gameState.ball.y + gameState.ball.radius >= canvas.height) { gameState.ball.y = canvas.height - gameState.ball.radius; gameState.ball.dy = -gameState.ball.dy; }

            const ballHitPaddle1 = gameState.ball.dx < 0 &&
                gameState.ball.x - gameState.ball.radius <= gameState.paddle1.x + gameState.paddle1.width &&
                gameState.ball.y >= gameState.paddle1.y &&
                gameState.ball.y <= gameState.paddle1.y + gameState.paddle1.height;

            const ballHitPaddle2 = gameState.ball.dx > 0 &&
                gameState.ball.x + gameState.ball.radius >= gameState.paddle2.x &&
                gameState.ball.y >= gameState.paddle2.y &&
                gameState.ball.y <= gameState.paddle2.y + gameState.paddle2.height;

            // Ensure minimum velocity after collisions
            if (Math.abs(gameState.ball.dx) < 100 * (canvas.width / ORIGINAL_CANVAS_WIDTH)) {
                gameState.ball.dx = Math.sign(gameState.ball.dx) * 100 * (canvas.width / ORIGINAL_CANVAS_WIDTH);
            }
            if (Math.abs(gameState.ball.dy) < 100 * (canvas.height / ORIGINAL_CANVAS_HEIGHT)) {
                gameState.ball.dy = Math.sign(gameState.ball.dy) * 100 * (canvas.height / ORIGINAL_CANVAS_HEIGHT);
            }

            if (ballHitPaddle1) {
                gameState.ball.x = gameState.paddle1.x + gameState.paddle1.width + gameState.ball.radius;
                gameState.ball.dx = -gameState.ball.dx;
                gameState.ball.dy += (Math.random() * 50 - 25) * scaleFactorY;
                soundManager.play('paddle');
                particleSystem.createTrail(gameState.ball.x, gameState.ball.y, '#00ff41', 5);
            }
            else if (ballHitPaddle2) {
                gameState.ball.x = gameState.paddle2.x - gameState.ball.radius;
                gameState.ball.dx = -gameState.ball.dx;
                gameState.ball.dy += (Math.random() * 50 - 25) * scaleFactorY;
                soundManager.play('paddle');
                particleSystem.createTrail(gameState.ball.x, gameState.ball.y, '#ff0041', 5);
            }

            // --- NEW: Win Condition Logic ---
            const WINNING_SCORE = 4; // Define the score needed to win

            if (gameState.ball.x < 0) { // Ball went past left side (Player 2 scores)
                gameState.player2Score++;
                updateScore();
                if (gameState.player2Score >= WINNING_SCORE) { // Check if Player 2 reached winning score
                    gameOver("Player 2 Wins!"); // End the game
                    return; // Stop further updates
                }
                gameState.ball.x = canvas.width / 2;
                gameState.ball.y = canvas.height / 2;
                gameState.ball.dx = (Math.random() < 0.5 ? 1 : -1) * gameState.initialBallSpeed;
                gameState.ball.dy = (Math.random() < 0.5 ? 1 : -1) * gameState.initialBallSpeed;
            } else if (gameState.ball.x > canvas.width) { // Ball went past right side (Player 1 scores)
                gameState.player1Score++;
                updateScore();
                if (gameState.player1Score >= WINNING_SCORE) { // Check if Player 1 reached winning score
                    gameOver("Player 1 Wins!"); // End the game
                    return; // Stop further updates
                }
                gameState.ball.x = canvas.width / 2;
                gameState.ball.y = canvas.height / 2;
                gameState.ball.dx = (Math.random() < 0.5 ? 1 : -1) * gameState.initialBallSpeed;
                gameState.ball.dy = (Math.random() < 0.5 ? 1 : -1) * gameState.initialBallSpeed;
            }

            if (gameState.difficulty === 'easy') {
                let aiTargetY = gameState.ball.y - gameState.paddle2.height / 2;
                aiTargetY = Math.max(0, Math.min(canvas.height - gameState.paddle2.height, aiTargetY));
                const moveAmount = gameState.paddle2.speed * deltaTime;
                if (gameState.paddle2.y < aiTargetY) { gameState.paddle2.y = Math.min(aiTargetY, gameState.paddle2.y + moveAmount); }
                else if (gameState.paddle2.y > aiTargetY) { gameState.paddle2.y = Math.max(aiTargetY, gameState.paddle2.y - moveAmount); }
            } else {
                const scaleFactorX = canvas.width / ORIGINAL_CANVAS_WIDTH;
                const scaleFactorY = canvas.height / ORIGINAL_CANVAS_HEIGHT;

                let predictedY = gameState.ball.y;
                if (gameState.ball.dx > 0 && gameState.ball.x > canvas.width / 2) {
                    const timeToReachPaddleX = (gameState.paddle2.x - gameState.ball.x) / gameState.ball.dx;
                    if (timeToReachPaddleX > 0) { predictedY = gameState.ball.y + gameState.ball.dy * timeToReachPaddleX; predictedY = Math.max(0, Math.min(canvas.height, predictedY)); }
                }
                const humanError = (Math.random() - 0.5) * 15 * scaleFactorY;
                let aiTargetY = predictedY - gameState.paddle2.height / 2 + humanError;
                aiTargetY = Math.max(0, Math.min(canvas.height - gameState.paddle2.height, aiTargetY));
                const moveAmount = gameState.paddle2.speed * deltaTime;
                if (gameState.paddle2.y < aiTargetY) { gameState.paddle2.y = Math.min(aiTargetY, gameState.paddle2.y + moveAmount); }
                else if (gameState.paddle2.y > aiTargetY) { gameState.paddle2.y = Math.max(aiTargetY, gameState.paddle2.y - moveAmount); }
            }
        }

        function drawPong() {
            if (!ctx) return;
            const scaleFactorX = canvas.width / ORIGINAL_CANVAS_WIDTH;
            const scaleFactorY = canvas.height / ORIGINAL_CANVAS_HEIGHT;

            ctx.fillStyle = '#00ff41'; ctx.fillRect(gameState.paddle1.x, gameState.paddle1.y, gameState.paddle1.width, gameState.paddle1.height);
            ctx.strokeStyle = '#00cc00';
            ctx.lineWidth = 1 * Math.min(scaleFactorX, scaleFactorY);
            ctx.strokeRect(gameState.paddle1.x, gameState.paddle1.y, gameState.paddle1.width, gameState.paddle1.height);

            ctx.fillStyle = '#ff0041'; ctx.fillRect(gameState.paddle2.x, gameState.paddle2.y, gameState.paddle2.width, gameState.paddle2.height);
            ctx.strokeStyle = '#cc0033';
            ctx.lineWidth = 1 * Math.min(scaleFactorX, scaleFactorY);
            ctx.strokeRect(gameState.paddle2.x, gameState.paddle2.y, gameState.paddle2.width, gameState.paddle2.height);

            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#00ff41';
            ctx.setLineDash([5 * scaleFactorX, 5 * scaleFactorX]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        // --- End Pong Game ---

        // --- Breakout Game ---
        function initBreakout() {
            const currentCanvasWidth = canvas.width;
            const currentCanvasHeight = canvas.height;
            const scaleFactorX = currentCanvasWidth / ORIGINAL_CANVAS_WIDTH;
            const scaleFactorY = currentCanvasHeight / ORIGINAL_CANVAS_HEIGHT;

            // Caluclate paddle dimensions first
            const paddleWidth = 100 * scaleFactorX;
            const paddleHeight = 10 * scaleFactorY;

            gameState = {
                paddle: {
                    x: (currentCanvasWidth / 2 - (paddleWidth / 2)) + (30 * scaleFactorX),
                    y: currentCanvasHeight - (10 * scaleFactorY), // Paddle remains lower
                    width: 100 * scaleFactorX,
                    height: 10 * scaleFactorY,
                    speed: 250 * scaleFactorX
                },
                ball: {
                    x: currentCanvasWidth / 2,
                    y: currentCanvasHeight - (30 * scaleFactorY),
                    vx: 335 * scaleFactorX,
                    vy: -335 * scaleFactorY,
                    radius: 8 * Math.min(scaleFactorX, scaleFactorY),
                    prevX: 0, prevY: 0
                },
                blocks: [], blocksRemaining: 0
            };

            const blocksPerRow = 10; // Keeping 10 bricks
            const numRows = 5;
            const originalBlockDesignHeight = 15;
            const originalTopOffset = 60;

            // --- Calculate Stretched Block Dimensions ---
            const baseWidthWithoutStretch = currentCanvasWidth / blocksPerRow;
            const stretchAmountPerBlock = 6 * scaleFactorX; // Adjust this number (e.g., 5, 10, 15) for brick width
            const blockWidth = Math.round(baseWidthWithoutStretch + stretchAmountPerBlock);
            const totalStretchedBlocksWidth = blocksPerRow * blockWidth;

            // Calculate the left offset to center the stretched blocks, THEN ADD an additional manual shift
            let blockOffsetLeft = (currentCanvasWidth - totalStretchedBlocksWidth) / 2;
            blockOffsetLeft += (22.5 * scaleFactorX); // <-- UNCOMMENTED AND INCREASED THIS VALUE TO SHIFT BLOCKS RIGHT

            const blockOffsetTop = Math.floor(originalTopOffset * scaleFactorY);
            const blockHeight = Math.floor(originalBlockDesignHeight * scaleFactorY);
            const verticalPaddingBetweenRows = Math.floor(5 * scaleFactorY);


            /* Breakout debug logs removed for performance */
            

            // Loop to create blocks
            for (let row = 0; row < numRows; row++) {
                let currentX = blockOffsetLeft;
                for (let col = 0; col < blocksPerRow; col++) {
                    gameState.blocks.push({
                        x: currentX,
                        y: blockOffsetTop + row * (blockHeight + verticalPaddingBetweenRows),
                        width: blockWidth,
                        height: blockHeight,
                        color: `hsl(${row * 50}, 100%, 50%)`,
                        hits: 5 - row
                    });
                    gameState.blocksRemaining++;

                    currentX += blockWidth;
                }
            }
            score = 0; updateScore();
        }

        function checkCollision(ball, rect) {
            return ball.x + ball.radius > rect.x && ball.x - ball.radius < rect.x + rect.width &&
                ball.y + ball.radius > rect.y && ball.y - ball.radius < rect.y + rect.height;
        }

        function getCollisionResponse(ball, block) {
            let hitX = false; let hitY = false;
            if (ball.prevX + ball.radius <= block.x && ball.x + ball.radius > block.x) {
                ball.x = block.x - ball.radius; ball.vx *= -1; hitX = true;
            }
            else if (ball.prevX - ball.radius >= block.x + block.width && ball.x - ball.radius < block.x + block.width) {
                ball.x = block.x + block.width + ball.radius; ball.vx *= -1; hitX = true;
            }
            if (ball.prevY + ball.radius <= block.y && ball.y + ball.radius > block.y) {
                ball.y = block.y - ball.radius; ball.vy *= -1; hitY = true;
            }
            else if (ball.prevY - ball.radius >= block.y + block.height && ball.y - ball.radius < block.y + block.height) {
                ball.y = block.y + block.height + ball.radius; ball.vy *= -1; hitY = true;
            }
            return hitX || hitY;
        }

        function updateBreakout(deltaTime) {
            const scaleFactorX = canvas.width / ORIGINAL_CANVAS_WIDTH;
            const scaleFactorY = canvas.height / ORIGINAL_CANVAS_HEIGHT; // <--- ADDED THIS LINE
            const maxBallSpeed = 600 * scaleFactorX; // Define a max speed for the ball

            if (keysPressed.has('arrowleft') || keysPressed.has('a')) { gameState.paddle.x = Math.max(0, gameState.paddle.x - gameState.paddle.speed * deltaTime); }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) { gameState.paddle.x = Math.min(canvas.width - gameState.paddle.width, gameState.paddle.x + gameState.paddle.speed * deltaTime); }
            gameState.ball.prevX = gameState.ball.x; gameState.ball.prevY = gameState.ball.y;
            gameState.ball.x += gameState.ball.vx * deltaTime;
            gameState.ball.y += gameState.ball.vy * deltaTime;

            // Wall collisions
            if (gameState.ball.x - gameState.ball.radius <= 0) {
                gameState.ball.x = gameState.ball.radius;
                gameState.ball.vx = -gameState.ball.vx;
            } else if (gameState.ball.x + gameState.ball.radius >= canvas.width) {
                gameState.ball.x = canvas.width - gameState.ball.radius;
                gameState.ball.vx = -gameState.ball.vx;
            }
            if (gameState.ball.y - gameState.ball.radius <= 0) { // Top wall collision
                gameState.ball.y = gameState.ball.radius;
                gameState.ball.vy = -gameState.ball.vy;
            }

            // Paddle collision
            if (gameState.ball.vy > 0 && // Moving downwards
                gameState.ball.x + gameState.ball.radius > gameState.paddle.x &&
                gameState.ball.x - gameState.ball.radius < gameState.paddle.x + gameState.paddle.width &&
                gameState.ball.y + gameState.ball.radius >= gameState.paddle.y &&
                gameState.ball.prevY + gameState.ball.radius < gameState.paddle.y) {
                gameState.ball.y = gameState.paddle.y - gameState.ball.radius;
                gameState.ball.vy = -gameState.ball.vy;

                const hitPoint = gameState.ball.x - (gameState.paddle.x + gameState.paddle.width / 2);
                gameState.ball.vx = hitPoint * 2 * scaleFactorX; // Original calculation

                // CAP THE BALL'S HORIZONTAL VELOCITY after paddle hit
                gameState.ball.vx = Math.max(-maxBallSpeed, Math.min(maxBallSpeed, gameState.ball.vx));
                // Ensure some minimum speed to avoid getting stuck or going perfectly vertical too often
                if (Math.abs(gameState.ball.vx) < 50 * scaleFactorX) { // If too slow horizontally
                    gameState.ball.vx = (gameState.ball.vx >= 0 ? 1 : -1) * 50 * scaleFactorX; // Give it a minimum horizontal push
                }

                // Cap the vertical velocity too, just in case
                gameState.ball.vy = Math.max(-maxBallSpeed, Math.min(maxBallSpeed, gameState.ball.vy));
                // Ensure it always has some vertical speed when going up
                if (gameState.ball.vy > -50 * scaleFactorY && gameState.ball.vy < 0) {
                    gameState.ball.vy = -50 * scaleFactorY;
                }
            }

            // Block collisions
            for (let i = gameState.blocks.length - 1; i >= 0; i--) {
                const block = gameState.blocks[i];
                if (checkCollision(gameState.ball, block)) {
                    if (getCollisionResponse(gameState.ball, block)) {
                        block.hits--;
                        if (block.hits <= 0) {
                            score += 10;
                            updateScore();
                            gameState.blocks.splice(i, 1);
                            gameState.blocksRemaining--;
                        }
                        // Cap velocity after hitting a block as well
                        gameState.ball.vx = Math.max(-maxBallSpeed, Math.min(maxBallSpeed, gameState.ball.vx));
                        gameState.ball.vy = Math.max(-maxBallSpeed, Math.min(maxBallSpeed, gameState.ball.vy));
                        break; // Exit loop after first collision
                    }
                }
            }

            // Game Over conditions
            if (gameState.ball.y - gameState.ball.radius > canvas.height) {
                console.log("GAME OVER: Ball went below canvas. Ball Y:", gameState.ball.y.toFixed(2), "Canvas Height:", canvas.height);
                gameOver();
                return;
            }
            if (gameState.blocksRemaining === 0) {
                console.log("GAME OVER: All blocks cleared!");
                gameOver();
                return;
            }

            // Debug logging removed to reduce console noise and improve performance
        }

        function drawBreakout() {
            if (!ctx) return;
            const time = performance.now() * 0.003;
            
            // Space background
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#000033');
            bgGradient.addColorStop(0.7, '#000011');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Enhanced paddle with glow
            ctx.save();
            ctx.shadowColor = '#00ff41';
            ctx.shadowBlur = 15;
            
            const paddleGradient = ctx.createLinearGradient(gameState.paddle.x, gameState.paddle.y, 
                                                           gameState.paddle.x, gameState.paddle.y + gameState.paddle.height);
            paddleGradient.addColorStop(0, '#90EE90');
            paddleGradient.addColorStop(0.5, '#00ff41');
            paddleGradient.addColorStop(1, '#006400');
            ctx.fillStyle = paddleGradient;
            
            ctx.beginPath();
            ctx.roundRect(gameState.paddle.x, gameState.paddle.y, gameState.paddle.width, gameState.paddle.height, 5);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();
            
            // Enhanced ball with trail and glow
            ctx.save();
            
            // Ball trail
            for (let i = 0; i < 5; i++) {
                const trailAlpha = (5 - i) / 5 * 0.3;
                const trailX = gameState.ball.x - gameState.ball.vx * 0.01 * i;
                const trailY = gameState.ball.y - gameState.ball.vy * 0.01 * i;
                
                ctx.globalAlpha = trailAlpha;
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(trailX, trailY, gameState.ball.radius * (1 - i * 0.1), 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20;
            
            const ballGradient = ctx.createRadialGradient(
                gameState.ball.x - gameState.ball.radius/3, gameState.ball.y - gameState.ball.radius/3, 0,
                gameState.ball.x, gameState.ball.y, gameState.ball.radius
            );
            ballGradient.addColorStop(0, '#ffffff');
            ballGradient.addColorStop(0.3, '#87CEEB');
            ballGradient.addColorStop(1, '#00ffff');
            ctx.fillStyle = ballGradient;
            
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.restore();
            
            // Enhanced blocks with animations and effects
            gameState.blocks.forEach((block, index) => {
                ctx.save();
                
                // Block pulsing animation
                const pulse = 1 + Math.sin(time * 2 + index * 0.1) * 0.05;
                const centerX = block.x + block.width/2;
                const centerY = block.y + block.height/2;
                
                ctx.translate(centerX, centerY);
                ctx.scale(pulse, pulse);
                ctx.translate(-block.width/2, -block.height/2);
                
                // Block gradient based on hits remaining
                const intensity = block.hits / 5;
                const blockGradient = ctx.createLinearGradient(0, 0, 0, block.height);
                
                // Parse HSL from block.color and enhance it
                const hslMatch = block.color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (hslMatch) {
                    const hue = parseInt(hslMatch[1]);
                    blockGradient.addColorStop(0, `hsl(${hue}, 100%, ${60 + intensity * 20}%)`);
                    blockGradient.addColorStop(0.5, block.color);
                    blockGradient.addColorStop(1, `hsl(${hue}, 80%, ${30 + intensity * 10}%)`);
                }
                
                ctx.fillStyle = blockGradient;
                ctx.beginPath();
                ctx.roundRect(0, 0, block.width, block.height, 3);
                ctx.fill();
                
                // Block border with glow
                ctx.shadowColor = block.color;
                ctx.shadowBlur = 5;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Hit indicator dots
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                for (let i = 0; i < block.hits; i++) {
                    const dotX = (i + 1) * block.width / (block.hits + 1);
                    const dotY = block.height / 2;
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
            
            // Add some ambient particles
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 20; i++) {
                const particleX = (Math.sin(time * 0.5 + i) * canvas.width/4) + canvas.width/2;
                const particleY = (Math.cos(time * 0.3 + i * 0.7) * canvas.height/4) + canvas.height/2;
                ctx.beginPath();
                ctx.arc(particleX, particleY, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }
// --- End Breakout Game ---


        // --- Tetris Game ---
        const TETRIS_COLS = 10;
        const TETRIS_ROWS = 20;
        // TETRIS_BLOCK_SIZE will be dynamically calculated in resizeCanvas

        const TETROMINOS = {
            'I': { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: '#00ffff' },
            'J': { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: '#0000ff' },
            'L': { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: '#ffa500' },
            'O': { shape: [[1, 1], [1, 1]], color: '#ffff00' },
            'S': { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: '#00ff00' },
            'T': { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: '#800080' },
            'Z': { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: '#ff0000' }
        };

        function initTetris() {
            // Re-calculate TETRIS_BLOCK_SIZE based on current canvas width, ensuring it's set for new game
            window.TETRIS_BLOCK_SIZE = Math.floor(canvas.width / TETRIS_COLS);

            gameState = {
                board: Array(TETRIS_ROWS).fill(0).map(() => Array(TETRIS_COLS).fill(0)),
                currentPiece: null, nextPiece: null, pieceX: 0, pieceY: 0, currentPieceColor: '',
                dropCounter: 0, dropInterval: 1, level: 1, linesCleared: 0, score: 0, isGameOver: false, lastMoveTime: 0
            };
            generateNewPiece(); gameState.dropCounter = 0; gameState.lastMoveTime = performance.now(); score = 0; updateScore();
        }

        function generateNewPiece() {
            const pieceKeys = Object.keys(TETROMINOS);
            const randomKey = pieceKeys[Math.floor(Math.random() * pieceKeys.length)];
            const pieceData = TETROMINOS[randomKey];
            gameState.currentPiece = JSON.parse(JSON.stringify(pieceData.shape)); // Deep copy
            gameState.currentPieceColor = pieceData.color;
            gameState.pieceX = Math.floor(TETRIS_COLS / 2) - Math.floor(gameState.currentPiece[0].length / 2);
            gameState.pieceY = 0;

            // Check for game over condition immediately after spawning a new piece
            if (checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY)) {
                gameState.isGameOver = true;
                gameOver();
            }
        }

        function checkTetrisCollision(board, piece, offsetX, offsetY) {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] !== 0) { // If it's a block in the tetromino
                        const boardX = x + offsetX;
                        const boardY = y + offsetY;

                        // Check for collision with walls or bottom
                        if (boardX < 0 || boardX >= TETRIS_COLS || boardY >= TETRIS_ROWS) {
                            return true;
                        }
                        // Skip collision check for cells above the board (negative Y)
                        if (boardY < 0) {
                            continue;
                        }
                        // Check for collision with existing blocks on the board
                        if (board[boardY] && board[boardY][boardX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function rotatePiece(piece, dir) {
            // Create a new array for the rotated piece to avoid modifying the original during check
            const originalPiece = JSON.parse(JSON.stringify(piece)); // Deep copy
            let newPiece = originalPiece.map((row, y) => row.map((val, x) => originalPiece[originalPiece.length - 1 - x][y]));

            if (dir === -1) { // Rotate counter-clockwise (3 times clockwise)
                for (let i = 0; i < 3; i++) {
                    newPiece = newPiece.map((row, y) => row.map((val, x) => newPiece[newPiece.length - 1 - x][y]));
                }
            }

            // Wall kick tests (simplified for basic functionality)
            const offsets = [[0, 0], [-1, 0], [1, 0], [0, -1], [-2, 0], [2, 0]]; // Common wall kick offsets
            for (const [ox, oy] of offsets) {
                if (!checkTetrisCollision(gameState.board, newPiece, gameState.pieceX + ox, gameState.pieceY + oy)) {
                    gameState.currentPiece = newPiece;
                    gameState.pieceX += ox;
                    gameState.pieceY += oy;
                    return true; // Rotation successful
                }
            }
            return false; // Rotation failed
        }

        function lockPiece() {
            for (let y = 0; y < gameState.currentPiece.length; y++) {
                for (let x = 0; x < gameState.currentPiece[y].length; x++) {
                    if (gameState.currentPiece[y][x] !== 0) {
                        // Ensure it's within bounds before placing
                        if (gameState.pieceY + y >= 0 && gameState.pieceY + y < TETRIS_ROWS &&
                            gameState.pieceX + x >= 0 && gameState.pieceX + x < TETRIS_COLS) {
                            gameState.board[gameState.pieceY + y][gameState.pieceX + x] = gameState.currentPieceColor;
                        }
                    }
                }
            }
            clearLines();
            generateNewPiece();
        }

        function clearLines() {
            let linesClearedThisTurn = 0;
            const keptLines = [];

            for (let y = 0; y < TETRIS_ROWS; y++) {
                const isLineFull = gameState.board[y].every(block => block !== 0);
                if (!isLineFull) {
                    keptLines.push(gameState.board[y]);
                } else {
                    linesClearedThisTurn++;
                }
            }

            // Add empty rows to the top for cleared lines
            const newBoard = [];
            for (let i = 0; i < linesClearedThisTurn; i++) {
                newBoard.push(Array(TETRIS_COLS).fill(0));
            }
            // Add the lines that were not full
            keptLines.forEach(row => newBoard.push(row));

            // Adjust board size if necessary (shouldn't happen if logic is perfect, but as a safeguard)
            while (newBoard.length > TETRIS_ROWS) {
                newBoard.shift(); // Remove from top if somehow too many rows
            }
            while (newBoard.length < TETRIS_ROWS) {
                newBoard.unshift(Array(TETRIS_COLS).fill(0)); // Add empty rows to top if too few
            }
            
            gameState.board = newBoard;

            if (linesClearedThisTurn > 0) {
                const scorePerLine = [0, 100, 300, 500, 800]; // Score for 0, 1, 2, 3, 4 lines
                score += scorePerLine[linesClearedThisTurn] * gameState.level;
                gameState.linesCleared += linesClearedThisTurn;
                updateScore();
            }

            // Increase level after every 10 lines cleared (example)
            if (gameState.linesCleared >= gameState.level * 10) {
                gameState.level++;
                gameState.dropInterval = Math.max(0.1, gameState.dropInterval * 0.85); // Make it drop faster
            }
        }

        function updateTetris(deltaTime) {
            if (gameState.isGameOver) return;

            gameState.dropCounter += deltaTime;
            if (gameState.dropCounter >= gameState.dropInterval) {
                gameState.dropCounter = 0;
                dropPiece();
            }

            const currentTime = performance.now();
            const moveDelay = 100; // Milliseconds between horizontal moves on hold

            if (keysPressed.has('arrowdown') || keysPressed.has('s')) {
                gameState.dropCounter += deltaTime * 5; // Soft drop faster
            }
            
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) {
                if (currentTime - gameState.lastMoveTime > moveDelay) {
                    if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX - 1, gameState.pieceY)) {
                        gameState.pieceX--;
                        gameState.lastMoveTime = currentTime;
                    }
                }
            } else if (keysPressed.has('arrowright') || keysPressed.has('d')) {
                if (currentTime - gameState.lastMoveTime > moveDelay) {
                    if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX + 1, gameState.pieceY)) {
                        gameState.pieceX++;
                        gameState.lastMoveTime = currentTime;
                    }
                }
            } else {
                gameState.lastMoveTime = 0; // Reset last move time when no horizontal key is pressed
            }
        }

        function dropPiece() {
            if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY + 1)) {
                gameState.pieceY++;
            } else {
                lockPiece();
            }
        }

        function drawTetris() {
            if (!ctx) return;
            // Draw the fixed blocks on the board
            for (let y = 0; y < TETRIS_ROWS; y++) {
                for (let x = 0; x < TETRIS_COLS; x++) {
                    if (gameState.board[y][x] !== 0) {
                        ctx.fillStyle = gameState.board[y][x];
                        ctx.fillRect(x * window.TETRIS_BLOCK_SIZE, y * window.TETRIS_BLOCK_SIZE, window.TETRIS_BLOCK_SIZE - 1, window.TETRIS_BLOCK_SIZE - 1);
                        ctx.strokeStyle = '#000'; // Block borders
                        ctx.strokeRect(x * window.TETRIS_BLOCK_SIZE, y * window.TETRIS_BLOCK_SIZE, window.TETRIS_BLOCK_SIZE - 1, window.TETRIS_BLOCK_SIZE - 1);
                    }
                }
            }

            // Draw the current falling piece
            if (gameState.currentPiece) {
                ctx.fillStyle = gameState.currentPieceColor;
                for (let y = 0; y < gameState.currentPiece.length; y++) {
                    for (let x = 0; x < gameState.currentPiece[y].length; x++) {
                        if (gameState.currentPiece[y][x] !== 0) {
                            ctx.fillRect((gameState.pieceX + x) * window.TETRIS_BLOCK_SIZE, (gameState.pieceY + y) * window.TETRIS_BLOCK_SIZE, window.TETRIS_BLOCK_SIZE - 1, window.TETRIS_BLOCK_SIZE - 1);
                            ctx.strokeStyle = '#000'; // Block borders
                            ctx.strokeRect((gameState.pieceX + x) * window.TETRIS_BLOCK_SIZE, (gameState.pieceY + y) * window.TETRIS_BLOCK_SIZE, window.TETRIS_BLOCK_SIZE - 1, window.TETRIS_BLOCK_SIZE - 1);
                        }
                    }
                }
            }

            // Draw grid lines for visual clarity
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 * (window.TETRIS_BLOCK_SIZE / 20); // Scale line width
            for (let i = 0; i <= TETRIS_COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * window.TETRIS_BLOCK_SIZE, 0);
                ctx.lineTo(i * window.TETRIS_BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= TETRIS_ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * window.TETRIS_BLOCK_SIZE);
                ctx.lineTo(canvas.width, i * window.TETRIS_BLOCK_SIZE);
                ctx.stroke();
            }

            // Display Level and Lines Cleared (optional, for Tetris specific)
            ctx.fillStyle = '#00ff41';
            ctx.font = `${35 * (canvas.width / ORIGINAL_CANVAS_WIDTH)}px 'Courier New', monospace`; // Scaled font size
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top'; // Align to top for consistency
            ctx.fillText(`Level: ${gameState.level}`, 10, 10);
            ctx.fillText(`Lines: ${gameState.linesCleared}`, 10, 30);
        }
        // --- End Tetris Game ---

        // --- Minesweeper Game ---
        // MINE_CELL_SIZE will be dynamically calculated in resizeCanvas
        // Define original rows/cols for scaling reference
        const MINESWEEPER_DEFAULT_ROWS = 16;
        const MINESWEEPER_DEFAULT_COLS = 16;
        const MINESWEEPER_DEFAULT_MINES = 40;
        const MINESWEEPER_ORIGINAL_CELL_SIZE = 30;

        function initMinesweeper() {
            gameState = {
                rows: MINESWEEPER_DEFAULT_ROWS,
                cols: MINESWEEPER_DEFAULT_COLS,
                mines: MINESWEEPER_DEFAULT_MINES, // Corrected variable name
                board: [],
                revealed: [],
                flagged: [],
                gameOver: false,
                gameWon: false,
                startTime: 0,
                timer: 0,
                minesRemaining: 0
            };
            
            // Re-calculate MINE_CELL_SIZE based on current canvas width, ensuring it's set for new game
            window.MINE_CELL_SIZE = Math.floor(canvas.width / gameState.cols);

            // Initialize board, revealed, and flagged arrays
            for (let r = 0; r < gameState.rows; r++) {
                gameState.board.push(Array(gameState.cols).fill(0));
                gameState.revealed.push(Array(gameState.cols).fill(false));
                gameState.flagged.push(Array(gameState.cols).fill(false));
            }

            placeMines();
            calculateMineCounts();

            gameState.minesRemaining = gameState.mines;
            document.getElementById('mineCountDisplay').textContent = `Mines: ${gameState.minesRemaining}`;
            document.getElementById('timerDisplay').textContent = `Time: 0s`;

            gameState.startTime = Date.now(); // Start timer
            gameState.timer = 0;
        }

        function placeMines() {
            let minesPlaced = 0;
            while (minesPlaced < gameState.mines) {
                const r = Math.floor(Math.random() * gameState.rows);
                const c = Math.floor(Math.random() * gameState.cols);
                if (gameState.board[r][c] !== -1) { // If no mine is already there
                    gameState.board[r][c] = -1; // Place a mine
                    minesPlaced++;
                }
            }
        }

        function calculateMineCounts() {
            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] === -1) continue; // Skip if it's a mine

                    let count = 0;
                    // Check all 8 surrounding cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue; // Skip the cell itself

                            const nr = r + dr;
                            const nc = c + dc;

                            // Check bounds and if the neighbor is a mine
                            if (
                                nr >= 0 && nr < gameState.rows &&
                                nc >= 0 && nc < gameState.cols &&
                                gameState.board[nr][nc] === -1
                            ) {
                                count++;
                            }
                        }
                    }
                    gameState.board[r][c] = count;
                }
            }
        }

        function handleMinesweeperClick(event) {
            if (gameState.gameOver || gameState.gameWon || !canvas || document.getElementById('messageBox').style.display === 'block') return;

            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to internal canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            const c = Math.floor(x / window.MINE_CELL_SIZE);
            const r = Math.floor(y / window.MINE_CELL_SIZE);

            // Basic bounds check
            if (r < 0 || r >= gameState.rows || c < 0 || c >= gameState.cols) {
                return;
            }

            // Left click (reveal)
            if (event.button === 0) { // 0 for left click
                if (!gameState.revealed[r][c] && !gameState.flagged[r][c]) {
                    revealCell(r, c);
                }
            }
            checkMinesweeperWin();
        }

        function handleMinesweeperRightClick(event) {
            event.preventDefault(); // Prevent context menu from appearing
            if (gameState.gameOver || gameState.gameWon || !canvas || document.getElementById('messageBox').style.display === 'block') return;

            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to internal canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            const c = Math.floor(x / window.MINE_CELL_SIZE);
            const r = Math.floor(y / window.MINE_CELL_SIZE);

            // Basic bounds check
            if (r < 0 || r >= gameState.rows || c < 0 || c >= gameState.cols) {
                return;
            }

            // Right click (flag)
            if (!gameState.revealed[r][c]) { // Can only flag unrevealed cells
                gameState.flagged[r][c] = !gameState.flagged[r][c]; // Toggle flag
                gameState.minesRemaining += (gameState.flagged[r][c] ? -1 : 1); // Update mine count
                document.getElementById('mineCountDisplay').textContent = `Mines: ${gameState.minesRemaining}`;
            }
            checkMinesweeperWin();
        }


        // Recursive function to reveal cells
        function revealCell(r, c) {
            // Base cases for recursion: out of bounds, already revealed, or flagged
            if (r < 0 || r >= gameState.rows || c < 0 || c >= gameState.cols ||
                gameState.revealed[r][c] || gameState.flagged[r][c]) {
                return;
            }

            gameState.revealed[r][c] = true; // Mark as revealed

            if (gameState.board[r][c] === -1) {
                // Hit a mine! Game Over
                gameState.gameOver = true;
                gameOver('lost'); // Call the general gameOver function
                revealAllMines(); // Show all mines
                return;
            }

            if (gameState.board[r][c] === 0) {
                // If it's an empty cell (0 mines around), recursively reveal neighbors
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        revealCell(r + dr, c + dc);
                    }
                }
            }
            // If it's a numbered cell, just reveal it (recursion stops here)
        }

        function revealAllMines() {
            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] === -1) {
                        gameState.revealed[r][c] = true; // Show all mines
                        gameState.flagged[r][c] = false; // Unflag any incorrectly flagged mines for display
                    }
                }
            }
        }

        function checkMinesweeperWin() {
            let nonMineCellsRevealed = 0;
            let totalNonMineCells = (gameState.rows * gameState.cols) - gameState.mines;

            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] !== -1 && gameState.revealed[r][c]) {
                        nonMineCellsRevealed++;
                    }
                }
            }

            if (nonMineCellsRevealed === totalNonMineCells && !gameState.gameOver) {
                gameState.gameWon = true;
                gameOver('won'); // Call general gameOver function with 'won' status
                revealAllMines(); // For aesthetics, show all mines when won (they should be flagged)
            }
        }

        function updateMinesweeper(deltaTime) {
            if (!gameState.gameOver && !gameState.gameWon) {
                gameState.timer = Math.floor((Date.now() - gameState.startTime) / 1000);
                document.getElementById('timerDisplay').textContent = `Time: ${gameState.timer}s`;
            }
        }

        function drawMinesweeper() {
            if (!ctx) return;
            const currentCellSize = window.MINE_CELL_SIZE;
            const scaleFactor = currentCellSize / MINESWEEPER_ORIGINAL_CELL_SIZE;

            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    const x = c * currentCellSize;
                    const y = r * currentCellSize;

                    // Draw cell background
                    if (gameState.revealed[r][c]) {
                        ctx.fillStyle = '#333'; // Darker for revealed cells
                        ctx.fillRect(x, y, currentCellSize, currentCellSize);
                        if (gameState.board[r][c] === -1) {
                            // Draw mine (black circle with white cross)
                            ctx.fillStyle = '#ff0041'; // Red for mine
                            ctx.beginPath();
                            ctx.arc(x + currentCellSize / 2, y + currentCellSize / 2, currentCellSize / 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2 * scaleFactor; // Scaled line width
                            ctx.beginPath();
                            ctx.moveTo(x + currentCellSize / 2, y + currentCellSize / 4);
                            ctx.lineTo(x + currentCellSize / 2, y + currentCellSize * 3 / 4);
                            ctx.moveTo(x + currentCellSize / 4, y + currentCellSize / 2);
                            ctx.lineTo(x + currentCellSize * 3 / 4, y + currentCellSize / 2);
                            ctx.stroke();
                        } else if (gameState.board[r][c] > 0) {
                            // Draw number of adjacent mines
                            const num = gameState.board[r][c];
                            const colors = ['#0000ff', '#008000', '#ff0000', '#000080', '#800000', '#008080', '#000', '#808080']; // Colors for numbers 1-8
                            ctx.fillStyle = colors[num - 1]; // Get color based on number
                            ctx.font = `${currentCellSize * 0.7}px 'Courier New', monospace`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(num.toString(), x + currentCellSize / 2, y + currentCellSize / 2);
                        }
                    } else {
                        // Draw unrevealed cell
                        ctx.fillStyle = '#666'; // Gray for unrevealed cells
                        ctx.fillRect(x, y, currentCellSize, currentCellSize);
                        if (gameState.flagged[r][c]) {
                            // Draw flag
                            ctx.fillStyle = '#ffff00'; // Yellow flag
                            ctx.beginPath();
                            ctx.moveTo(x + currentCellSize * 0.2, y + currentCellSize * 0.8);
                            ctx.lineTo(x + currentCellSize * 0.2, y + currentCellSize * 0.2);
                            ctx.lineTo(x + currentCellSize * 0.8, y + currentCellSize * 0.3);
                            ctx.lineTo(x + currentCellSize * 0.2, y + currentCellSize * 0.4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 2 * scaleFactor; // Scaled line width
                            ctx.stroke();
                        }
                    }
                    ctx.strokeStyle = '#000'; // Cell borders
                    ctx.lineWidth = 1 * scaleFactor; // Scaled line width
                    ctx.strokeRect(x, y, currentCellSize, currentCellSize);
                }
            }
        }
        // --- End Minesweeper Game ---

        // --- Galactic Invaders Game ---
        // Reference dimensions for consistent element scaling
        const GALACTIC_INVADERS_REFERENCE_WIDTH = 600;
        const GALACTIC_INVADERS_REFERENCE_HEIGHT = 700;

        // Original conceptual sizes for player/enemy to maintain aspect ratio during drawing
        const GI_PLAYER_DRAW_REF_WIDTH = 40;
        const GI_PLAYER_DRAW_REF_HEIGHT = 40; // This is a general bounding box height, not actual drawn visual height
        const GI_ENEMY_DRAW_REF_WIDTH = 30;
        const GI_ENEMY_DRAW_REF_HEIGHT = 20;

        // Constants for player ship drawing (relative to its center)
        const GI_PLAYER_DRAW_TOP_OFFSET_FROM_CENTER = -10; // Topmost point of drawn ship relative to its Y
        const GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER = 15; // Bottommost point of drawn ship relative to its Y


        // Other constants scaled by game width
        const GI_PLAYER_Y_OFFSET = 20; // Changed from 50 to 20 to move player lower
        const GI_PLAYER_BULLET_RADIUS = 3;
        const GI_ENEMY_BULLET_RADIUS = 3;
        const GI_ENEMY_ADVANCE_Y = 20; 
        const GI_OFFSET_Y = 50;
        const GI_HORIZONTAL_SPACING = 15;
        const GI_VERTICAL_SPACING = 20;

        // Speeds remain constant relative to screen size (pixels per second)
        const PLAYER_SPEED = 200; 
        const PLAYER_BULLET_SPEED = 600; 
        const PLAYER_SHOOT_COOLDOWN = 0.5;

        const ENEMY_NORMAL_SPEED_X = 50; 
        const ENEMY_NORMAL_SPEED_Y = 20; 
        const ENEMY_DIVE_SPEED = 200; 
        const ENEMY_BULLET_SPEED = 150;
        const ENEMY_BASE_SHOULD_SHOOT_CHANCE = 0.0005; 
        const ENEMY_BASE_RAM_CHANCE = 0.00005;

        function initGalacticInvaders() {
            const currentCanvasWidth = canvas.width;
            const currentCanvasHeight = canvas.height;

            // Determine a single game scale based on current canvas width relative to the reference width
            // This ensures all drawing operations maintain the original aspect ratio of elements
            const gameScale = currentCanvasWidth / GALACTIC_INVADERS_REFERENCE_WIDTH;

            gameState = {
                player: {
                    x: currentCanvasWidth / 2,
                    // Temporarily set Y to a default, it will be recalculated in startGameFromOverlay
                    y: currentCanvasHeight / 2, 
                    width: GI_PLAYER_DRAW_REF_WIDTH * gameScale, // For collision detection (could be slightly larger than visual)
                    height: GI_PLAYER_DRAW_REF_HEIGHT * gameScale, // For collision detection
                    lastShotTime: 0,
                    canShoot: true,
                    isDestroyed: false,
                    isInvincible: false,
                    invincibilityTimer: 0,
                    invincibilityDuration: 2,
                    blinkInterval: 0.1
                },
                playerBullets: [],
                enemies: [],
                enemyBullets: [],
                score: 0,
                lives: 3,
                wave: 1,
                enemyDirection: 1,
                enemyAdvanceTimer: 0,
                enemyAdvanceInterval: 2,
                waveOscillationAmplitude: 5 * gameScale, 
                waveOscillationFrequency: 5,
                currentEnemyShootChance: ENEMY_BASE_SHOULD_SHOOT_CHANCE * (1 + (gameState.wave - 1) * 0.1), 
                currentEnemyRamChance: ENEMY_BASE_RAM_CHANCE * (1 + (gameState.wave - 1) * 0.5), 
                explosions: [],
                explosionDuration: 0.5
            };
            
            spawnEnemyWave();
            updateGalacticInvadersScoreAndLives(); // Initialize UI
        }

        // Draw Player Ship (enhanced graphics)
        function drawPlayerShip(player) {
            const currentTimeSeconds = performance.now() / 1000;
            if (player.isInvincible && Math.floor(currentTimeSeconds / player.blinkInterval) % 2 === 0) {
                return; // Don't draw if blinking during invincibility
            }

            // Calculate element-specific scale based on canvas width
            const entityScale = canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH;

            const basePlayerX = player.x;
            const basePlayerY = player.y;

            ctx.save(); // Save the current canvas state
            ctx.translate(basePlayerX, basePlayerY); // Move origin to ship's center for drawing

            // Add ship glow effect
            ctx.shadowColor = '#00ff41';
            ctx.shadowBlur = 15 * entityScale;

            // Main Body (enhanced triangle with gradient)
            const bodyGradient = ctx.createLinearGradient(0, GI_PLAYER_DRAW_TOP_OFFSET_FROM_CENTER * entityScale, 0, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale);
            bodyGradient.addColorStop(0, '#90ff90');
            bodyGradient.addColorStop(0.5, '#00ff41');
            bodyGradient.addColorStop(1, '#006600');
            ctx.fillStyle = bodyGradient;
            ctx.strokeStyle = '#00aa00';
            ctx.lineWidth = 2 * entityScale;
            ctx.beginPath();
            ctx.moveTo(0, GI_PLAYER_DRAW_TOP_OFFSET_FROM_CENTER * entityScale);
            ctx.lineTo(-20 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 5 * entityScale);
            ctx.lineTo(20 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 5 * entityScale);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Enhanced Cockpit with gradient
            const cockpitGradient = ctx.createRadialGradient(0, GI_PLAYER_DRAW_TOP_OFFSET_FROM_CENTER * entityScale + 2 * entityScale, 0, 0, GI_PLAYER_DRAW_TOP_OFFSET_FROM_CENTER * entityScale + 2 * entityScale, 8 * entityScale);
            cockpitGradient.addColorStop(0, '#ffffff');
            cockpitGradient.addColorStop(0.5, '#00ffff');
            cockpitGradient.addColorStop(1, '#0066aa');
            ctx.fillStyle = cockpitGradient;
            ctx.strokeStyle = '#0099cc';
            ctx.beginPath();
            ctx.roundRect(-6 * entityScale, GI_PLAYER_DRAW_TOP_OFFSET_FROM_CENTER * entityScale, 12 * entityScale, 6 * entityScale, 2 * entityScale);
            ctx.fill();
            ctx.stroke();

            // Enhanced Left Wing with gradient and details
            const wingGradient = ctx.createLinearGradient(-30 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 10 * entityScale, -20 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale + 5 * entityScale);
            wingGradient.addColorStop(0, '#ff6666');
            wingGradient.addColorStop(0.5, '#ff0041');
            wingGradient.addColorStop(1, '#aa0022');
            ctx.fillStyle = wingGradient;
            ctx.strokeStyle = '#cc0033';
            ctx.beginPath();
            ctx.moveTo(-20 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 5 * entityScale);
            ctx.lineTo(-32 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 12 * entityScale);
            ctx.lineTo(-35 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 8 * entityScale);
            ctx.lineTo(-32 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale + 8 * entityScale);
            ctx.lineTo(-20 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale + 5 * entityScale);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Enhanced Right Wing (mirror of left)
            ctx.fillStyle = wingGradient;
            ctx.strokeStyle = '#cc0033';
            ctx.beginPath();
            ctx.moveTo(20 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 5 * entityScale);
            ctx.lineTo(32 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 12 * entityScale);
            ctx.lineTo(35 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 8 * entityScale);
            ctx.lineTo(32 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale + 8 * entityScale);
            ctx.lineTo(20 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale + 5 * entityScale);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Enhanced Animated Thrusters
            const thrusterIntensity = 0.7 + Math.sin(currentTimeSeconds * 15) * 0.3;
            const thrusterGradient = ctx.createLinearGradient(0, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 5 * entityScale, 0, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale + 8 * entityScale);
            thrusterGradient.addColorStop(0, `rgba(255, 255, 255, ${thrusterIntensity})`);
            thrusterGradient.addColorStop(0.3, `rgba(255, 165, 0, ${thrusterIntensity})`);
            thrusterGradient.addColorStop(0.7, `rgba(255, 69, 0, ${thrusterIntensity * 0.8})`);
            thrusterGradient.addColorStop(1, `rgba(255, 0, 0, ${thrusterIntensity * 0.4})`);
            
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 8 * entityScale;
            ctx.fillStyle = thrusterGradient;
            
            // Left thruster
            ctx.beginPath();
            ctx.moveTo(-18 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 5 * entityScale);
            ctx.lineTo(-12 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 5 * entityScale);
            ctx.lineTo(-15 * entityScale + Math.random() * 2 - 1, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale + (3 + Math.random() * 6) * entityScale);
            ctx.closePath();
            ctx.fill();
            
            // Right thruster
            ctx.beginPath();
            ctx.moveTo(12 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 5 * entityScale);
            ctx.lineTo(18 * entityScale, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale - 5 * entityScale);
            ctx.lineTo(15 * entityScale + Math.random() * 2 - 1, GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale + (3 + Math.random() * 6) * entityScale);
            ctx.closePath();
            ctx.fill();

            // Add engine glow particles
            ctx.shadowBlur = 0;
            for (let i = 0; i < 3; i++) {
                const particleY = GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * entityScale + (8 + Math.random() * 10) * entityScale;
                const leftX = -15 * entityScale + Math.random() * 6 - 3;
                const rightX = 15 * entityScale + Math.random() * 6 - 3;
                const alpha = Math.random() * 0.8 + 0.2;
                
                ctx.fillStyle = `rgba(255, ${100 + Math.random() * 155}, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(leftX, particleY, 1 * entityScale, 0, Math.PI * 2);
                ctx.arc(rightX, particleY, 1 * entityScale, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore(); // Restore the canvas state
        }


        // Draw Enemy Ship (enhanced graphics)
        function drawEnemyShip(enemy) {
            const entityScale = canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH;
            const time = performance.now() * 0.003;

            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            
            // Add ship glow effect
            ctx.shadowColor = enemy.color;
            ctx.shadowBlur = 10 * entityScale;

            // Main body with enhanced gradient
            const bodyGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, enemy.width/2);
            bodyGradient.addColorStop(0, '#ffffff');
            bodyGradient.addColorStop(0.3, enemy.color);
            bodyGradient.addColorStop(0.8, `hsl(${(parseFloat(enemy.color.match(/\d+/)[0]) + 180) % 360}, 80%, 40%)`);
            bodyGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bodyGradient;
            
            // Enhanced main body shape with subtle animation
            const pulseScale = 1 + Math.sin(time * 4 + enemy.x * 0.01) * 0.05;
            ctx.scale(pulseScale, pulseScale);
            
            ctx.beginPath();
            ctx.ellipse(0, 0, enemy.width / 2, enemy.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Enhanced outline
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1.5 * entityScale;
            ctx.stroke();
            
            // Reset scale for other elements
            ctx.scale(1/pulseScale, 1/pulseScale);

            // Enhanced side thrusters with animation
            const thrusterFlicker = 0.7 + Math.sin(time * 8 + enemy.x * 0.02) * 0.3;
            const thrusterGradient = ctx.createLinearGradient(0, 0, 0, enemy.height/2);
            thrusterGradient.addColorStop(0, `rgba(255, 69, 0, ${thrusterFlicker})`);
            thrusterGradient.addColorStop(0.7, `rgba(255, 165, 0, ${thrusterFlicker * 0.8})`);
            thrusterGradient.addColorStop(1, `rgba(255, 255, 0, ${thrusterFlicker * 0.4})`);
            ctx.fillStyle = thrusterGradient;
            
            // Left thruster
            ctx.beginPath();
            ctx.moveTo(-enemy.width / 2, 0);
            ctx.lineTo(-enemy.width / 2 - (8 * entityScale), enemy.height / 3);
            ctx.lineTo(-enemy.width / 2 - (4 * entityScale) + Math.random() * 2 - 1, enemy.height / 2 + Math.random() * 4);
            ctx.lineTo(-enemy.width / 2, enemy.height / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#ff4500';
            ctx.lineWidth = 1 * entityScale;
            ctx.stroke();

            // Right thruster
            ctx.beginPath();
            ctx.moveTo(enemy.width / 2, 0);
            ctx.lineTo(enemy.width / 2 + (8 * entityScale), enemy.height / 3);
            ctx.lineTo(enemy.width / 2 + (4 * entityScale) + Math.random() * 2 - 1, enemy.height / 2 + Math.random() * 4);
            ctx.lineTo(enemy.width / 2, enemy.height / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.stroke();
            
            // Enhanced central eye/core
            const coreGradient = ctx.createRadialGradient(0, -enemy.height / 4, 0, 0, -enemy.height / 4, 6 * entityScale);
            coreGradient.addColorStop(0, '#ffffff');
            coreGradient.addColorStop(0.4, '#ff0000');
            coreGradient.addColorStop(1, '#800000');
            ctx.fillStyle = coreGradient;
            
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 8 * entityScale;
            
            ctx.beginPath();
            ctx.arc(0, -enemy.height / 4, 4 * entityScale, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye highlight
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(-1 * entityScale, -enemy.height / 4 - 1 * entityScale, 1.5 * entityScale, 0, Math.PI * 2);
            ctx.fill();

            // Enhanced antenna/sensors
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2 * entityScale;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 4 * entityScale;
            
            // Left antenna
            ctx.beginPath();
            ctx.moveTo(-enemy.width / 4, -enemy.height / 2);
            ctx.lineTo(-enemy.width / 4 - (6 * entityScale), -enemy.height / 2 - (8 * entityScale));
            ctx.stroke();
            
            // Right antenna
            ctx.beginPath();
            ctx.moveTo(enemy.width / 4, -enemy.height / 2);
            ctx.lineTo(enemy.width / 4 + (6 * entityScale), -enemy.height / 2 - (8 * entityScale));
            ctx.stroke();
            
            // Antenna tips
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(-enemy.width / 4 - (6 * entityScale), -enemy.height / 2 - (8 * entityScale), 1.5 * entityScale, 0, Math.PI * 2);
            ctx.arc(enemy.width / 4 + (6 * entityScale), -enemy.height / 2 - (8 * entityScale), 1.5 * entityScale, 0, Math.PI * 2);
            ctx.fill();
            
            // Additional hull details
            ctx.shadowBlur = 0;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 1 * entityScale;
            
            // Hull lines
            ctx.beginPath();
            ctx.moveTo(-enemy.width / 3, -enemy.height / 6);
            ctx.lineTo(enemy.width / 3, -enemy.height / 6);
            ctx.moveTo(-enemy.width / 4, enemy.height / 6);
            ctx.lineTo(enemy.width / 4, enemy.height / 6);
            ctx.stroke();
            
            ctx.restore();
        }

        // New function to draw an explosion
        function drawExplosion(explosion, totalDuration) {
            if (!ctx) return;
            const progress = 1 - (explosion.timer / totalDuration);
            const maxRadius = 30 * (canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH); // Scaled max radius
            const currentRadius = maxRadius * progress;
            const alpha = 1 - progress;

            ctx.save();
            ctx.globalAlpha = alpha;

            ctx.fillStyle = `rgba(255, ${Math.floor(165 * (1 - progress))}, 0, ${alpha})`;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = `rgba(255, 255, ${Math.floor(100 * (1 - progress))}, ${alpha * 0.8})`;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, currentRadius * 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }


        function spawnEnemyWave() {
            gameState.enemies = [];
            const baseEnemyRows = 3; 
            const maxEnemyRows = 7; 
            const baseEnemiesPerRow = 6; 
            
            const enemyRows = Math.min(baseEnemyRows + Math.floor((gameState.wave - 1) / 2), maxEnemyRows); 
            const enemiesPerRow = Math.min(baseEnemiesPerRow + Math.floor((gameState.wave - 1) * 0.75), 10);

            const currentCanvasWidth = canvas.width;
            const currentCanvasHeight = canvas.height;

            const gameScale = currentCanvasWidth / GALACTIC_INVADERS_REFERENCE_WIDTH;

            const enemyWidth = GI_ENEMY_DRAW_REF_WIDTH * gameScale;
            const enemyHeight = GI_ENEMY_DRAW_REF_HEIGHT * gameScale;
            const horizontalSpacing = GI_HORIZONTAL_SPACING * gameScale;
            const verticalSpacing = GI_VERTICAL_SPACING * gameScale;

            const totalGroupWidth = enemiesPerRow * enemyWidth + (enemiesPerRow - 1) * horizontalSpacing;
            const startX = (currentCanvasWidth - totalGroupWidth) / 2;
            const offsetY = GI_OFFSET_Y * gameScale;

            gameState.currentEnemyShootChance = ENEMY_BASE_SHOULD_SHOOT_CHANCE * (1 + (gameState.wave - 1) * 0.1); 
            gameState.currentEnemyRamChance = ENEMY_BASE_RAM_CHANCE * (1 + (gameState.wave - 1) * 0.5); 

            for (let r = 0; r < enemyRows; r++) { 
                for (let c = 0; c < enemiesPerRow; c++) {
                    gameState.enemies.push({
                        x: startX + c * (enemyWidth + horizontalSpacing) + (Math.random() * 10 - 5) * gameScale,
                        y: offsetY + r * (enemyHeight + verticalSpacing) + (Math.random() * 10 - 5) * gameScale,
                        initialY: offsetY + r * (enemyHeight + verticalSpacing),
                        width: enemyWidth, // Store scaled width for collision detection
                        height: enemyHeight, // Store scaled height for collision detection
                        color: `hsl(${Math.random() * 360}, 80%, 70%)`, 
                        isDiving: false,
                        diveTargetX: 0 
                    });
                }
            }
        }

        function firePlayerBullet() {
            const currentTime = performance.now() / 1000;
            if (currentTime - gameState.player.lastShotTime > PLAYER_SHOOT_COOLDOWN) {
                const gameScale = canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH;
                gameState.playerBullets.push({
                    x: gameState.player.x,
                    // Bullet origin should be from the top of the player's main body (GI_PLAYER_DRAW_TOP_OFFSET_FROM_CENTER)
                    y: gameState.player.y + (GI_PLAYER_DRAW_TOP_OFFSET_FROM_CENTER * gameScale), 
                    radius: GI_PLAYER_BULLET_RADIUS * gameScale, 
                    vy: -PLAYER_BULLET_SPEED * (canvas.height / GALACTIC_INVADERS_REFERENCE_HEIGHT) 
                });
                gameState.player.lastShotTime = currentTime;
            }
        }

        function updateGalacticInvaders(deltaTime) {
            const currentTimeSeconds = performance.now() / 1000;
            const gameScale = canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH; // Use consistent scale

            if (gameState.player.isInvincible) {
                gameState.player.invincibilityTimer -= deltaTime;
                if (gameState.player.invincibilityTimer <= 0) {
                    gameState.player.isInvincible = false;
                }
            }

            // Player movement scaled by current canvas width
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) {
                gameState.player.x -= PLAYER_SPEED * gameScale * deltaTime;
            }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) {
                gameState.player.x += PLAYER_SPEED * gameScale * deltaTime;
            }
            // Clamp player position
            gameState.player.x = Math.max(gameState.player.width / 2, Math.min(canvas.width - gameState.player.width / 2, gameState.player.x));

            // Player bullets update
            gameState.playerBullets = gameState.playerBullets.filter(bullet => {
                bullet.y += bullet.vy * deltaTime;
                return bullet.y > 0;
            });

            // Enemy movement and shooting/diving
            gameState.enemyAdvanceTimer += deltaTime;
            let advanceDown = false;
            let hitWallThisFrame = false;

            if (gameState.enemyAdvanceTimer >= gameState.enemyAdvanceInterval) {
                gameState.enemyAdvanceTimer = 0;
                for (const enemy of gameState.enemies) {
                    // Adjust margin from wall for check based on scaling
                    const wallMargin = 10 * gameScale;
                    if (!enemy.isDiving && ((gameState.enemyDirection === 1 && enemy.x + enemy.width / 2 >= canvas.width - wallMargin) ||
                                            (gameState.enemyDirection === -1 && enemy.x - enemy.width / 2 <= wallMargin))) {
                        hitWallThisFrame = true;
                        break;
                    }
                }

                if (hitWallThisFrame) {
                    gameState.enemyDirection *= -1;
                    advanceDown = true;
                }
            }

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];

                if (enemy.isDiving) {
                    enemy.y += ENEMY_DIVE_SPEED * gameScale * deltaTime; 
                    const dx = enemy.diveTargetX - enemy.x;
                    if (Math.abs(dx) > 5 * gameScale) { 
                        enemy.x += Math.sign(dx) * ENEMY_DIVE_SPEED * 0.5 * gameScale * deltaTime; 
                    }
                    
                    if (enemy.y - enemy.height / 2 > canvas.height) {
                        enemy.y = -enemy.height / 2;
                        enemy.x = gameState.player.x;
                        enemy.diveTargetX = gameState.player.x;
                    }
                } else {
                    enemy.x += gameState.enemyDirection * ENEMY_NORMAL_SPEED_X * gameScale * deltaTime; 
                    if (advanceDown) {
                        enemy.initialY += ENEMY_NORMAL_SPEED_Y * gameScale; 
                    }
                    enemy.y = enemy.initialY + Math.sin(currentTimeSeconds * gameState.waveOscillationFrequency + enemy.x / (50 * gameScale)) * gameState.waveOscillationAmplitude;

                    if (Math.random() < gameState.currentEnemyRamChance) {
                        enemy.isDiving = true;
                        enemy.diveTargetX = gameState.player.x;
                    } else if (Math.random() < gameState.currentEnemyShootChance) {
                        gameState.enemyBullets.push({
                            x: enemy.x,
                            y: enemy.y + enemy.height / 2,
                            radius: GI_ENEMY_BULLET_RADIUS * gameScale, 
                            vy: ENEMY_BULLET_SPEED * gameScale
                        });
                    }

                    if (enemy.y + enemy.height / 2 >= canvas.height - gameState.player.height * 2) {
                        gameOver();
                        return;
                    }
                }
            }


            // Enemy bullets update
            gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                bullet.y += bullet.vy * deltaTime;
                return bullet.y < canvas.height;
            });

            // Collision detection (Player Bullets vs Enemies)
            for (let i = gameState.playerBullets.length - 1; i >= 0; i--) {
                const pBullet = gameState.playerBullets[i];
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const closestX = Math.max(enemy.x - enemy.width / 2, Math.min(pBullet.x, enemy.x + enemy.width / 2));
                    const closestY = Math.max(enemy.y - enemy.height / 2, Math.min(pBullet.y, enemy.y + pBullet.radius)); 
                    const dx = pBullet.x - closestX;
                    const dy = pBullet.y - closestY;
                    const distanceSq = (dx * dx) + (dy * dy);

                    if (distanceSq < (pBullet.radius * pBullet.radius)) { 
                        gameState.playerBullets.splice(i, 1);
                        gameState.enemies.splice(j, 1);
                        gameState.score += 100;
                        updateGalacticInvadersScoreAndLives();
                        break; 
                    }
                }
            }

            // Collision detection (Enemy Bullets/Enemies vs Player)
            if (!gameState.player.isInvincible && !gameState.player.isDestroyed) {
                for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                    const eBullet = gameState.enemyBullets[i];
                    const dx = gameState.player.x - eBullet.x;
                    const dy = gameState.player.y - eBullet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Adjusted player collision radius for the new ship shape (more approximate)
                    const playerApproxRadius = Math.max(gameState.player.width, gameState.player.height) / 2 * 0.8; 
                    const eBulletHitRadius = playerApproxRadius + eBullet.radius;
                    if (distance < eBulletHitRadius) { 
                        gameState.enemyBullets.splice(i, 1);
                        handlePlayerHit();
                        return;
                    }
                }
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    if (enemy.isDiving) { 
                        const dx = gameState.player.x - enemy.x;
                        const dy = gameState.player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        const playerApproxRadius = Math.max(gameState.player.width, gameState.player.height) / 2 * 0.8;
                        const enemyApproxRadius = Math.max(enemy.width, enemy.height) / 2;

                        if (distance < playerApproxRadius + enemyApproxRadius) {
                            gameState.enemies.splice(i, 1);
                            handlePlayerHit();
                            return;
                        }
                    }
                }
            }

            // Update explosions
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                explosion.timer -= deltaTime;
                if (explosion.timer <= 0) {
                    gameState.explosions.splice(i, 1);
                }
            }

            // Check if all enemies are defeated for next wave
            if (gameState.enemies.length === 0) {
                gameState.wave++;
                spawnEnemyWave();
            }
        }

        // New function to handle player getting hit
        function handlePlayerHit() {
            gameState.lives--;
            updateGalacticInvadersScoreAndLives();

            if (gameState.lives <= 0) {
                gameState.player.isDestroyed = true;
                gameState.explosions.push({ x: gameState.player.x, y: gameState.player.y, timer: gameState.explosionDuration });
                gameOver();
            } else {
                gameState.player.isDestroyed = true;
                gameState.explosions.push({ x: gameState.player.x, y: gameState.player.y, timer: gameState.explosionDuration });
                
                setTimeout(() => {
                    gameState.player.isDestroyed = false;
                    const gameScale = canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH;
                    // Respawn player at the correct calculated Y position
                    gameState.player.y = canvas.height - (GI_PLAYER_Y_OFFSET * gameScale) - (GI_PLAYER_DRAW_BOTTOM_OFFSET_FROM_CENTER * gameScale); 
                    gameState.player.x = canvas.width / 2; // Reset X to center
                    gameState.player.isInvincible = true;
                    gameState.player.invincibilityTimer = gameState.player.invincibilityDuration;
                }, gameState.explosionDuration * 1000);
            }
        }

        function drawGalacticInvaders() {
            if (!gameState.player.isDestroyed) {
                drawPlayerShip(gameState.player);
            }
            
            gameState.explosions.forEach(explosion => drawExplosion(explosion, gameState.explosionDuration));

            // Enhanced player bullets with glow and trails
            gameState.playerBullets.forEach(bullet => {
                const entityScale = canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH;
                
                ctx.save();
                
                // Bullet glow effect
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15 * entityScale;
                
                // Bullet trail
                const trailLength = Math.abs(bullet.vy) * 0.02;
                for (let i = 0; i < 3; i++) {
                    const trailAlpha = (3 - i) / 3 * 0.4;
                    const trailY = bullet.y + (trailLength * i / 3);
                    ctx.globalAlpha = trailAlpha;
                    
                    const trailGradient = ctx.createRadialGradient(bullet.x, trailY, 0, bullet.x, trailY, bullet.radius * 2);
                    trailGradient.addColorStop(0, '#ffffff');
                    trailGradient.addColorStop(0.5, '#00ffff');
                    trailGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    ctx.fillStyle = trailGradient;
                    
                    ctx.beginPath();
                    ctx.arc(bullet.x, trailY, bullet.radius * (1 + i * 0.2), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main bullet with gradient
                ctx.globalAlpha = 1;
                const bulletGradient = ctx.createRadialGradient(bullet.x - bullet.radius/3, bullet.y - bullet.radius/3, 0, bullet.x, bullet.y, bullet.radius);
                bulletGradient.addColorStop(0, '#ffffff');
                bulletGradient.addColorStop(0.3, '#87CEEB');
                bulletGradient.addColorStop(0.8, '#00ffff');
                bulletGradient.addColorStop(1, '#0099cc');
                ctx.fillStyle = bulletGradient;
                
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Bullet highlight
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(bullet.x - bullet.radius/3, bullet.y - bullet.radius/3, bullet.radius/3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });

            gameState.enemies.forEach(enemy => {
                drawEnemyShip(enemy);
            });

            // Enhanced enemy bullets with menacing glow
            gameState.enemyBullets.forEach(bullet => {
                const entityScale = canvas.width / GALACTIC_INVADERS_REFERENCE_WIDTH;
                
                ctx.save();
                
                // Bullet glow effect
                ctx.shadowColor = '#ff0041';
                ctx.shadowBlur = 12 * entityScale;
                
                // Bullet trail
                const trailLength = Math.abs(bullet.vy) * 0.02;
                for (let i = 0; i < 2; i++) {
                    const trailAlpha = (2 - i) / 2 * 0.3;
                    const trailY = bullet.y - (trailLength * i / 2);
                    ctx.globalAlpha = trailAlpha;
                    
                    const trailGradient = ctx.createRadialGradient(bullet.x, trailY, 0, bullet.x, trailY, bullet.radius * 2);
                    trailGradient.addColorStop(0, '#ff6666');
                    trailGradient.addColorStop(0.5, '#ff0041');
                    trailGradient.addColorStop(1, 'rgba(255, 0, 65, 0)');
                    ctx.fillStyle = trailGradient;
                    
                    ctx.beginPath();
                    ctx.arc(bullet.x, trailY, bullet.radius * (1 + i * 0.3), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main bullet with gradient
                ctx.globalAlpha = 1;
                const bulletGradient = ctx.createRadialGradient(bullet.x - bullet.radius/3, bullet.y - bullet.radius/3, 0, bullet.x, bullet.y, bullet.radius);
                bulletGradient.addColorStop(0, '#ffaaaa');
                bulletGradient.addColorStop(0.3, '#ff6666');
                bulletGradient.addColorStop(0.8, '#ff0041');
                bulletGradient.addColorStop(1, '#aa0022');
                ctx.fillStyle = bulletGradient;
                
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Bullet core glow
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(bullet.x - bullet.radius/4, bullet.y - bullet.radius/4, bullet.radius/4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }

        function updateGalacticInvadersScoreAndLives() {
            document.getElementById('galacticScoreDisplay').textContent = `Score: ${gameState.score}`;
            document.getElementById('galacticLivesDisplay').textContent = `Lives: ${gameState.lives}`;
            document.getElementById('galacticWaveDisplay').textContent = `Wave: ${gameState.wave}`;
        }
        // --- End Galactic Invaders Game ---

        // --- Flappy Bird Game ---
        // Original constants for scaling reference - MOVED TO GLOBAL SCOPE
        const FLAPPY_ORIGINAL_BIRD_WIDTH = 30;
        const FLAPPY_ORIGINAL_BIRD_HEIGHT = 20;
        const FLAPPY_ORIGINAL_GRAVITY = 1000; // px/s^2
        const FLAPPY_ORIGINAL_JUMP_STRENGTH = -400; // px/s
        const FLAPPY_ORIGINAL_PIPE_WIDTH = 50;
        const FLAPPY_ORIGINAL_PIPE_SPEED = 150; // px/s
        const FLAPPY_ORIGINAL_GROUND_HEIGHT = 50; // height from bottom of canvas
        const FLAPPY_ORIGINAL_PIPE_GAP = 120; // Adjusted from 150 to 120

        function initFlappyBird() {
            const currentCanvasWidth = canvas.width;
            const currentCanvasHeight = canvas.height;

            const scaleFactorX = currentCanvasWidth / ORIGINAL_CANVAS_WIDTH; // Based on default game original width
            const scaleFactorY = currentCanvasHeight / ORIGINAL_CANVAS_HEIGHT; // Based on default game original height

            gameState = {
                bird: {
                    x: currentCanvasWidth * 0.2, // 20% from left, scaled
                    y: currentCanvasHeight / 2,
                    width: FLAPPY_ORIGINAL_BIRD_WIDTH * scaleFactorX,
                    height: FLAPPY_ORIGINAL_BIRD_HEIGHT * scaleFactorY,
                    dy: 0, // Current vertical velocity
                },
                gravity: FLAPPY_ORIGINAL_GRAVITY * scaleFactorY,
                jumpStrength: FLAPPY_ORIGINAL_JUMP_STRENGTH * scaleFactorY,
                pipes: [],
                pipeSpawnTimer: 0,
                pipeWidth: FLAPPY_ORIGINAL_PIPE_WIDTH * scaleFactorX,
                pipeSpeed: FLAPPY_ORIGINAL_PIPE_SPEED * scaleFactorX,
                pipeSpawnInterval: 2, // Original static interval in seconds
                groundHeight: FLAPPY_ORIGINAL_GROUND_HEIGHT * scaleFactorY,
                isGameOver: false,
                gameStarted: false // Game starts only on first flap/spacebar press
            };
            score = 0;
            updateScore();
        }

        function flapBird() {
            if (!gameState.isGameOver) {
                gameState.bird.dy = gameState.jumpStrength;
            }
        }

        function createFlappyPipe() {
            const minTopPipeHeight = 50 * (canvas.height / ORIGINAL_CANVAS_HEIGHT); // Scaled minimum height for top pipe
            // Use the new FLAPPY_ORIGINAL_PIPE_GAP constant
            const maxTopPipeHeight = canvas.height - gameState.groundHeight - (FLAPPY_ORIGINAL_PIPE_GAP * (canvas.height / ORIGINAL_CANVAS_HEIGHT)) - minTopPipeHeight; 

            const topHeight = minTopPipeHeight + Math.random() * maxTopPipeHeight; // Random top pipe height
            // Use the new FLAPPY_ORIGINAL_PIPE_GAP constant
            const gap = FLAPPY_ORIGINAL_PIPE_GAP * (canvas.height / ORIGINAL_CANVAS_HEIGHT); // Fixed gap, scaled

            gameState.pipes.push({
                x: canvas.width,
                width: gameState.pipeWidth,
                topHeight: topHeight,
                gap: gap,
                bottomHeight: canvas.height - topHeight - gap - gameState.groundHeight, // Derived bottom pipe height
                passed: false
            });
        }

        function updateFlappyBird(deltaTime) {
            if (gameState.isGameOver || !gameState.gameStarted) {
                // If game hasn't started, just update bird Y slightly for "waiting" animation
                // Ensure gameState.bird exists before trying to access its properties
                if (gameState.bird) { 
                    gameState.bird.y = canvas.height / 2 + Math.sin(performance.now() / 200) * 5 * (canvas.height / ORIGINAL_CANVAS_HEIGHT);
                }
                return; 
            }

            // Apply gravity
            gameState.bird.dy += gameState.gravity * deltaTime;
            gameState.bird.y += gameState.bird.dy * deltaTime;

            // Check collision with top/bottom
            if (gameState.bird.y < 0) {
                gameState.bird.y = 0;
                gameState.bird.dy = 0; // Stop upward movement
            }
            if (gameState.bird.y + gameState.bird.height > canvas.height - gameState.groundHeight) {
                gameState.bird.y = canvas.height - gameState.groundHeight - gameState.bird.height;
                gameOver();
                gameState.isGameOver = true;
                return;
            }

            // Move and spawn pipes
            gameState.pipeSpawnTimer += deltaTime;
            if (gameState.pipeSpawnTimer > gameState.pipeSpawnInterval) {
                createFlappyPipe();
                gameState.pipeSpawnTimer = 0;
            }

            for (let i = gameState.pipes.length - 1; i >= 0; i--) {
                const pipe = gameState.pipes[i];
                pipe.x -= gameState.pipeSpeed * deltaTime;

                // Collision detection with pipes
                const bird = gameState.bird;
                // Check if bird is within horizontal range of pipe
                if (bird.x < pipe.x + pipe.width && bird.x + bird.width > pipe.x) {
                    // Check collision with top pipe segment
                    if (bird.y < pipe.topHeight || // bird top above pipe bottom
                        bird.y + bird.height > (pipe.topHeight + pipe.gap)) { // bird bottom below pipe top
                        gameOver();
                        gameState.isGameOver = true;
                        return;
                    }
                }

                // Check for scoring (bird passed pipe)
                if (pipe.x + pipe.width < bird.x && !pipe.passed) {
                    score++;
                    updateScore();
                    pipe.passed = true; // Mark as passed to avoid multiple scores
                }

                // Remove off-screen pipes
                if (pipe.x + pipe.width < 0) {
                    gameState.pipes.splice(i, 1);
                }
            }
        }
        
        function drawFlappyBird() {
            if (!ctx) return;
            const time = performance.now() * 0.001;
            const scale = Math.min((canvas.width / ORIGINAL_CANVAS_WIDTH), (canvas.height / ORIGINAL_CANVAS_HEIGHT));

            // Enhanced animated background with gradient sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height - gameState.groundHeight);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(0.7, '#70c5ce');
            skyGradient.addColorStop(1, '#5fb3c7');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height - gameState.groundHeight);

            // Moving clouds in background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            for (let i = 0; i < 4; i++) {
                const cloudX = ((time * 30 + i * 150) % (canvas.width + 100)) - 50;
                const cloudY = 30 + i * 25;
                drawFlappyCloud(cloudX, cloudY, 25 + i * 8, scale);
            }

            // Enhanced ground with texture and gradient
            const groundGradient = ctx.createLinearGradient(0, canvas.height - gameState.groundHeight, 0, canvas.height);
            groundGradient.addColorStop(0, '#8B7355');
            groundGradient.addColorStop(0.3, '#ded895');
            groundGradient.addColorStop(0.7, '#d4c589');
            groundGradient.addColorStop(1, '#c4b579');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height - gameState.groundHeight, canvas.width, gameState.groundHeight);
            
            // Ground texture dots
            ctx.fillStyle = 'rgba(139, 115, 85, 0.4)';
            for (let x = 0; x < canvas.width; x += 15 * scale) {
                for (let y = canvas.height - gameState.groundHeight + 5; y < canvas.height; y += 10 * scale) {
                    if (Math.random() > 0.7) {
                        ctx.beginPath();
                        ctx.arc(x + Math.random() * 10, y, 1 * scale, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Enhanced ground line with glow
            ctx.shadowColor = '#8B7355';
            ctx.shadowBlur = 5 * scale;
            ctx.strokeStyle = '#5a4d31';
            ctx.lineWidth = 3 * scale;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - gameState.groundHeight);
            ctx.lineTo(canvas.width, canvas.height - gameState.groundHeight);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Enhanced pipes with gradients and shadows
            gameState.pipes.forEach(pipe => {
                ctx.save();
                
                // Pipe shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 8 * scale;
                ctx.shadowOffsetX = 3 * scale;
                ctx.shadowOffsetY = 2 * scale;
                
                // Pipe gradient
                const pipeGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipe.width, 0);
                pipeGradient.addColorStop(0, '#8BC34A');
                pipeGradient.addColorStop(0.3, '#74bf2e');
                pipeGradient.addColorStop(0.7, '#689F38');
                pipeGradient.addColorStop(1, '#558B2F');
                ctx.fillStyle = pipeGradient;
                
                // Top pipe with rounded bottom
                ctx.beginPath();
                ctx.roundRect(pipe.x, 0, pipe.width, pipe.topHeight - 5 * scale, [0, 0, 8 * scale, 8 * scale]);
                ctx.fill();
                
                // Bottom pipe with rounded top
                const bottomPipeY = pipe.topHeight + pipe.gap;
                ctx.beginPath();
                ctx.roundRect(pipe.x, bottomPipeY + 5 * scale, pipe.width, 
                    canvas.height - bottomPipeY - gameState.groundHeight - 5 * scale, [8 * scale, 8 * scale, 0, 0]);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Enhanced pipe caps with beveled edges
                const capHeight = 20 * scale;
                const capWidth = pipe.width + 10 * scale;
                const capXOffset = -5 * scale;
                
                const capGradient = ctx.createLinearGradient(pipe.x + capXOffset, 0, pipe.x + capXOffset + capWidth, 0);
                capGradient.addColorStop(0, '#A5D6A7');
                capGradient.addColorStop(0.5, '#8BC34A');
                capGradient.addColorStop(1, '#689F38');
                ctx.fillStyle = capGradient;
                
                // Top cap with highlight
                ctx.beginPath();
                ctx.roundRect(pipe.x + capXOffset, pipe.topHeight - capHeight, capWidth, capHeight, 4 * scale);
                ctx.fill();
                
                // Bottom cap with highlight
                ctx.beginPath();
                ctx.roundRect(pipe.x + capXOffset, bottomPipeY, capWidth, capHeight, 4 * scale);
                ctx.fill();
                
                // Add pipe highlights
                ctx.strokeStyle = '#C8E6C9';
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.moveTo(pipe.x + 3 * scale, 5 * scale);
                ctx.lineTo(pipe.x + 3 * scale, pipe.topHeight - 10 * scale);
                ctx.moveTo(pipe.x + 3 * scale, bottomPipeY + 10 * scale);
                ctx.lineTo(pipe.x + 3 * scale, canvas.height - gameState.groundHeight - 5 * scale);
                ctx.stroke();
                
                ctx.restore();
            });

            // Enhanced bird with detailed sprite and animation
            const bird = gameState.bird;
            if (bird) {
                ctx.save();
                ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
                
                // Bird rotation based on velocity for more realistic movement
                const rotation = Math.max(-0.5, Math.min(0.3, bird.dy * 0.002));
                ctx.rotate(rotation);
                
                // Wing flap animation
                const flapSpeed = gameState.gameStarted ? 15 : 5;
                const wingOffset = Math.sin(time * flapSpeed) * 5 * scale;
                
                // Bird shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 8 * scale;
                ctx.shadowOffsetX = 2 * scale;
                ctx.shadowOffsetY = 3 * scale;
                
                // Main body with gradient
                const bodyGradient = ctx.createRadialGradient(-2 * scale, -3 * scale, 0, 0, 0, bird.width / 2);
                bodyGradient.addColorStop(0, '#FFF176');
                bodyGradient.addColorStop(0.6, '#ffeb3b');
                bodyGradient.addColorStop(1, '#F57F17');
                ctx.fillStyle = bodyGradient;
                
                ctx.beginPath();
                ctx.ellipse(0, 0, bird.width / 2, bird.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Wing with animation
                const wingGradient = ctx.createLinearGradient(-bird.width/2, wingOffset, bird.width/4, wingOffset);
                wingGradient.addColorStop(0, '#FFD54F');
                wingGradient.addColorStop(0.7, '#FFC107');
                wingGradient.addColorStop(1, '#FF8F00');
                ctx.fillStyle = wingGradient;
                
                ctx.beginPath();
                ctx.ellipse(-bird.width/4, wingOffset, bird.width/3, bird.height/4, -0.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Wing outline
                ctx.strokeStyle = '#FF8F00';
                ctx.lineWidth = 1 * scale;
                ctx.stroke();
                
                // Enhanced beak with gradient
                const beakGradient = ctx.createLinearGradient(bird.width/2, 0, bird.width/2 + 12 * scale, 0);
                beakGradient.addColorStop(0, '#FFB74D');
                beakGradient.addColorStop(1, '#ff8c00');
                ctx.fillStyle = beakGradient;
                
                ctx.beginPath();
                ctx.moveTo(bird.width / 2, -2 * scale);
                ctx.lineTo(bird.width / 2 + 12 * scale, 0);
                ctx.lineTo(bird.width / 2, 2 * scale);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#F57C00';
                ctx.lineWidth = 1 * scale;
                ctx.stroke();
                
                // Enhanced eye with pupil and highlight
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(bird.width * 0.2, -bird.height * 0.15, 4 * scale, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye highlight
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(bird.width * 0.2 + 1 * scale, -bird.height * 0.15 - 1 * scale, 1.5 * scale, 0, Math.PI * 2);
                ctx.fill();
                
                // Tail feathers
                ctx.fillStyle = '#FFC107';
                ctx.beginPath();
                ctx.moveTo(-bird.width / 2, 0);
                ctx.lineTo(-bird.width / 2 - 6 * scale, -4 * scale);
                ctx.lineTo(-bird.width / 2 - 8 * scale, 0);
                ctx.lineTo(-bird.width / 2 - 6 * scale, 4 * scale);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#FF8F00';
                ctx.stroke();
                
                ctx.restore();
                
                // Add motion trail when bird is falling fast
                if (bird.dy > 200) {
                    for (let i = 1; i <= 3; i++) {
                        const trailAlpha = (4 - i) / 4 * 0.3;
                        const trailY = bird.y + bird.height / 2 - bird.dy * 0.01 * i;
                        
                        ctx.globalAlpha = trailAlpha;
                        ctx.fillStyle = '#ffeb3b';
                        ctx.beginPath();
                        ctx.arc(bird.x + bird.width / 2, trailY, (bird.width / 2) * (1 - i * 0.2), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
            }

            // Game start instructions with enhanced styling
            if (!gameState.gameStarted && !gameState.isGameOver) {
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 10 * scale;
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${24 * scale}px 'Courier New', monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const pulseScale = 1 + Math.sin(time * 3) * 0.1;
                ctx.scale(pulseScale, pulseScale);
                ctx.fillText('Press Spacebar to Start!', (canvas.width / 2) / pulseScale, (canvas.height / 2 - 50 * scale) / pulseScale);
                
                ctx.restore();
            }
        }
        
        function drawFlappyCloud(x, y, size, scale) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            
            // Main cloud body
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
            ctx.arc(size * 0.5, 0, size * 0.5, 0, Math.PI * 2);
            ctx.arc(-size * 0.5, 0, size * 0.4, 0, Math.PI * 2);
            ctx.arc(size * 0.2, -size * 0.4, size * 0.3, 0, Math.PI * 2);
            ctx.arc(-size * 0.2, -size * 0.3, size * 0.35, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        // --- End Flappy Bird Game ---


        // Initial setup on window load
        window.addEventListener('load', () => {
            createStars();
            // Ensure canvas and context are available globally before any game starts
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Initialize global sound and particle systems
            soundManager = new SoundManager();
            particleSystem = new ParticleSystem(ctx);

            document.getElementById('gameSelection').style.display = 'grid'; // Show game selection menu initially
            document.getElementById('gameArea').style.display = 'none'; // Hide game area initially
            document.getElementById('gameOverOverlay').classList.remove('active'); // Hide game over overlay
            document.getElementById('messageBox').style.display = 'none'; // Hide message box
            document.getElementById('mainHeader').style.display = 'block'; // Ensure header is shown on initial load
            document.getElementById('gameTitle').style.display = 'none'; 
            // Hide Pong's specific elements on initial load
            document.getElementById('pongDifficultySelection').style.display = 'none'; 
            document.getElementById('restartGameButton').style.display = 'none';
            document.querySelector('.action-buttons').style.display = 'none';

            updateScore(); // Initial update for score display (will show Score: 0)
        });

        // Re-create stars and resize canvas on window resize to ensure full coverage and responsiveness
        window.addEventListener('resize', () => {
            createStars();
            // Call resizeCanvas only if a game is currently selected and active.
            // If the game is not active, it means we are in the menu or an overlay,
            // so no need to resize the canvas yet.
            if (currentGame && gameActive) {
                resizeCanvas();
            }
        });
    </script>
</body>
</html>
