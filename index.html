<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroArcade - Play Games Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            color: #00ff41;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll for the body */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        .container {
            position: relative;
            z-index: 2;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff41;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            width: 100%;
            max-width: 650px;
        }
        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff41;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px #00ff41; }
            to { text-shadow: 0 0 20px #00ff41, 0 0 30px #00ff41; }
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
            width: 100%;
        }
        .game-card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .game-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 65, 0.1), transparent);
            transform: rotate(45deg) translateX(-100%) translateY(-100%); /* Start off-screen */
            opacity: 0;
            transition: none; /* Animation will control the visual properties */
        }
        @keyframes shine {
            0% { transform: rotate(45deg) translateX(-100%) translateY(-100%); opacity: 0; }
            1% { opacity: 1; } /* Make it visible at the start of the sweep */
            99% { opacity: 1; } /* Keep it visible during the sweep */
            100% { transform: rotate(45deg) translateX(100%) translateY(100%); opacity: 0; } /* End off-screen and fade out */
        }
        .game-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 30px rgba(0, 255, 65, 0.4);
            border-color: #00ffff;
        }
        .game-card:hover::before {
            animation: shine 1.5s linear infinite; /* Play animation continuously while hovered */
        }
        .game-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #00ffff;
        }
        .game-description {
            margin-bottom: 20px;
            opacity: 0.9;
            line-height: 1.4;
        }
        .play-btn {
            background: linear-gradient(45deg, #00ff41, #00ffff);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: #000;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.5);
        }
        .game-area {
            display: none;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            width: 100%; /* Allows it to take full width */
            /* max-width removed to allow full expansion */
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.1); 
            display: flex; /* Use flexbox to center content */
            flex-direction: column;
            align-items: center;
        }
        .game-canvas {
            border: 2px solid #00ffff;
            border-radius: 10px;
            background: #000;
            margin: 20px auto;
            display: block;
            width: 100%; /* Take full width of its parent (game-area) */
            height: auto; /* Maintain aspect ratio based on width */
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
            /* Removed min-width to allow full responsiveness */
        }

        .game-controls {
            margin: 20px 0;
            text-align: center;
            color: #00ff41;
        }
        .control-btn {
            background: #00ff41;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .control-btn:hover {
            background: #00ffff;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.5);
        }

        .score {
            font-size: 1.3rem;
            margin: 10px 0;
            color: #00ffff;
        }
        /* Minesweeper specific controls for flags/timer */
        #minesweeperInfo {
            display: flex;
            justify-content: space-between;
            width: 100%;
            min-width: 300px; /* Ensure a minimum width for info bar */
            max-width: 600px; /* Limit to canvas width */
            margin-top: 10px;
            color: #00ffff;
            font-size: 1.1rem;
            margin-left: auto;
            margin-right: auto;
        }
        /* Pong Difficulty Selection */
        #pongDifficultySelection {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            margin: 20px auto;
            text-align: center;
            max-width: 400px;
            width: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #pongDifficultySelection h3 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #00ff41;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }
        #pongDifficultySelection label {
            font-size: 1.2rem;
            margin: 10px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            color: #00ffff;
        }
        #pongDifficultySelection input[type="radio"] {
            margin-right: 10px;
            transform: scale(1.5);
            accent-color: #00ff41;
            cursor: pointer;
        }
        #pongDifficultySelection button {
            margin-top: 25px;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
        }


        .action-buttons {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        .back-btn {
            background: #ff4444;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        .back-btn:hover {
            background: #ff6666;
        }
        
        /* Game Over Overlay Styles */
        .game-over-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            z-index: 100;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #00ff41;
            text-align: center;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(5px);
        }
        .game-over-overlay.active {
            display: flex;
        }
        .game-over-content {
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff0041;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 0 30px rgba(255, 0, 65, 0.6);
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .game-over-content h2 {
            font-size: 3rem;
            color: #ff0041;
            text-shadow: 0 0 15px #ff0041;
            margin-bottom: 20px;
            animation: heartbeat 1.5s infinite;
        }
        @keyframes heartbeat {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .game-over-content p {
            font-size: 1.8rem;
            margin-bottom: 10px; /* Reduced margin to make space for high score */
            color: #00ffff;
        }
        .game-over-buttons button {
            background: linear-gradient(45deg, #00ff41, #00ffff);
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            color: #000;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .game-over-buttons button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        }

        /* Message Box Style */
        .message-box {
            background: rgba(0, 0, 0, 1);
            border: 2px solid #ffeb3b;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
            font-size: 1.1rem;
            color: #ffeb3b;
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.5);
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            max-width: 80%;
        }

        /* Galactic Invaders Specific Styles */
        .galactic-invaders-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            min-width: 300px; /* Ensure a minimum width for info bar */
            max-width: 600px; /* Limit to canvas width */
            margin-top: 10px;
            color: #00ff41;
            font-size: 1.1rem;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>

    <div class="container">
        <header id="mainHeader">
            <h1>🎮 RETROARCADE 🎮</h1>
            <p class="subtitle">Classic Games Reimagined for the Web</p>
        </header>

        <div id="gameSelection" class="games-grid">
            <div class="game-card" onclick="startGame('dino')">
                <h3 class="game-title">🦖 Prehistoric Run</h3>
                <p class="game-description">Leap over cacti and dodge pterodactyls in this endless runner classic. How long can you survive the ancient world? Press SPACE to jump!</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('snake')">
                <h3 class="game-title">🐍 Neon Snake</h3>
                <p class="game-description">Guide the glowing serpent through the digital void. Collect energy orbs to grow longer, but don't crash into yourself! Use WASD or Arrow Keys.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('pong')">
                <h3 class="game-title">⚡ Cyber Pong</h3>
                <p class="game-description">The classic paddle game with a futuristic twist. Can you beat the AI opponent in this high-speed digital duel? Use W/S or ↑/↓ arrows.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('asteroids')">
                <h3 class="game-title">💫 Space Rocks</h3>
                <p class="game-description">Navigate your ship through a dangerous asteroid field. Blast the rocks to survive and rack up points! Use WASD to move, SPACE to shoot.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('breakout')">
                <h3 class="game-title">🧱 Block Destroyer</h3>
                <p class="game-description">Break through the neon barrier with your energy ball. Clear all blocks to advance to the next level! Use A/D or ←/→ arrows.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('tetris')">
                <h3 class="game-title">🟦 Pixel Tetris</h3>
                <p class="game-description">Arrange falling blocks to form complete lines and clear them. Don't let the stack reach the top! Use Arrow Keys or WASD to move and rotate.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('minesweeper')">
                <h3 class="game-title">💣 Hidden Grid</h3>
                <p class="game-description">Clear the minefield without detonating any hidden mines! Click to reveal a square; if a number appears, it tells you how many mines are adjacent. Right-click (or Ctrl+Click) to flag suspected mine locations. Reveal all non-mine squares to win!</p>
                <button class="play-btn">Play Now</button>
            </div>
            <!-- NEW GALAGA-LIKE GAME CARD -->
            <div class="game-card" onclick="startGame('galacticInvaders')">
                <h3 class="game-title">🚀 Galactic Invaders</h3>
                <p class="game-description">Defend your galaxy from waves of alien invaders! Move your ship left and right, and fire lasers to destroy them. Don't let them reach the bottom!</p>
                <button class="play-btn">Play Now</button>
            </div>
            <!-- END NEW GALAGA-LIKE GAME CARD -->
        </div>

        <div id="gameArea" class="game-area">
            <h2 id="gameTitle"></h2>
            <!-- Generic score display, hidden for Minesweeper/GalacticInvaders which have custom info bars -->
            <div class="score" id="scoreDisplay">Score: 0</div> 

            <!-- Minesweeper specific info display -->
            <div id="minesweeperInfo" style="display: none;">
                <span id="mineCountDisplay">Mines: 0</span>
                <span id="timerDisplay">Time: 0s</span>
            </div>

            <!-- Galactic Invaders specific info display -->
            <div id="galacticInvadersInfo" class="galactic-invaders-info" style="display: none;">
                <span id="galacticScoreDisplay">Score: 0</span>
                <span id="galacticLivesDisplay">Lives: 3</span>
                <span id="galacticWaveDisplay">Wave: 1</span>
            </div>

            <!-- Pong Difficulty Selection -->
            <div id="pongDifficultySelection">
                <h3>Choose Difficulty:</h3>
                <label>
                    <input type="radio" name="pongDifficulty" value="easy" checked> Easy
                </label>
                <label>
                    <input type="radio" name="pongDifficulty" value="hard"> Hard
                </label>
                <button class="play-btn" onclick="startSelectedPongDifficulty()">Start Cyber Pong</button>
            </div>
            <canvas id="gameCanvas" class="game-canvas"></canvas>
            <div class="game-controls" id="gameControls"></div>
            <div class="action-buttons">
                <button class="control-btn" id="restartGameButton" onclick="restartGame()" style="background: #ffaa00;">🔄 Restart Game</button>
                <button class="back-btn" id="backToMenuButton" onclick="backToMenu()">← Back to Games</button>
            </div>
        </div>
    </div>

    <!-- Message box for start instructions or in-game messages -->
    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageBoxOkBtn">OK</button>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay">
        <div class="game-over-content">
            <h2>GAME OVER!</h2>
            <p id="finalScoreDisplay">Final Score: 0</p>
            <div class="game-over-buttons">
                <button onclick="restartGameFromGameOver()">Play Again</button>
                <button onclick="backToMenuFromGameOver()">Back to Menu</button>
            </div>
        </div>
    </div>

    <script>
        // Create animated stars background
        function createStars() {
            const starsContainer = document.getElementById('stars');
            starsContainer.innerHTML = ''; // Clear existing stars
            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = Math.random() * 3 + 1 + 'px';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        let currentGame = null;
        let animationFrameId = null; // Stores the requestAnimationFrame ID for the active game
        let canvas, ctx; // Main canvas and context

        let score = 0;
        let gameState = {}; // Holds game-specific variables for the current game

        let gameActive = false; // Global flag to control game loop

        // Global variables for tracking previous canvas size for scaling active game elements
        let previousCanvasWidth = 0;
        let previousCanvasHeight = 0;

        // --- Keyboard Input Tracking (Centralized) ---
        const keysPressed = new Set(); // Tracks which keys are currently held down

        document.addEventListener('keydown', (e) => {
            // Only process input if a game is active AND the game over/start overlays are NOT active
            if (gameActive && 
                !document.getElementById('gameOverOverlay').classList.contains('active') &&
                document.getElementById('messageBox').style.display !== 'block') { 
                
                const lowerKey = e.key.toLowerCase();
                // Prevent default browser behavior for relevant keys
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd'].includes(lowerKey)) {
                    e.preventDefault();
                }
                keysPressed.add(lowerKey);

                // --- Game-specific input handling ---
                switch (currentGame) {
                    case 'dino':
                        if (lowerKey === ' ' && !gameState.dino.isJumping) {
                            gameState.dino.jump();
                        }
                        break;
                    case 'snake':
                        if (lowerKey === 'arrowup' || lowerKey === 'w') {
                            changeDirection('up');
                        } else if (lowerKey === 'arrowdown' || lowerKey === 's') {
                            changeDirection('down');
                        } else if (lowerKey === 'arrowleft' || lowerKey === 'a') {
                            changeDirection('left');
                        } else if (lowerKey === 'arrowright' || lowerKey === 'd') {
                            changeDirection('right');
                        }
                        break;
                    case 'asteroids':
                         if (lowerKey === ' ') {
                            shootBulletAsteroids();
                        }
                        break;
                    case 'tetris':
                        if (lowerKey === 'arrowup' || lowerKey === 'w') {
                            if (!e.repeat) { // Prevent multiple rotations on hold
                                rotatePiece(gameState.currentPiece, 1);
                            }
                        } else if (lowerKey === ' ') { // Hard drop
                            if (!e.repeat) {
                                while (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY + 1)) {
                                    gameState.pieceY++;
                                }
                                lockPiece();
                            }
                        }
                        break;
                    case 'galacticInvaders':
                        if (lowerKey === ' ' && gameState.player.canShoot) {
                            firePlayerBullet();
                        }
                        break;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed.delete(e.key.toLowerCase());
        });

        // --- Main Game Loop (requestAnimationFrame) ---
        let lastFrameTime = 0;
        function gameLoop(currentTime) {
            // Stop if no game is selected or if game is not active
            if (!currentGame || !gameActive) return; 

            const deltaTime = (currentTime - lastFrameTime) / 1000; // DeltaTime in seconds
            lastFrameTime = currentTime;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw specific game
            switch(currentGame) {
                case 'dino': updateDino(deltaTime); drawDino(); break;
                case 'snake': updateSnake(deltaTime); drawSnake(); break;
                case 'pong': updatePong(deltaTime); drawPong(); break;
                case 'asteroids': updateAsteroids(deltaTime); drawAsteroids(); break;
                case 'breakout': updateBreakout(deltaTime); drawBreakout(); break;
                case 'tetris': updateTetris(deltaTime); drawTetris(); break;
                case 'minesweeper': updateMinesweeper(deltaTime); drawMinesweeper(); break;
                case 'galacticInvaders': updateGalacticInvaders(deltaTime); drawGalacticInvaders(); break;
            }

            // Continue the loop only if game is active and not showing a message or game over screen
            if (gameActive && !document.getElementById('gameOverOverlay').classList.contains('active') &&
                document.getElementById('messageBox').style.display !== 'block') { // Check if messageBox is NOT visible
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // Global function to handle canvas resizing and drawing
        function resizeCanvas() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            const containerElement = document.querySelector('.container');
            const headerElement = document.getElementById('mainHeader');
            const gameTitleElement = document.getElementById('gameTitle');
            const scoreDisplayElement = document.getElementById('scoreDisplay');
            const minesweeperInfoElement = document.getElementById('minesweeperInfo');
            const galacticInvadersInfoElement = document.getElementById('galacticInvadersInfo');
            const actionButtonsElement = document.querySelector('.action-buttons');
            const pongDifficultySelectionElement = document.getElementById('pongDifficultySelection');
            const messageBoxElement = document.getElementById('messageBox');


            // Calculate available width and height for the canvas
            let usedVerticalSpace = 0;
            let usedHorizontalSpace = 0;

            usedHorizontalSpace = containerElement.offsetLeft * 2 + 40; // 2 * body-margin + 2 * container-padding

            usedVerticalSpace += headerElement.offsetHeight + parseFloat(getComputedStyle(headerElement).marginBottom);
            
            if (gameTitleElement.style.display !== 'none') {
                usedVerticalSpace += gameTitleElement.offsetHeight + parseFloat(getComputedStyle(gameTitleElement).marginBottom);
            }
            if (scoreDisplayElement.style.display !== 'none') {
                usedVerticalSpace += scoreDisplayElement.offsetHeight + parseFloat(getComputedStyle(scoreDisplayElement).marginBottom);
            }
            if (minesweeperInfoElement.style.display !== 'none') {
                usedVerticalSpace += minesweeperInfoElement.offsetHeight + parseFloat(getComputedStyle(minesweeperInfoElement).marginBottom);
            }
            if (galacticInvadersInfoElement.style.display !== 'none') {
                usedVerticalSpace += galacticInvadersInfoElement.offsetHeight + parseFloat(getComputedStyle(galacticInvadersInfoElement).marginBottom);
            }
            if (actionButtonsElement.style.display !== 'none') {
                usedVerticalSpace += actionButtonsElement.offsetHeight + parseFloat(getComputedStyle(actionButtonsElement).marginTop);
            }
            if (pongDifficultySelectionElement.style.display !== 'none') {
                usedVerticalSpace += pongDifficultySelectionElement.offsetHeight + parseFloat(getComputedStyle(pongDifficultySelectionElement).marginTop) + parseFloat(getComputedStyle(pongDifficultySelectionElement).marginBottom);
            }

            usedVerticalSpace += 40 + 40; // game-area padding + canvas margins

            const availableWidth = window.innerWidth - usedHorizontalSpace;
            const availableHeight = window.innerHeight - usedVerticalSpace;

            const defaultGameOriginalWidth = 600;
            const defaultGameOriginalHeight = 400;
            const giOriginalWidth = 600;
            const giOriginalHeight = 700;
            const tetrisOriginalCols = TETRIS_COLS;
            const tetrisOriginalRows = TETRIS_ROWS;
            const minesweeperOriginalCols = MINESWEEPER_DEFAULT_COLS;
            const minesweeperOriginalRows = MINESWEEPER_DEFAULT_ROWS;
            

            let originalWidth, originalHeight;
            let newCanvasWidth, newCanvasHeight;
            let calculatedBlockSize; // For grid-based games

            switch (currentGame) {
                case 'tetris':
                    // Calculate optimal block size based on available space, ensuring integer size
                    const maxBlockSizeTetrisX = Math.floor(availableWidth / tetrisOriginalCols);
                    const maxBlockSizeTetrisY = Math.floor(availableHeight / tetrisOriginalRows);
                    calculatedBlockSize = Math.min(maxBlockSizeTetrisX, maxBlockSizeTetrisY);
                    calculatedBlockSize = Math.max(10, calculatedBlockSize); // Minimum block size to ensure visibility

                    newCanvasWidth = calculatedBlockSize * tetrisOriginalCols;
                    newCanvasHeight = calculatedBlockSize * tetrisOriginalRows;
                    // For Tetris, the "original" aspect ratio is implicitly defined by cols/rows and a uniform block size
                    originalWidth = newCanvasWidth; // Use the calculated dimensions as the target
                    originalHeight = newCanvasHeight;
                    break;

                case 'minesweeper':
                    // Calculate optimal cell size based on available space, ensuring integer size
                    const maxCellSizeMinesweeperX = Math.floor(availableWidth / minesweeperOriginalCols);
                    const maxCellSizeMinesweeperY = Math.floor(availableHeight / minesweeperOriginalRows);
                    calculatedBlockSize = Math.min(maxCellSizeMinesweeperX, maxCellSizeMinesweeperY);
                    calculatedBlockSize = Math.max(10, calculatedBlockSize); // Minimum cell size

                    newCanvasWidth = calculatedBlockSize * minesweeperOriginalCols;
                    newCanvasHeight = calculatedBlockSize * minesweeperOriginalRows;
                    // For Minesweeper, the "original" aspect ratio is implicitly defined by cols/rows and a uniform cell size
                    originalWidth = newCanvasWidth; // Use the calculated dimensions as the target
                    originalHeight = newCanvasHeight;
                    break;

                case 'galacticInvaders':
                    originalWidth = giOriginalWidth;
                    originalHeight = giOriginalHeight;
                    const giAspectRatio = originalWidth / originalHeight;

                    const giCalculatedWidthBasedOnHeight = availableHeight * giAspectRatio;
                    const giCalculatedHeightBasedOnWidth = availableWidth / giAspectRatio;

                    if (giCalculatedWidthBasedOnHeight <= availableWidth) {
                        newCanvasWidth = giCalculatedWidthBasedOnHeight;
                        newCanvasHeight = availableHeight;
                    } else {
                        newCanvasWidth = availableWidth;
                        newCanvasHeight = giCalculatedHeightBasedOnWidth;
                    }
                    break;

                default: // For Pong, Dino, Snake, Asteroids, Breakout
                    originalWidth = defaultGameOriginalWidth;
                    originalHeight = defaultGameOriginalHeight;
                    const defaultAspectRatio = originalWidth / originalHeight;

                    const defaultCalculatedWidthBasedOnHeight = availableHeight * defaultAspectRatio;
                    const defaultCalculatedHeightBasedOnWidth = availableWidth / defaultAspectRatio;

                    if (defaultCalculatedWidthBasedOnHeight <= availableWidth) {
                        newCanvasWidth = defaultCalculatedWidthBasedOnHeight;
                        newCanvasHeight = availableHeight;
                    } else {
                        newCanvasWidth = availableWidth;
                        newCanvasHeight = defaultCalculatedHeightBasedOnWidth;
                    }
                    break;
            }

            // Store old dimensions before applying new ones to canvas
            const oldCanvasWidth = canvas.width;
            const oldCanvasHeight = canvas.height;

            // Apply new dimensions to canvas
            canvas.width = newCanvasWidth;
            canvas.height = newCanvasHeight;

            // Update game-specific global sizes for drawing/logic based on new canvas size
            if (currentGame === 'tetris') {
                window.TETRIS_BLOCK_SIZE = calculatedBlockSize; // Use the calculated integer block size
            } else if (currentGame === 'minesweeper') {
                window.MINE_CELL_SIZE = calculatedBlockSize; // Use the calculated integer cell size
            }

            // Ensure `previousCanvasWidth/Height` are initialized on first run or updated on subsequent runs
            if (previousCanvasWidth === 0 || previousCanvasHeight === 0 || isNaN(oldCanvasWidth) || isNaN(oldCanvasHeight) || oldCanvasWidth === 0 || oldCanvasHeight === 0) {
                previousCanvasWidth = canvas.width;
                previousCanvasHeight = canvas.height;
            } else if (canvas.width !== oldCanvasWidth || canvas.height !== oldCanvasHeight) {
                // Canvas dimensions actually changed, so scale existing game elements
                const scaleX = canvas.width / oldCanvasWidth;
                const scaleY = canvas.height / oldCanvasHeight;

                if (gameActive && gameState) {
                    switch (currentGame) {
                        case 'dino':
                            if (gameState.dino) {
                                gameState.dino.x *= scaleX;
                                gameState.dino.y *= scaleY;
                                gameState.dino.width *= scaleX;
                                gameState.dino.height *= scaleY;
                                gameState.dino.gravity *= scaleY;
                                gameState.dino.jumpStrength *= scaleY;
                                GROUND_LINE_Y = canvas.height - (canvas.height * DINO_Y_OFFSET_RATIO);
                            }
                            gameState.obstacles.forEach(obstacle => {
                                obstacle.x *= scaleX;
                                obstacle.y *= scaleY;
                                obstacle.width *= scaleX;
                                obstacle.height *= scaleY;
                            });
                            gameState.gameSpeed *= scaleX;
                            break;
                        case 'snake':
                            if (gameState.snake) {
                                gameState.gridSize *= scaleX; // Scale grid size
                                gameState.snake.forEach(segment => {
                                    segment.x = Math.round(segment.x * scaleX); // Round to nearest grid cell
                                    segment.y = Math.round(segment.y * scaleY);
                                });
                                gameState.food.x = Math.round(gameState.food.x * scaleX);
                                gameState.food.y = Math.round(gameState.food.y * scaleY);
                            }
                            break;
                        case 'pong':
                            if (gameState.paddle1) {
                                gameState.paddle1.x *= scaleX;
                                gameState.paddle1.y *= scaleY;
                                gameState.paddle1.width *= scaleX;
                                gameState.paddle1.height *= scaleY;
                                gameState.paddle1.speed *= scaleY;

                                gameState.paddle2.x *= scaleX;
                                gameState.paddle2.y *= scaleY;
                                gameState.paddle2.width *= scaleX;
                                gameState.paddle2.height *= scaleY;
                                gameState.paddle2.speed *= scaleY;

                                gameState.ball.x *= scaleX;
                                gameState.ball.y *= scaleY;
                                gameState.ball.dx *= scaleX;
                                gameState.ball.dy *= scaleY;
                                gameState.ball.radius *= Math.min(scaleX, scaleY); // Keep ball round
                                gameState.initialBallSpeed *= scaleX;
                            }
                            break;
                        case 'asteroids':
                            if (gameState.ship) {
                                gameState.ship.x *= scaleX;
                                gameState.ship.y *= scaleY;
                                gameState.ship.thrust *= Math.min(scaleX, scaleY); // Scale thrust proportionally
                            }
                            gameState.bullets.forEach(bullet => {
                                bullet.x *= scaleX;
                                bullet.y *= scaleY;
                                bullet.vx *= scaleX;
                                bullet.vy *= scaleY;
                            });
                            gameState.asteroids.forEach(asteroid => {
                                asteroid.x *= scaleX;
                                asteroid.y *= scaleY;
                                asteroid.vx *= Math.min(scaleX, scaleY); // Scale asteroid speeds
                                asteroid.vy *= Math.min(scaleX, scaleY);
                                asteroid.radius *= Math.min(scaleX, scaleY);
                            });
                            break;
                        case 'breakout':
                            if (gameState.paddle) {
                                gameState.paddle.x *= scaleX;
                                gameState.paddle.y *= scaleY;
                                gameState.paddle.width *= scaleX;
                                gameState.paddle.height *= scaleY;
                                gameState.paddle.speed *= scaleX;
                            }
                            if (gameState.ball) {
                                gameState.ball.x *= scaleX;
                                gameState.ball.y *= scaleY;
                                gameState.ball.prevX *= scaleX;
                                gameState.ball.prevY *= scaleY;
                                gameState.ball.vx *= scaleX;
                                gameState.ball.vy *= scaleY;
                                gameState.ball.radius *= Math.min(scaleX, scaleY);
                            }
                            gameState.blocks.forEach(block => {
                                block.x *= scaleX;
                                block.y *= scaleY;
                                block.width *= scaleX;
                                block.height *= scaleY;
                            });
                            break;
                        case 'galacticInvaders':
                            if (gameState.player) {
                                gameState.player.x *= scaleX;
                                gameState.player.y *= scaleY;
                                gameState.player.width *= scaleX;
                                gameState.player.height *= scaleY;
                            }
                            gameState.playerBullets.forEach(bullet => {
                                bullet.x *= scaleX;
                                bullet.y *= scaleY;
                                bullet.radius *= Math.min(scaleX, scaleY);
                                bullet.vy *= scaleY; // Bullet speed in Y scales
                            });
                            gameState.enemies.forEach(enemy => {
                                enemy.x *= scaleX;
                                enemy.y *= scaleY;
                                enemy.initialY *= scaleY; // Update initialY for oscillation
                                enemy.width *= scaleX;
                                enemy.height *= scaleY;
                                enemy.diveTargetX *= scaleX;
                            });
                            gameState.enemyBullets.forEach(bullet => {
                                bullet.x *= scaleX;
                                bullet.y *= scaleY;
                                bullet.radius *= Math.min(scaleX, scaleY);
                                bullet.vy *= scaleY; // Bullet speed in Y scales
                            });
                            gameState.explosions.forEach(explosion => {
                                explosion.x *= scaleX;
                                explosion.y *= scaleY;
                            });
                            gameState.waveOscillationAmplitude *= scaleY;
                            break;
                        case 'tetris':
                            // For Tetris, the pieces and board are based on block size, which is recalculated.
                            // We need to re-center the current piece on the new scaled board.
                            if (gameState.currentPiece) {
                                gameState.pieceX = Math.floor(TETRIS_COLS / 2) - Math.floor(gameState.currentPiece[0].length / 2);
                                // Y might need adjustment if canvas height changed drastically, but generally starts at 0
                            }
                            // No need to scale individual block positions as they are relative to grid coordinates * BLOCK_SIZE
                            break;
                        case 'minesweeper':
                            // For Minesweeper, cells are also based on MINE_CELL_SIZE, which is recalculated.
                            // No individual scaling needed as positions are grid-based.
                            break;
                    }
                }
                previousCanvasWidth = canvas.width;
                previousCanvasHeight = canvas.height;
            }
            
            // Force a redraw if game is active, regardless of whether scaling happened or not
            if (gameActive && ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                switch(currentGame) {
                    case 'dino': drawDino(); break;
                    case 'snake': drawSnake(); break;
                    case 'pong': drawPong(); break;
                    case 'asteroids': drawAsteroids(); break;
                    case 'breakout': drawBreakout(); break;
                    case 'tetris': drawTetris(); break;
                    case 'minesweeper': drawMinesweeper(); break;
                    case 'galacticInvaders': drawGalacticInvaders(); break;
                }
            }
        }


        function startGame(gameType, difficulty = null) {
            // Cancel any existing animation frame to prevent multiple loops
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Hide main game selection grid and the header
            document.getElementById('gameSelection').style.display = 'none'; 
            document.getElementById('mainHeader').style.display = 'none';
            
            // Hide all overlays that might be active
            document.getElementById('gameOverOverlay').classList.remove('active');
            document.getElementById('messageBox').style.display = 'none'; 

            currentGame = gameType; // Set current game
            
            // Re-initialize previous canvas dimensions before calling resizeCanvas for the first time
            // to ensure a clean state for scaling calculation
            previousCanvasWidth = 0;
            previousCanvasHeight = 0;

            // Set initial visibility states before calling resizeCanvas,
            // so resizeCanvas can accurately calculate available space
            document.getElementById('gameArea').style.display = 'flex'; // Show game area as flex container
            document.getElementById('gameTitle').style.display = 'block'; // Assume title will be shown for calc
            document.getElementById('scoreDisplay').style.display = 'block'; // Assume score will be shown for calc
            document.getElementById('minesweeperInfo').style.display = 'none'; // Initially hidden
            document.getElementById('galacticInvadersInfo').style.display = 'none'; // Initially hidden
            document.getElementById('restartGameButton').style.display = 'block'; // Assume buttons will be shown for calc
            document.querySelector('.action-buttons').style.display = 'flex'; // Assume buttons will be shown for calc
            canvas.style.display = 'block'; // Canvas will be visible
            document.getElementById('pongDifficultySelection').style.display = 'none'; // Initially hidden
            // Message box is positioned absolutely, so it doesn't affect flow layout for height calculation

            resizeCanvas(); // Set initial canvas size based on game type and available space

            // Clear the canvas explicitly to remove any lingering drawings
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000'; // Fill with black for a clean background
            ctx.fillRect(0, 0, canvas.width, canvas.height);


            // Hide game specific elements initially for all games
            document.getElementById('minesweeperInfo').style.display = 'none';
            document.getElementById('scoreDisplay').style.display = 'none'; // Generic score display, will be set by game type
            document.getElementById('galacticInvadersInfo').style.display = 'none'; // Galactic Invaders info display
            document.getElementById('restartGameButton').style.display = 'none'; 
            document.querySelector('.action-buttons').style.display = 'none'; 
            canvas.style.display = 'none'; 
            // Always hide game title until the game is actually started (not just showing instructions)
            document.getElementById('gameTitle').style.display = 'none'; 
            
            // Clear game state and input keys for a fresh start
            score = 0; // Reset score for the game that's about to start
            updateScore(); // This will update the scoreDisplay element
            keysPressed.clear();
            console.log(`[Game Start] Current score reset to: ${score}`); // Log for debugging

            // Remove previous Minesweeper-specific listeners (if any)
            canvas.removeEventListener('click', handleMinesweeperClick);
            canvas.removeEventListener('contextmenu', handleMinesweeperRightClick);


            // Game-specific initializations
            if (gameType === 'pong' && difficulty === null) {
                // For Pong, show difficulty selection first, and the gameArea frame
                document.getElementById('gameArea').style.display = 'flex'; // Show game area for Pong difficulty
                document.getElementById('pongDifficultySelection').style.display = 'flex';
                // gameTitle remains hidden here. It will be shown in startSelectedPongDifficulty.
                // No need to initialize Pong game state yet, it will be done after difficulty selection
            } else {
                // For other games, show the gameArea as container for messageBox
                document.getElementById('gameArea').style.display = 'flex'; 
                // gameTitle is explicitly hidden above. This will be shown when startGameFromOverlay is called.
                const controlsText = getControlsText(gameType);
                // Pass true for isStartOverlay to show 'Start Game' button
                showMessage(`**Controls:** ${controlsText}<br><br>Click 'Start Game' to begin the challenge!`, true);
                
                // Initialize game state (but don't start game loop until user clicks OK)
                gameState = {}; // Clear previous game state
                switch(gameType) {
                    case 'dino': initDino(); break;
                    case 'snake': initSnake(); break;
                    // Pong is handled above if difficulty is null
                    case 'asteroids': initAsteroids(); break;
                    case 'breakout': initBreakout(); break;
                    case 'tetris': initTetris(); break;
                    case 'minesweeper': initMinesweeper(); break;
                    case 'galacticInvaders': initGalacticInvaders(); break;
                }
            }
        }

        // Modified showMessage to distinguish start overlay messages
        function showMessage(msg, isStartOverlay = false) {
            messageText.innerHTML = msg;
            
            if (isStartOverlay) {
                messageBoxOkBtn.textContent = 'Start Game';
                messageBoxOkBtn.onclick = startGameFromOverlay; // Attach specific start function
            } else { // Regular in-game message
                messageBoxOkBtn.textContent = 'OK';
                messageBoxOkBtn.onclick = hideMessage;
            }
            messageBox.style.display = 'block'; // This makes the message box visible
            gameActive = false; // Pause game logic
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // Ensure loop stops when message is shown
                animationFrameId = null;
            }
        }
        
        function hideMessage() {
            messageBox.style.display = 'none';
            // Reset messageBoxOkBtn's onclick in case it was modified for a start overlay
            messageBoxOkBtn.onclick = hideMessage;
            messageBoxOkBtn.textContent = 'OK'; 

            gameActive = true; // Resume/start game logic
            
            // Show relevant info based on game type AFTER starting
            if (currentGame === 'minesweeper') {
                document.getElementById('minesweeperInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none'; // Minesweeper uses its own score/timer display
            } else if (currentGame === 'galacticInvaders') {
                document.getElementById('galacticInvadersInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none'; // Hide generic score
                updateGalacticInvadersScoreAndLives(); // Update specific UI
            }
            else { // For other games
                document.getElementById('minesweeperInfo').style.display = 'none';
                document.getElementById('galacticInvadersInfo').style.display = 'none';
                document.getElementById('scoreDisplay').style.display = 'block';
            }
            
            document.getElementById('gameTitle').style.display = 'block'; // Show game title now
            document.getElementById('gameArea').style.display = 'flex'; // Game Area is already active and its children will be shown
            canvas.style.display = 'block'; // Show canvas now that instructions are hidden
            document.getElementById('restartGameButton').style.display = 'block'; // Show restart button
            document.querySelector('.action-buttons').style.display = 'flex'; // Show action buttons
            
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // New function to handle starting game from the overlay's "Start Game" button
        function startGameFromOverlay() {
            messageBox.style.display = 'none';
            gameActive = true; // Set unified game active flag
            
            // Now, show the actual game elements within the gameArea
            document.getElementById('gameArea').style.display = 'flex'; // Game area container should already be visible
            document.getElementById('gameTitle').style.display = 'block'; // Show game title now
            document.getElementById('gameTitle').textContent = getGameTitle(currentGame); // Ensure title is set
            canvas.style.display = 'block'; 
            document.getElementById('restartGameButton').style.display = 'block'; // Show restart button
            document.querySelector('.action-buttons').style.display = 'flex'; // Show action buttons
            
            // Show relevant info based on game type AFTER starting
            if (currentGame === 'minesweeper') {
                document.getElementById('minesweeperInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none';
            } else if (currentGame === 'galacticInvaders') {
                document.getElementById('galacticInvadersInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none'; // Hide generic score
                updateGalacticInvadersScoreAndLives(); // Update specific UI
            }
            else { // For other games
                document.getElementById('minesweeperInfo').style.display = 'none';
                document.getElementById('galacticInvadersInfo').style.display = 'none';
                document.getElementById('scoreDisplay').style.display = 'block';
            }
            
            setupControls(currentGame); // Update controls display (now just clears the div)
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }


        function startSelectedPongDifficulty() {
            const selectedDifficulty = document.querySelector('input[name="pongDifficulty"]:checked').value;
            // Directly initialize and start Pong without the extra message box step
            initializeGame('pong', selectedDifficulty); 
            document.getElementById('pongDifficultySelection').style.display = 'none'; // Hide difficulty selection
            document.getElementById('gameTitle').style.display = 'block'; // Show game title for Pong
            document.getElementById('gameTitle').textContent = getGameTitle('pong'); // Update title
            // GameArea is already 'flex' from startGame for Pong. Now show its contents.
            document.getElementById('scoreDisplay').style.display = 'block'; // Show score display
            document.getElementById('restartGameButton').style.display = 'block'; // Show restart button
            canvas.style.display = 'block'; // Show canvas now that difficulty is selected
            document.querySelector('.action-buttons').style.display = 'flex'; // Show action buttons
            setupControls('pong'); // Setup controls (now just clears the div)
            gameActive = true;
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function gameOver(status = 'lost') {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameActive = false; // Stop game logic

            // Get references to elements
            const finalScoreDisplay = document.getElementById('finalScoreDisplay');
            const gameOverH2 = document.getElementById('gameOverOverlay').querySelector('h2');
            const gameOverContent = document.getElementById('gameOverOverlay').querySelector('.game-over-content');

            if (currentGame === 'minesweeper') {
                if (status === 'won') {
                    gameOverH2.textContent = 'YOU WON!';
                    gameOverH2.style.color = '#00ff41';
                    gameOverH2.style.textShadow = '0 0 15px #00ff41';
                    gameOverContent.style.borderColor = '#00ff41';
                    finalScoreDisplay.textContent = `Time: ${gameState.timer}s`;
                } else {
                    gameOverH2.textContent = 'GAME OVER!';
                    gameOverH2.style.color = '#ff0041';
                    gameOverH2.style.textShadow = '0 0 15px #ff0041';
                    gameOverContent.style.borderColor = '#ff0041';
                    finalScoreDisplay.textContent = `You hit a mine!`;
                }
            } else if (currentGame === 'galacticInvaders') {
                gameOverH2.textContent = 'GAME OVER!';
                gameOverH2.style.color = '#ff0077'; // Galaga-like specific color
                gameOverH2.style.textShadow = '0 0 15px #ff0077';
                gameOverContent.style.borderColor = '#ff0077';
                finalScoreDisplay.textContent = `Final Score: ${gameState.score} (Wave ${gameState.wave})`; // Include wave in final score

            }
            // For all other traditional score games
            else {
                gameOverH2.textContent = 'GAME OVER!';
                gameOverH2.style.color = '#ff0041';
                gameOverH2.style.textShadow = '0 0 15px #ff0041';
                gameOverContent.style.borderColor = '#ff0041';
                finalScoreDisplay.textContent = `Final Score: ${score}`;
            }

            document.getElementById('gameOverOverlay').classList.add('active');
        }

        function restartGame() {
            // Cancel any running game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameActive = false; // Ensure game is marked inactive before re-init

            score = 0; // Reset general score
            updateScore(); // Update generic score display
            gameState = {}; // Clear previous game state
            keysPressed.clear(); // Clear any pressed keys
            console.log(`[Game Restart] Current score reset to: ${score}`); // Log for debugging

            // Clear canvas display explicitly before re-initializing
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000'; // Fill with black
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Hide game-specific UI elements (they will be shown by startGame later)
            canvas.style.display = 'none';
            document.getElementById('restartGameButton').style.display = 'none'; 
            document.querySelector('.action-buttons').style.display = 'none'; 
            document.getElementById('scoreDisplay').style.display = 'none'; // Hide generic score
            document.getElementById('minesweeperInfo').style.display = 'none'; 
            document.getElementById('galacticInvadersInfo').style.display = 'none'; // Hide Galactic Invaders info
            document.getElementById('gameTitle').style.display = 'none'; // Explicitly hide game title on restart
            document.getElementById('pongDifficultySelection').style.display = 'none'; // Hide pong difficulty if it was visible

            // Ensure gameArea is visible as container for the message/difficulty
            document.getElementById('gameArea').style.display = 'flex'; // Changed to flex

            // Re-initialize previous canvas dimensions for accurate scaling upon restart
            previousCanvasWidth = 0;
            previousCanvasHeight = 0;

            if (currentGame === 'pong') {
                // For Pong, go back to difficulty selection, which correctly uses gameArea styling
                startGame('pong', null); 
            } else {
                // For other games, re-initialize and show the start message again (which uses gameArea styling)
                initializeGame(currentGame); 
                const controlsText = getControlsText(currentGame);
                showMessage(`**Controls:** ${controlsText}<br><br>Click 'Start Game' to begin the challenge!`, true); 
            }
        }

        function restartGameFromGameOver() {
            document.getElementById('gameOverOverlay').classList.remove('active');
            // Call startGame for the current game, which handles all necessary resets and setup.
            restartGame(); // Use restartGame to ensure full re-init and setup for controls/canvas
        }


        function backToMenuFromGameOver() {
            document.getElementById('gameOverOverlay').classList.remove('active');
            backToMenu();
        }

        function backToMenu() {
            // Cancel any running game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameActive = false; // Reset gameActive when returning to menu

            // Clear canvas explicitly when going back to menu
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000'; // Fill with black
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Hide all game displays and overlays
            document.getElementById('gameArea').style.display = 'none'; // Ensure gameArea is hidden
            document.getElementById('pongDifficultySelection').style.display = 'none';
            document.getElementById('messageBox').style.display = 'none';
            document.getElementById('gameOverOverlay').classList.remove('active');

            // Show main menu and header
            document.getElementById('gameSelection').style.display = 'grid'; 
            document.getElementById('mainHeader').style.display = 'block';
            
            currentGame = null; // Clear current game selection
            score = 0; // Reset general score for the menu
            updateScore();
            keysPressed.clear(); // Clear any pressed keys

            // Reset previous canvas dimensions when returning to menu to prevent scaling issues on next game start
            previousCanvasWidth = 0;
            previousCanvasHeight = 0;

            document.getElementById('minesweeperInfo').style.display = 'none'; // Hide Minesweeper info
            document.getElementById('galacticInvadersInfo').style.display = 'none'; // Hide Galactic Invaders info
            document.getElementById('scoreDisplay').style.display = 'block'; // Ensure general score display is visible
            document.getElementById('restartGameButton').style.display = 'none'; // Hide restart button when back to menu
            document.querySelector('.action-buttons').style.display = 'none'; // Hide action buttons when back to menu
            document.getElementById('gameTitle').style.display = 'none'; // Ensure it's hidden when returning to menu


            // Ensure canvas is hidden when going back to menu
            if (canvas) {
                canvas.style.display = 'none';
            }

            // Remove Minesweeper specific listeners
            canvas.removeEventListener('click', handleMinesweeperClick);
            canvas.removeEventListener('contextmenu', handleMinesweeperRightClick);
        }

        function updateScore() {
            // This function is for traditional game scores only
            if (currentGame !== 'minesweeper' && currentGame !== 'galacticInvaders') { // Minesweeper and Galactic Invaders have their own score display
                document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
            }
        }

        // Helper function to initialize game state without starting the loop immediately
        function initializeGame(gameType, difficulty = null) {
            // This function now only handles the initial setup for traditional games
            // Canvas/context is already set up by startGame for the correct game type.

            if (ctx) { // Only clear if it's a traditional game canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            switch(gameType) {
                case 'dino': initDino(); break;
                case 'snake': initSnake(); break;
                case 'pong': initPong(difficulty); break;
                case 'asteroids': initAsteroids(); break;
                case 'breakout': initBreakout(); break;
                case 'tetris': initTetris(); break;
                case 'minesweeper': initMinesweeper(); break;
                case 'galacticInvaders': initGalacticInvaders(); break;
            }
        }

        function getGameTitle(gameType) {
            const titles = {
                dino: '🦖 Prehistoric Run',
                snake: '🐍 Neon Snake',
                pong: '⚡ Cyber Pong',
                asteroids: '💫 Space Rocks',
                breakout: '🧱 Block Destroyer',
                tetris: '🟦 Pixel Tetris',
                minesweeper: '💣 Hidden Grid',
                galacticInvaders: '🚀 Galactic Invaders'
            };
            return titles[gameType];
        }

        function getControlsText(gameType) {
            let instructions = '';
            switch (gameType) {
                case 'dino': instructions = 'Press **SPACEBAR** to jump over obstacles.'; break;
                case 'snake': instructions = 'Use **WASD** or **Arrow Keys** to change snake direction.'; break;
                case 'pong': instructions = 'Use **W** (Up) and **S** (Down) or **↑ Arrow** (Up) and **↓ Arrow** (Down) to move your paddle.'; break;
                case 'asteroids': instructions = 'Use **W** or **↑ Arrow** for thrust. Use **A** or **← Arrow** to rotate left. Use **D** (Right) or **→ Arrow** to rotate right. Press **SPACEBAR** to shoot.'; break;
                case 'breakout': instructions = 'Use **A** (Left) and **D** (Right) or **← Arrow** (Left) and **→ Arrow** (Right) to move your paddle.'; break;
                case 'tetris': instructions = 'Use **← Arrow / A** (Left), **→ Arrow / D** (Right), **↓ Arrow / S** (Soft Drop). Use **↑ Arrow / W** (Rotate). Press **SPACEBAR** for Hard Drop.'; break;
                case 'minesweeper': instructions = 'Click a square to reveal it. Right-click (or Ctrl+Click) to flag a mine. Clear all non-mine squares to win.'; break;
                case 'galacticInvaders': instructions = 'Use **A** (Left) and **D** (Right) or **← Arrow** (Left) and **→ Arrow** (Right) to move your ship. Press **SPACEBAR** to shoot.'; break;
                default: instructions = 'Keyboard controls.';
            }
            return instructions;
        }

        function setupControls(gameType) {
            const controlsDiv = document.getElementById('gameControls');
            controlsDiv.innerHTML = ''; // Clear the content of the controls div
        }


        // --- Dino Game ---
        // GROUND_LINE_Y will now be relative to dynamic canvas.height
        let GROUND_LINE_Y;
        const DINO_Y_OFFSET_RATIO = 0.0125; // 5 / 400 = 0.0125 (original offset / original canvas height)
        const DINO_HEIGHT_RATIO = 0.125; // 50 / 400 = 0.125
        const DINO_WIDTH_RATIO = 0.05; // 30 / 600 = 0.05

        function initDino() {
            // Update constants based on current canvas size
            const currentDinoHeight = canvas.height * DINO_HEIGHT_RATIO;
            const currentDinoWidth = canvas.width * DINO_WIDTH_RATIO;
            GROUND_LINE_Y = canvas.height - (canvas.height * DINO_Y_OFFSET_RATIO);

            gameState.dino = {
                x: 50 * (canvas.width / 600), // Scale initial x
                y: GROUND_LINE_Y - currentDinoHeight, // Use scaled height
                width: currentDinoWidth,
                height: currentDinoHeight,
                dy: 0, 
                gravity: 2400 * (canvas.height / 400), // Scale gravity with height
                jumpStrength: -600 * (canvas.height / 400), // Scale jump strength with height
                isJumping: false,
                draw() {
                    if (!ctx) return;
                    ctx.fillStyle = '#00ff41'; ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.beginPath(); ctx.arc(this.x + this.width, this.y + this.height * 0.2, this.width * 0.5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x + this.width + 5 * (canvas.width / 600), this.y + this.height * 0.1, this.width * 0.3, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#1a1a2e'; ctx.beginPath(); ctx.arc(this.x + this.width + this.width * 0.4, this.y + this.height * 0.15, 2 * (canvas.width / 600), 0, Math.PI * 2); ctx.fill();
                },
                jump() { if (!this.isJumping) { this.dy = this.jumpStrength; this.isJumping = true; } },
                update(deltaTime) {
                    this.dy += this.gravity * deltaTime; // Apply gravity over time
                    this.y += this.dy * deltaTime; // Apply vertical movement over time
                    if (this.y + this.height > GROUND_LINE_Y) { this.y = GROUND_LINE_Y - this.height; this.dy = 0; this.isJumping = false; }
                }
            };
            gameState.obstacles = [];
            gameState.gameSpeed = 500 * (canvas.width / 600); // Initial speed, scaled
            gameState.obstacleSpawnTimer = 0; // In seconds
            gameState.obstacleSpawnInterval = 0.7; // Initial interval
        }

        function createDinoObstacle() {
            const scaleFactor = canvas.width / 600;
            const obstacleTypes = [
                { width: 20 * scaleFactor, height: 40 * scaleFactor, color: '#ff0041' },
                { width: 30 * scaleFactor, height: 60 * scaleFactor, color: '#ff0041' },
                { width: 45 * scaleFactor, height: 25 * scaleFactor, color: '#ff0041', isFlying: true, yOffset: 100 * scaleFactor }
            ];
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            gameState.obstacles.push({
                x: canvas.width, y: type.isFlying ? (GROUND_LINE_Y - type.height - type.yOffset) : (GROUND_LINE_Y - type.height),
                width: type.width, height: type.height, color: type.color,
                draw() {
                    if (!ctx) return; ctx.fillStyle = this.color;
                    if (type.isFlying) {
                         ctx.beginPath(); ctx.moveTo(this.x, this.y + this.height * 0.5); ctx.lineTo(this.x + this.width, this.y); ctx.lineTo(this.x + this.width * 0.8, this.y + this.height * 0.5); ctx.lineTo(this.x + this.width, this.y + this.height); ctx.lineTo(this.x, this.y + this.height * 0.5); ctx.fill();
                    } else { ctx.fillRect(this.x, this.y, this.width, this.height); }
                }
            });
        }

        function updateDino(deltaTime) {
            for (let i = 0; i < gameState.obstacles.length; i++) {
                gameState.obstacles[i].x -= gameState.gameSpeed * deltaTime; // Move obstacles by speed * deltaTime
                const dino = gameState.dino; const obstacle = gameState.obstacles[i];
                if (dino.x < obstacle.x + obstacle.width && dino.x + dino.width > obstacle.x && dino.y < obstacle.y + obstacle.height && dino.y + dino.height > obstacle.y) {
                    gameOver(); return;
                }
            }
            gameState.obstacles = gameState.obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
            gameState.obstacleSpawnTimer += deltaTime; // Accumulate time
            if (gameState.obstacleSpawnTimer > gameState.obstacleSpawnInterval && gameState.obstacles.length < 3) {
                createDinoObstacle();
                gameState.obstacleSpawnTimer = 0;
                gameState.gameSpeed += 5 * deltaTime * (canvas.width / 600); // Increase speed over time, scaled
                // Decrease interval over time, clamp at 0.3 seconds
                gameState.obstacleSpawnInterval = Math.max(0.3, gameState.obstacleSpawnInterval - (0.02 * deltaTime)); 
            }
            gameState.dino.update(deltaTime); // Pass deltaTime to dino's update
            score++; updateScore();
        }

        function drawDino() {
            if (!ctx) return;
            ctx.strokeStyle = '#00ff41'; ctx.lineWidth = 5 * (canvas.width / 600); ctx.beginPath(); ctx.moveTo(0, GROUND_LINE_Y); ctx.lineTo(canvas.width, GROUND_LINE_Y); ctx.stroke();
            gameState.dino.draw();
            for (let obstacle of gameState.obstacles) { obstacle.draw(); }
        }
        // --- End Dino Game ---


        // --- Snake Game ---
        const SNAKE_INITIAL_GRID_SIZE = 20; // Original grid size for scaling

        function initSnake() {
            const scaleFactor = canvas.width / 600;
            const currentGridSize = SNAKE_INITIAL_GRID_SIZE * scaleFactor;
            gameState = {
                snake: [{x: 10, y: 10}], food: {x: 15, y: 15}, direction: {x: 1, y: 0}, nextDirection: {x: 1, y: 0},
                gridSize: currentGridSize,
                speed: 10, // Speed in terms of grid cells per second
                timeSinceLastMove: 0
            };
            spawnFood();
        }

        function updateSnake(deltaTime) {
            const moveInterval = 1 / gameState.speed;
            gameState.timeSinceLastMove += deltaTime;
            if (gameState.timeSinceLastMove >= moveInterval) {
                gameState.timeSinceLastMove -= moveInterval;
                gameState.direction = gameState.nextDirection;
                const head = {x: gameState.snake[0].x + gameState.direction.x, y: gameState.snake[0].y + gameState.direction.y};
                const maxGridX = Math.floor(canvas.width / gameState.gridSize);
                const maxGridY = Math.floor(canvas.height / gameState.gridSize);
                if (head.x < 0 || head.x >= maxGridX || head.y < 0 || head.y >= maxGridY) { gameOver(); return; }
                for (let i = 1; i < gameState.snake.length; i++) {
                    const segment = gameState.snake[i]; if (head.x === segment.x && head.y === segment.y) { gameOver(); return; }
                }
                gameState.snake.unshift(head);
                if (head.x === gameState.food.x && head.y === gameState.food.y) {
                    score += 10; updateScore(); if (gameState.speed < 20) gameState.speed += 0.5; spawnFood();
                } else { gameState.snake.pop(); }
            }
        }

        function spawnFood() {
            const maxGridX = Math.floor(canvas.width / gameState.gridSize);
            const maxGridY = Math.floor(canvas.height / gameState.gridSize);
            do {
                gameState.food = {x: Math.floor(Math.random() * maxGridX), y: Math.floor(Math.random() * maxGridY)};
            } while (gameState.snake.some(segment => segment.x === gameState.food.x && segment.y === gameState.food.y));
        }

        function drawSnake() {
            if (!ctx) return;
            ctx.fillStyle = '#00ff41';
            for (let segment of gameState.snake) { ctx.fillRect(segment.x * gameState.gridSize, segment.y * gameState.gridSize, gameState.gridSize - 2 * (canvas.width / 600), gameState.gridSize - 2 * (canvas.width / 600)); }
            ctx.fillStyle = '#ff0041';
            ctx.fillRect(gameState.food.x * gameState.gridSize, gameState.food.y * gameState.gridSize, gameState.gridSize - 2 * (canvas.width / 600), gameState.gridSize - 2 * (canvas.width / 600));
        }

        function changeDirection(dir) {
            if (!gameState || !gameState.direction) return;
            const directions = { up: {x: 0, y: -1}, down: {x: 0, y: 1}, left: {x: -1, y: 0}, right: {x: 1, y: 0} };
            const newDir = directions[dir];
            if (newDir && (newDir.x !== -gameState.direction.x || newDir.y !== -gameState.direction.y)) { gameState.nextDirection = newDir; }
        }
        // --- End Snake Game ---

        // --- Pong Game ---
        function initPong(difficulty) {
            gameState.difficulty = difficulty;
            const scaleFactorX = canvas.width / 600;
            const scaleFactorY = canvas.height / 400;

            // Increased base speed for easy difficulty
            let initialBallSpeed = 350 * scaleFactorX; // Default for easy, scaled by width
            if (difficulty === 'hard') {
                initialBallSpeed = 415 * scaleFactorX; // Adjusted speed for hard difficulty, scaled by width
            }
            
            const randomXDir = Math.random() < 0.5 ? 1 : -1;
            const randomYDir = Math.random() < 0.5 ? 1 : -1;
            let aiPaddleSpeed;
            if (difficulty === 'easy') { 
                aiPaddleSpeed = 250 * scaleFactorY; // Slightly increased AI speed for easy
            } else { 
                aiPaddleSpeed = 350 * scaleFactorY; 
            } // Scaled by height
            
            gameState = {
                ...gameState,
                paddle1: {
                    x: 10 * scaleFactorX, // Scaled
                    y: canvas.height/2 - (50 * scaleFactorY), // Scaled
                    width: 10 * scaleFactorX, // Scaled
                    height: 100 * scaleFactorY, // Scaled
                    dy: 0,
                    speed: 200 * scaleFactorY // Scaled
                },
                paddle2: {
                    x: canvas.width - (20 * scaleFactorX), // Scaled
                    y: canvas.height/2 - (50 * scaleFactorY), // Scaled
                    width: 10 * scaleFactorX, // Scaled
                    height: 100 * scaleFactorY, // Scaled
                    speed: aiPaddleSpeed
                },
                ball: {
                    x: canvas.width/2,
                    y: canvas.height/2,
                    dx: initialBallSpeed * randomXDir,
                    dy: initialBallSpeed * randomYDir,
                    radius: 8 * Math.min(scaleFactorX, scaleFactorY) // Scaled
                },
                initialBallSpeed: initialBallSpeed 
            };
            score = 0; updateScore();
        }

        function updatePong(deltaTime) {
            const scaleFactorY = canvas.height / 400;

            if (keysPressed.has('arrowup') || keysPressed.has('w')) { gameState.paddle1.y = Math.max(0, gameState.paddle1.y - gameState.paddle1.speed * deltaTime); }
            if (keysPressed.has('arrowdown') || keysPressed.has('s')) { gameState.paddle1.y = Math.min(canvas.height - gameState.paddle1.height, gameState.paddle1.y + gameState.paddle1.speed * deltaTime); }
            gameState.ball.x += gameState.ball.dx * deltaTime; gameState.ball.y += gameState.ball.dy * deltaTime;
            if (gameState.ball.y - gameState.ball.radius <= 0) { gameState.ball.y = gameState.ball.radius; gameState.ball.dy = -gameState.ball.dy; }
            else if (gameState.ball.y + gameState.ball.radius >= canvas.height) { gameState.ball.y = canvas.height - gameState.ball.radius; gameState.ball.dy = -gameState.ball.dy; }
            
            const ballHitPaddle1 = gameState.ball.dx < 0 && 
                                   gameState.ball.x - gameState.ball.radius <= gameState.paddle1.x + gameState.paddle1.width && 
                                   gameState.ball.y >= gameState.paddle1.y && 
                                   gameState.ball.y <= gameState.paddle1.y + gameState.paddle1.height;
            
            const ballHitPaddle2 = gameState.ball.dx > 0 && 
                                   gameState.ball.x + gameState.ball.radius >= gameState.paddle2.x && 
                                   gameState.ball.y >= gameState.paddle2.y && 
                                   gameState.ball.y <= gameState.paddle2.y + gameState.paddle2.height;

            if (ballHitPaddle1) {
                gameState.ball.x = gameState.paddle1.x + gameState.paddle1.width + gameState.ball.radius; 
                gameState.ball.dx = -gameState.ball.dx; 
                gameState.ball.dy += (Math.random() * 50 - 25) * scaleFactorY; // Scaled deflection
            }
            else if (ballHitPaddle2) {
                gameState.ball.x = gameState.paddle2.x - gameState.ball.radius; 
                gameState.ball.dx = -gameState.ball.dx; 
                gameState.ball.dy += (Math.random() * 50 - 25) * scaleFactorY; // Scaled deflection
            }

            if (gameState.ball.x < 0) { gameOver(); return; } else if (gameState.ball.x > canvas.width) {
                 gameState.ball.x = canvas.width/2; gameState.ball.y = canvas.height/2;
                 gameState.ball.dx = (Math.random() < 0.5 ? 1 : -1) * gameState.initialBallSpeed; gameState.ball.dy = (Math.random() < 0.5 ? 1 : -1) * gameState.initialBallSpeed;
                 score += 1; updateScore();
            }
            if (gameState.difficulty === 'easy') {
                let aiTargetY = gameState.ball.y - gameState.paddle2.height / 2; aiTargetY = Math.max(0, Math.min(canvas.height - gameState.paddle2.height, aiTargetY));
                const moveAmount = gameState.paddle2.speed * deltaTime;
                if (gameState.paddle2.y < aiTargetY) { gameState.paddle2.y = Math.min(aiTargetY, gameState.paddle2.y + moveAmount); }
                else if (gameState.paddle2.y > aiTargetY) { gameState.paddle2.y = Math.max(aiTargetY, gameState.paddle2.y - moveAmount); }
            } else {
                const scaleFactorX = canvas.width / 600;
                const scaleFactorY = canvas.height / 400;

                let predictedY = gameState.ball.y;
                if (gameState.ball.dx > 0 && gameState.ball.x > canvas.width / 2) {
                    const timeToReachPaddleX = (gameState.paddle2.x - gameState.ball.x) / gameState.ball.dx;
                    if (timeToReachPaddleX > 0) { predictedY = gameState.ball.y + gameState.ball.dy * timeToReachPaddleX; predictedY = Math.max(0, Math.min(canvas.height, predictedY)); }
                }
                const humanError = (Math.random() - 0.5) * 15 * scaleFactorY; // Scaled human error
                let aiTargetY = predictedY - gameState.paddle2.height / 2 + humanError; aiTargetY = Math.max(0, Math.min(canvas.height - gameState.paddle2.height, aiTargetY));
                const moveAmount = gameState.paddle2.speed * deltaTime;
                if (gameState.paddle2.y < aiTargetY) { gameState.paddle2.y = Math.min(aiTargetY, gameState.paddle2.y + moveAmount); }
                else if (gameState.paddle2.y > aiTargetY) { gameState.paddle2.y = Math.max(aiTargetY, gameState.paddle2.y - moveAmount); }
            }
        }

        function drawPong() {
            if (!ctx) return;
            const scaleFactorX = canvas.width / 600;
            const scaleFactorY = canvas.height / 400;
            
            // Draw Paddle 1 (left paddle, original rectangular shape)
            ctx.fillStyle = '#00ff41';
            ctx.fillRect(gameState.paddle1.x, gameState.paddle1.y, gameState.paddle1.width, gameState.paddle1.height);
            ctx.strokeStyle = '#00cc00'; // Add a subtle outline
            ctx.lineWidth = 1 * Math.min(scaleFactorX, scaleFactorY);
            ctx.strokeRect(gameState.paddle1.x, gameState.paddle1.y, gameState.paddle1.width, gameState.paddle1.height);

            // Draw Paddle 2 (right paddle, original rectangular shape)
            ctx.fillStyle = '#ff0041';
            ctx.fillRect(gameState.paddle2.x, gameState.paddle2.y, gameState.paddle2.width, gameState.paddle2.height);
            ctx.strokeStyle = '#cc0033'; // Add a subtle outline
            ctx.lineWidth = 1 * Math.min(scaleFactorX, scaleFactorY);
            ctx.strokeRect(gameState.paddle2.x, gameState.paddle2.y, gameState.paddle2.width, gameState.paddle2.height);

            // Draw ball
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw center line
            ctx.strokeStyle = '#00ff41';
            ctx.setLineDash([5 * scaleFactorX, 5 * scaleFactorX]); // Scaled dash
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
        }
        // --- End Pong Game ---

        // --- Asteroids Game ---
        const ASTEROIDS_SHOOT_COOLDOWN = 0.2;
        let lastShotTimeAsteroids = 0;

        function initAsteroids() {
            const scaleFactor = canvas.width / 600;
            gameState = {
                ship: {x: canvas.width/2, y: canvas.height/2, angle: -Math.PI/2, vx: 0, vy: 0, thrust: 150 * scaleFactor, rotationSpeed: 3},
                bullets: [], asteroids: []
            };
            for (let i = 0; i < 5; i++) { spawnAsteroid(3); }
            score = 0; updateScore();
        }

        function updateAsteroids(deltaTime) {
            if (keysPressed.has('arrowup') || keysPressed.has('w')) { gameState.ship.vx += Math.cos(gameState.ship.angle) * gameState.ship.thrust * deltaTime; gameState.ship.vy += Math.sin(gameState.ship.angle) * gameState.ship.thrust * deltaTime; }
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) { gameState.ship.angle -= gameState.ship.rotationSpeed * deltaTime; }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) { gameState.ship.angle += gameState.ship.rotationSpeed * deltaTime; }
            gameState.ship.x += gameState.ship.vx * deltaTime; gameState.ship.y += gameState.ship.vy * deltaTime;
            gameState.ship.vx *= (1 - 0.5 * deltaTime); gameState.ship.vy *= (1 - 0.5 * deltaTime);
            if (gameState.ship.x < 0) gameState.ship.x = canvas.width; if (gameState.ship.x > canvas.width) gameState.ship.x = 0;
            if (gameState.ship.y < 0) gameState.ship.y = canvas.height; if (gameState.ship.y > canvas.height) gameState.ship.y = 0;
            gameState.bullets = gameState.bullets.filter(bullet => {
                bullet.x += bullet.vx * deltaTime; bullet.y += bullet.vy * deltaTime;
                return bullet.x > -10 && bullet.x < canvas.width + 10 && bullet.y > -10 && bullet.y < canvas.height + 10;
            });
            gameState.asteroids.forEach(asteroid => {
                asteroid.x += asteroid.vx * deltaTime; asteroid.y += asteroid.vy * deltaTime;
                if (asteroid.x < 0) asteroid.x = canvas.width; if (asteroid.x > canvas.width) asteroid.x = 0;
                if (asteroid.y < 0) asteroid.y = canvas.height; if (asteroid.y > canvas.height) asteroid.y = 0;
            });
            for (let bIndex = gameState.bullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = gameState.bullets[bIndex];
                for (let aIndex = gameState.asteroids.length - 1; aIndex >= 0; aIndex--) {
                    const asteroid = gameState.asteroids[aIndex];
                    const dx = bullet.x - asteroid.x; const dy = bullet.y - asteroid.y;
                    if (Math.sqrt(dx * dx + dy * dy) < asteroid.radius) {
                        gameState.bullets.splice(bIndex, 1); score += 100; updateScore();
                        if (asteroid.size > 1) { spawnAsteroid(asteroid.size - 1, asteroid.x, asteroid.y); spawnAsteroid(asteroid.size - 1, asteroid.x, asteroid.y); }
                        gameState.asteroids.splice(aIndex, 1); break;
                    }
                }
            }
            const shipDetectionRadius = 10 * (canvas.width / 600); // Scale ship detection radius
            for (let asteroid of gameState.asteroids) {
                const dx = gameState.ship.x - asteroid.x; const dy = gameState.ship.y - asteroid.y;
                if (Math.sqrt(dx * dx + dy * dy) < asteroid.radius + shipDetectionRadius) { gameOver(); return; }
            }
            if (gameState.asteroids.length === 0) {
                const levelMultiplier = Math.floor(score / 500) + 1;
                for (let i = 0; i < 5 + levelMultiplier; i++) { spawnAsteroid(3); }
            }
        }

        function drawAsteroids() {
            if (!ctx) return;
            const scaleFactor = canvas.width / 600;
            ctx.save(); ctx.translate(gameState.ship.x, gameState.ship.y); ctx.rotate(gameState.ship.angle);
            ctx.strokeStyle = '#00ff41'; ctx.lineWidth = 2 * scaleFactor; ctx.beginPath(); ctx.moveTo(15 * scaleFactor, 0); ctx.lineTo(-10 * scaleFactor, -10 * scaleFactor); ctx.lineTo(-5 * scaleFactor, 0); ctx.lineTo(-10 * scaleFactor, 10 * scaleFactor); ctx.closePath(); ctx.stroke(); ctx.restore();
            ctx.fillStyle = '#00ffff'; gameState.bullets.forEach(bullet => { ctx.beginPath(); ctx.arc(bullet.x, bullet.y, 2 * scaleFactor, 0, Math.PI * 2); ctx.fill(); });
            ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2 * scaleFactor; gameState.asteroids.forEach(asteroid => { ctx.beginPath(); ctx.arc(asteroid.x, asteroid.y, asteroid.radius, 0, Math.PI * 2); ctx.stroke(); });
        }

        function shootBulletAsteroids() {
            const currentTime = performance.now() / 1000;
            if (currentTime - lastShotTimeAsteroids > ASTEROIDS_SHOOT_COOLDOWN) {
                const scaleFactor = canvas.width / 600;
                gameState.bullets.push({
                    x: gameState.ship.x + Math.cos(gameState.ship.angle) * 15 * scaleFactor, y: gameState.ship.y + Math.sin(gameState.ship.angle) * 15 * scaleFactor,
                    vx: Math.cos(gameState.ship.angle) * 300 * scaleFactor + gameState.ship.vx, vy: Math.sin(gameState.ship.angle) * 300 * scaleFactor + gameState.ship.vy
                });
                lastShotTimeAsteroids = currentTime;
            }
        }

        function spawnAsteroid(size, x = null, y = null) {
            const scaleFactor = canvas.width / 600;
            const radiusMap = { 3: 40, 2: 25, 1: 15 }; const speedMap = { 3: 60, 2: 90, 1: 120 };
            const asteroidRadius = radiusMap[size] * scaleFactor;
            const asteroidSpeed = speedMap[size] * scaleFactor;
            let asteroidX = x !== null ? x : Math.random() * canvas.width; let asteroidY = y !== null ? y : Math.random() * canvas.height;
            if (size === 3 && x === null && gameState.ship) {
                while (Math.sqrt(Math.pow(asteroidX - gameState.ship.x, 2) + Math.pow(asteroidY - gameState.ship.y, 2)) < 150 * scaleFactor) { // Scaled initial distance
                    asteroidX = Math.random() * canvas.width; asteroidY = Math.random() * canvas.height;
                }
            }
            gameState.asteroids.push({ x: asteroidX, y: asteroidY, vx: (Math.random() - 0.5) * asteroidSpeed, vy: (Math.random() - 0.5) * asteroidSpeed, radius: asteroidRadius, size: size });
        }
        // --- End Asteroids Game ---


        // --- Breakout Game ---
        function initBreakout() {
            const scaleFactorX = canvas.width / 600;
            const scaleFactorY = canvas.height / 400;

            gameState = {
                paddle: {
                    x: canvas.width/2 - (50 * scaleFactorX),
                    y: canvas.height - (20 * scaleFactorY),
                    width: 100 * scaleFactorX,
                    height: 10 * scaleFactorY,
                    speed: 250 * scaleFactorX
                },
                ball: {
                    x: canvas.width/2,
                    y: canvas.height - (30 * scaleFactorY),
                    vx: 250 * scaleFactorX,
                    vy: -250 * scaleFactorY,
                    radius: 8 * Math.min(scaleFactorX, scaleFactorY),
                    prevX: 0, prevY: 0
                },
                blocks: [], blocksRemaining: 0
            };
            const blockWidth = 55 * scaleFactorX;
            const blockHeight = 15 * scaleFactorY;
            const blockPadding = 5 * scaleFactorX;
            const blockOffsetTop = 50 * scaleFactorY;
            const blocksPerRow = 10;
            const blockOffsetLeft = (canvas.width - (blocksPerRow * blockWidth + (blocksPerRow - 1) * blockPadding)) / 2;
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < blocksPerRow; col++) {
                    gameState.blocks.push({
                        x: col * (blockWidth + blockPadding) + blockOffsetLeft,
                        y: row * (blockHeight + blockPadding) + blockOffsetTop,
                        width: blockWidth,
                        height: blockHeight,
                        color: `hsl(${row * 50}, 100%, 50%)`,
                        hits: 5 - row
                    });
                    gameState.blocksRemaining++;
                }
            }
            score = 0; updateScore();
        }

        function checkCollision(ball, rect) {
            return ball.x + ball.radius > rect.x && ball.x - ball.radius < rect.x + rect.width &&
                   ball.y + ball.radius > rect.y && ball.y - ball.radius < rect.y + rect.height;
        }
        
        function getCollisionResponse(ball, block) {
            let hitX = false; let hitY = false;
            if (ball.prevX + ball.radius <= block.x && ball.x + ball.radius > block.x) {
                ball.x = block.x - ball.radius; ball.vx *= -1; hitX = true;
            } else if (ball.prevX - ball.radius >= block.x + block.width && ball.x - ball.radius < block.x + block.width) {
                ball.x = block.x + block.width + ball.radius; ball.vx *= -1; hitX = true;
            }
            if (ball.prevY + ball.radius <= block.y && ball.y + ball.radius > block.y) {
                ball.y = block.y - ball.radius; ball.vy *= -1; hitY = true;
            } else if (ball.prevY - ball.radius >= block.y + block.height && ball.y - ball.radius < block.y + block.height) {
                ball.y = block.y + block.height + ball.radius; ball.vy *= -1; hitY = true;
            }
            return hitX || hitY;
        }
        
        function updateBreakout(deltaTime) {
            const scaleFactorX = canvas.width / 600;

            if (keysPressed.has('arrowleft') || keysPressed.has('a')) { gameState.paddle.x = Math.max(0, gameState.paddle.x - gameState.paddle.speed * deltaTime); }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) { gameState.paddle.x = Math.min(canvas.width - gameState.paddle.width, gameState.paddle.x + gameState.paddle.speed * deltaTime); }
            gameState.ball.prevX = gameState.ball.x; gameState.ball.prevY = gameState.ball.y;
            gameState.ball.x += gameState.ball.vx * deltaTime; gameState.ball.y += gameState.ball.vy * deltaTime;
            if (gameState.ball.x - gameState.ball.radius <= 0) { gameState.ball.x = gameState.ball.radius; gameState.ball.vx = -gameState.ball.vx; }
            else if (gameState.ball.x + gameState.ball.radius >= canvas.width) { gameState.ball.x = canvas.width - gameState.ball.radius; gameState.ball.vx = -gameState.ball.vx; }
            if (gameState.ball.y - gameState.ball.radius <= 0) { gameState.ball.y = gameState.ball.radius; gameState.ball.vy = -gameState.ball.vy; }
            // Corrected paddle collision variable reference from `ball` to `gameState.ball`
            if (gameState.ball.vy > 0 && gameState.ball.x + gameState.ball.radius > gameState.paddle.x && gameState.ball.x - gameState.ball.radius < gameState.paddle.x + gameState.paddle.width && gameState.ball.y + gameState.ball.radius >= gameState.paddle.y && gameState.ball.prevY + gameState.ball.radius < gameState.paddle.y) {
                gameState.ball.y = gameState.paddle.y - gameState.ball.radius; 
                gameState.ball.vy = -gameState.ball.vy;
                const hitPoint = gameState.ball.x - (gameState.paddle.x + gameState.paddle.width / 2); gameState.ball.vx = hitPoint * 2 * scaleFactorX; // Scaled deflection
            }
            for (let i = gameState.blocks.length - 1; i >= 0; i--) {
                const block = gameState.blocks[i];
                if (checkCollision(gameState.ball, block)) {
                    if (getCollisionResponse(gameState.ball, block)) {
                        block.hits--;
                        if (block.hits <= 0) { score += 10; updateScore(); gameState.blocks.splice(i, 1); gameState.blocksRemaining--; }
                        break;
                    }
                }
            }
            if (gameState.ball.y - gameState.ball.radius > canvas.height) { gameOver(); return; }
            if (gameState.blocksRemaining === 0) { gameOver(); return; }
        }
        
        function drawBreakout() {
            if (!ctx) return;
            ctx.fillStyle = '#00ff41'; ctx.fillRect(gameState.paddle.x, gameState.paddle.y, gameState.paddle.width, gameState.paddle.height);
            ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2); ctx.fill();
            gameState.blocks.forEach(block => {
                ctx.fillStyle = block.color; ctx.fillRect(block.x, block.y, block.width, block.height);
                ctx.strokeStyle = '#222'; ctx.strokeRect(block.x, block.y, block.width, block.height);
            });
        }
        // --- End Breakout Game ---


        // --- Tetris Game ---
        const TETRIS_COLS = 10;
        const TETRIS_ROWS = 20;
        // TETRIS_BLOCK_SIZE will be dynamically calculated in resizeCanvas

        const TETROMINOS = {
            'I': { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: '#00ffff' },
            'J': { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: '#0000ff' },
            'L': { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: '#ffa500' },
            'O': { shape: [[1, 1], [1, 1]], color: '#ffff00' },
            'S': { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: '#00ff00' },
            'T': { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: '#800080' },
            'Z': { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: '#ff0000' }
        };

        function initTetris() {
            // Re-calculate TETRIS_BLOCK_SIZE based on current canvas width, ensuring it's set for new game
            window.TETRIS_BLOCK_SIZE = Math.floor(canvas.width / TETRIS_COLS);

            gameState = {
                board: Array(TETRIS_ROWS).fill(0).map(() => Array(TETRIS_COLS).fill(0)),
                currentPiece: null, nextPiece: null, pieceX: 0, pieceY: 0, currentPieceColor: '',
                dropCounter: 0, dropInterval: 1, level: 1, linesCleared: 0, score: 0, isGameOver: false, lastMoveTime: 0
            };
            generateNewPiece(); gameState.dropCounter = 0; gameState.lastMoveTime = performance.now(); score = 0; updateScore();
        }

        function generateNewPiece() {
            const pieceKeys = Object.keys(TETROMINOS);
            const randomKey = pieceKeys[Math.floor(Math.random() * pieceKeys.length)];
            const pieceData = TETROMINOS[randomKey];
            gameState.currentPiece = JSON.parse(JSON.stringify(pieceData.shape)); // Deep copy
            gameState.currentPieceColor = pieceData.color;
            gameState.pieceX = Math.floor(TETRIS_COLS / 2) - Math.floor(gameState.currentPiece[0].length / 2);
            gameState.pieceY = 0;

            // Check for game over condition immediately after spawning a new piece
            if (checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY)) {
                gameState.isGameOver = true;
                gameOver();
            }
        }

        function checkTetrisCollision(board, piece, offsetX, offsetY) {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] !== 0) { // If it's a block in the tetromino
                        const boardX = x + offsetX;
                        const boardY = y + offsetY;

                        // Check for collision with walls or bottom
                        if (boardX < 0 || boardX >= TETRIS_COLS || boardY >= TETRIS_ROWS) {
                            return true;
                        }
                        // Skip collision check for cells above the board (negative Y)
                        if (boardY < 0) {
                            continue;
                        }
                        // Check for collision with existing blocks on the board
                        if (board[boardY] && board[boardY][boardX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function rotatePiece(piece, dir) {
            // Create a new array for the rotated piece to avoid modifying the original during check
            const originalPiece = JSON.parse(JSON.stringify(piece)); // Deep copy
            let newPiece = originalPiece.map((row, y) => row.map((val, x) => originalPiece[originalPiece.length - 1 - x][y]));

            if (dir === -1) { // Rotate counter-clockwise (3 times clockwise)
                for (let i = 0; i < 3; i++) {
                    newPiece = newPiece.map((row, y) => row.map((val, x) => newPiece[newPiece.length - 1 - x][y]));
                }
            }

            // Wall kick tests (simplified for basic functionality)
            const offsets = [[0, 0], [-1, 0], [1, 0], [0, -1], [-2, 0], [2, 0]]; // Common wall kick offsets
            for (const [ox, oy] of offsets) {
                if (!checkTetrisCollision(gameState.board, newPiece, gameState.pieceX + ox, gameState.pieceY + oy)) {
                    gameState.currentPiece = newPiece;
                    gameState.pieceX += ox;
                    gameState.pieceY += oy;
                    return true; // Rotation successful
                }
            }
            return false; // Rotation failed
        }

        function lockPiece() {
            for (let y = 0; y < gameState.currentPiece.length; y++) {
                for (let x = 0; x < gameState.currentPiece[y].length; x++) {
                    if (gameState.currentPiece[y][x] !== 0) {
                        // Ensure it's within bounds before placing
                        if (gameState.pieceY + y >= 0 && gameState.pieceY + y < TETRIS_ROWS &&
                            gameState.pieceX + x >= 0 && gameState.pieceX + x < TETRIS_COLS) {
                            gameState.board[gameState.pieceY + y][gameState.pieceX + x] = gameState.currentPieceColor;
                        }
                    }
                }
            }
            clearLines();
            generateNewPiece();
        }

        function clearLines() {
            let linesClearedThisTurn = 0;
            const keptLines = [];

            for (let y = 0; y < TETRIS_ROWS; y++) {
                const isLineFull = gameState.board[y].every(block => block !== 0);
                if (!isLineFull) {
                    keptLines.push(gameState.board[y]);
                } else {
                    linesClearedThisTurn++;
                }
            }

            // Add empty rows to the top for cleared lines
            const newBoard = [];
            for (let i = 0; i < linesClearedThisTurn; i++) {
                newBoard.push(Array(TETRIS_COLS).fill(0));
            }
            // Add the lines that were not full
            keptLines.forEach(row => newBoard.push(row));

            // Adjust board size if necessary (shouldn't happen if logic is perfect, but as a safeguard)
            while (newBoard.length > TETRIS_ROWS) {
                newBoard.shift(); // Remove from top if somehow too many rows
            }
            while (newBoard.length < TETRIS_ROWS) {
                newBoard.unshift(Array(TETRIS_COLS).fill(0)); // Add empty rows to top if too few
            }
            
            gameState.board = newBoard;

            if (linesClearedThisTurn > 0) {
                const scorePerLine = [0, 100, 300, 500, 800]; // Score for 0, 1, 2, 3, 4 lines
                score += scorePerLine[linesClearedThisTurn] * gameState.level;
                gameState.linesCleared += linesClearedThisTurn;
                updateScore();
            }

            // Increase level after every 10 lines cleared (example)
            if (gameState.linesCleared >= gameState.level * 10) {
                gameState.level++;
                gameState.dropInterval = Math.max(0.1, gameState.dropInterval * 0.85); // Make it drop faster
            }
        }

        function updateTetris(deltaTime) {
            if (gameState.isGameOver) return;

            gameState.dropCounter += deltaTime;
            if (gameState.dropCounter >= gameState.dropInterval) {
                gameState.dropCounter = 0;
                dropPiece();
            }

            const currentTime = performance.now();
            const moveDelay = 100; // Milliseconds between horizontal moves on hold

            if (keysPressed.has('arrowdown') || keysPressed.has('s')) {
                gameState.dropCounter += deltaTime * 5; // Soft drop faster
            }
            
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) {
                if (currentTime - gameState.lastMoveTime > moveDelay) {
                    if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX - 1, gameState.pieceY)) {
                        gameState.pieceX--;
                        gameState.lastMoveTime = currentTime;
                    }
                }
            } else if (keysPressed.has('arrowright') || keysPressed.has('d')) {
                if (currentTime - gameState.lastMoveTime > moveDelay) {
                    if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX + 1, gameState.pieceY)) {
                        gameState.pieceX++;
                        gameState.lastMoveTime = currentTime;
                    }
                }
            } else {
                gameState.lastMoveTime = 0; // Reset last move time when no horizontal key is pressed
            }
        }

        function dropPiece() {
            if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY + 1)) {
                gameState.pieceY++;
            } else {
                lockPiece();
            }
        }

        function drawTetris() {
            if (!ctx) return;
            // Draw the fixed blocks on the board
            for (let y = 0; y < TETRIS_ROWS; y++) {
                for (let x = 0; x < TETRIS_COLS; x++) {
                    if (gameState.board[y][x] !== 0) {
                        ctx.fillStyle = gameState.board[y][x];
                        ctx.fillRect(x * window.TETRIS_BLOCK_SIZE, y * window.TETRIS_BLOCK_SIZE, window.TETRIS_BLOCK_SIZE - 1, window.TETRIS_BLOCK_SIZE - 1);
                        ctx.strokeStyle = '#000'; // Block borders
                        ctx.strokeRect(x * window.TETRIS_BLOCK_SIZE, y * window.TETRIS_BLOCK_SIZE, window.TETRIS_BLOCK_SIZE - 1, window.TETRIS_BLOCK_SIZE - 1);
                    }
                }
            }

            // Draw the current falling piece
            if (gameState.currentPiece) {
                ctx.fillStyle = gameState.currentPieceColor;
                for (let y = 0; y < gameState.currentPiece.length; y++) {
                    for (let x = 0; x < gameState.currentPiece[y].length; x++) {
                        if (gameState.currentPiece[y][x] !== 0) {
                            ctx.fillRect((gameState.pieceX + x) * window.TETRIS_BLOCK_SIZE, (gameState.pieceY + y) * window.TETRIS_BLOCK_SIZE, window.TETRIS_BLOCK_SIZE - 1, window.TETRIS_BLOCK_SIZE - 1);
                            ctx.strokeStyle = '#000'; // Block borders
                            ctx.strokeRect((gameState.pieceX + x) * window.TETRIS_BLOCK_SIZE, (gameState.pieceY + y) * window.TETRIS_BLOCK_SIZE, window.TETRIS_BLOCK_SIZE - 1, window.TETRIS_BLOCK_SIZE - 1);
                        }
                    }
                }
            }

            // Draw grid lines for visual clarity
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 * (window.TETRIS_BLOCK_SIZE / 20); // Scale line width
            for (let i = 0; i <= TETRIS_COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * window.TETRIS_BLOCK_SIZE, 0);
                ctx.lineTo(i * window.TETRIS_BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= TETRIS_ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * window.TETRIS_BLOCK_SIZE);
                ctx.lineTo(canvas.width, i * window.TETRIS_BLOCK_SIZE);
                ctx.stroke();
            }

            // Display Level and Lines Cleared (optional, for Tetris specific)
            ctx.fillStyle = '#00ff41';
            ctx.font = `${16 * (window.TETRIS_BLOCK_SIZE / 20)}px "Courier New", monospace`; // Scaled font size
            ctx.textAlign = 'left';
            ctx.fillText(`Level: ${gameState.level}`, 5 * (window.TETRIS_BLOCK_SIZE / 20), 20 * (window.TETRIS_BLOCK_SIZE / 20));
            ctx.fillText(`Lines: ${gameState.linesCleared}`, 5 * (window.TETRIS_BLOCK_SIZE / 20), 40 * (window.TETRIS_BLOCK_SIZE / 20));
        }
        // --- End Tetris Game ---

        // --- Minesweeper Game ---
        // MINE_CELL_SIZE will be dynamically calculated in resizeCanvas
        // Define original rows/cols for scaling reference
        const MINESWEEPER_DEFAULT_ROWS = 16;
        const MINESWEEPER_DEFAULT_COLS = 16;
        const MINESWEEPER_DEFAULT_MINES = 40;
        const MINESWEEPER_ORIGINAL_CELL_SIZE = 30;

        function initMinesweeper() {
            gameState = {
                rows: MINESWEEPER_DEFAULT_ROWS,
                cols: MINESWEEPER_DEFAULT_COLS,
                mines: MINESWEEPER_DEFAULT_MINES,
                board: [],
                revealed: [],
                flagged: [],
                gameOver: false,
                gameWon: false,
                startTime: 0,
                timer: 0,
                minesRemaining: 0
            };
            
            // Re-calculate MINE_CELL_SIZE based on current canvas width, ensuring it's set for new game
            window.MINE_CELL_SIZE = Math.floor(canvas.width / gameState.cols);

            // Initialize board, revealed, and flagged arrays
            for (let r = 0; r < gameState.rows; r++) {
                gameState.board.push(Array(gameState.cols).fill(0));
                gameState.revealed.push(Array(gameState.cols).fill(false));
                gameState.flagged.push(Array(gameState.cols).fill(false));
            }

            placeMines();
            calculateMineCounts();

            gameState.minesRemaining = gameState.mines;
            document.getElementById('mineCountDisplay').textContent = `Mines: ${gameState.minesRemaining}`;
            document.getElementById('timerDisplay').textContent = `Time: 0s`;

            // Add event listeners specific to Minesweeper
            canvas.addEventListener('click', handleMinesweeperClick);
            canvas.addEventListener('contextmenu', handleMinesweeperRightClick); // For right-click to flag

            gameState.startTime = Date.now(); // Start timer
            gameState.timer = 0;
        }

        function placeMines() {
            let minesPlaced = 0;
            while (minesPlaced < gameState.mines) {
                const r = Math.floor(Math.random() * gameState.rows);
                const c = Math.floor(Math.random() * gameState.cols);
                if (gameState.board[r][c] !== -1) { // If no mine is already there
                    gameState.board[r][c] = -1; // Place a mine
                    minesPlaced++;
                }
            }
        }

        function calculateMineCounts() {
            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] === -1) continue; // Skip if it's a mine

                    let count = 0;
                    // Check all 8 surrounding cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue; // Skip the cell itself

                            const nr = r + dr;
                            const nc = c + dc;

                            // Check bounds and if the neighbor is a mine
                            if (
                                nr >= 0 && nr < gameState.rows &&
                                nc >= 0 && nc < gameState.cols &&
                                gameState.board[nr][nc] === -1
                            ) {
                                count++;
                            }
                        }
                    }
                    gameState.board[r][c] = count;
                }
            }
        }

        function handleMinesweeperClick(event) {
            if (gameState.gameOver || gameState.gameWon || !canvas || document.getElementById('messageBox').style.display === 'block') return;

            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to internal canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            const c = Math.floor(x / window.MINE_CELL_SIZE);
            const r = Math.floor(y / window.MINE_CELL_SIZE);

            // Basic bounds check
            if (r < 0 || r >= gameState.rows || c < 0 || c >= gameState.cols) {
                return;
            }

            // Left click (reveal)
            if (event.button === 0) { // 0 for left click
                if (!gameState.revealed[r][c] && !gameState.flagged[r][c]) {
                    revealCell(r, c);
                }
            }
            checkMinesweeperWin();
        }

        function handleMinesweeperRightClick(event) {
            event.preventDefault(); // Prevent context menu from appearing
            if (gameState.gameOver || gameState.gameWon || !canvas || document.getElementById('messageBox').style.display === 'block') return;

            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to internal canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            const c = Math.floor(x / window.MINE_CELL_SIZE);
            const r = Math.floor(y / window.MINE_CELL_SIZE);

            // Basic bounds check
            if (r < 0 || r >= gameState.rows || c < 0 || c >= gameState.cols) {
                return;
            }

            // Right click (flag)
            if (!gameState.revealed[r][c]) { // Can only flag unrevealed cells
                gameState.flagged[r][c] = !gameState.flagged[r][c]; // Toggle flag
                gameState.minesRemaining += (gameState.flagged[r][c] ? -1 : 1); // Update mine count
                document.getElementById('mineCountDisplay').textContent = `Mines: ${gameState.minesRemaining}`;
            }
            checkMinesweeperWin();
        }


        // Recursive function to reveal cells
        function revealCell(r, c) {
            // Base cases for recursion: out of bounds, already revealed, or flagged
            if (r < 0 || r >= gameState.rows || c < 0 || c >= gameState.cols ||
                gameState.revealed[r][c] || gameState.flagged[r][c]) {
                return;
            }

            gameState.revealed[r][c] = true; // Mark as revealed

            if (gameState.board[r][c] === -1) {
                // Hit a mine! Game Over
                gameState.gameOver = true;
                gameOver('lost'); // Call the general gameOver function
                revealAllMines(); // Show all mines
                return;
            }

            if (gameState.board[r][c] === 0) {
                // If it's an empty cell (0 mines around), recursively reveal neighbors
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        revealCell(r + dr, c + dc);
                    }
                }
            }
            // If it's a numbered cell, just reveal it (recursion stops here)
        }

        function revealAllMines() {
            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] === -1) {
                        gameState.revealed[r][c] = true; // Show all mines
                        gameState.flagged[r][c] = false; // Unflag any incorrectly flagged mines for display
                    }
                }
            }
        }

        function checkMinesweeperWin() {
            let nonMineCellsRevealed = 0;
            let totalNonMineCells = (gameState.rows * gameState.cols) - gameState.mines;

            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] !== -1 && gameState.revealed[r][c]) {
                        nonMineCellsRevealed++;
                    }
                }
            }

            if (nonMineCellsRevealed === totalNonMineCells && !gameState.gameOver) {
                gameState.gameWon = true;
                gameOver('won'); // Call general gameOver function with 'won' status
                revealAllMines(); // For aesthetics, show all mines when won (they should be flagged)
            }
        }

        function updateMinesweeper(deltaTime) {
            if (!gameState.gameOver && !gameState.gameWon) {
                gameState.timer = Math.floor((Date.now() - gameState.startTime) / 1000);
                document.getElementById('timerDisplay').textContent = `Time: ${gameState.timer}s`;
            }
        }

        function drawMinesweeper() {
            if (!ctx) return;
            const currentCellSize = window.MINE_CELL_SIZE;
            const scaleFactor = currentCellSize / MINESWEEPER_ORIGINAL_CELL_SIZE;

            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    const x = c * currentCellSize;
                    const y = r * currentCellSize;

                    // Draw cell background
                    if (gameState.revealed[r][c]) {
                        ctx.fillStyle = '#333'; // Darker for revealed cells
                        ctx.fillRect(x, y, currentCellSize, currentCellSize);
                        if (gameState.board[r][c] === -1) {
                            // Draw mine (black circle with white cross)
                            ctx.fillStyle = '#ff0041'; // Red for mine
                            ctx.beginPath();
                            ctx.arc(x + currentCellSize / 2, y + currentCellSize / 2, currentCellSize / 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2 * scaleFactor; // Scaled line width
                            ctx.beginPath();
                            ctx.moveTo(x + currentCellSize / 2, y + currentCellSize / 4);
                            ctx.lineTo(x + currentCellSize / 2, y + currentCellSize * 3 / 4);
                            ctx.moveTo(x + currentCellSize / 4, y + currentCellSize / 2);
                            ctx.lineTo(x + currentCellSize * 3 / 4, y + currentCellSize / 2);
                            ctx.stroke();
                        } else if (gameState.board[r][c] > 0) {
                            // Draw number of adjacent mines
                            const num = gameState.board[r][c];
                            const colors = ['#0000ff', '#008000', '#ff0000', '#000080', '#800000', '#008080', '#000', '#808080']; // Colors for numbers 1-8
                            ctx.fillStyle = colors[num - 1]; // Get color based on number
                            ctx.font = `${currentCellSize * 0.7}px 'Courier New', monospace`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(num.toString(), x + currentCellSize / 2, y + currentCellSize / 2);
                        }
                    } else {
                        // Draw unrevealed cell
                        ctx.fillStyle = '#666'; // Gray for unrevealed cells
                        ctx.fillRect(x, y, currentCellSize, currentCellSize);
                        if (gameState.flagged[r][c]) {
                            // Draw flag
                            ctx.fillStyle = '#ffff00'; // Yellow flag
                            ctx.beginPath();
                            ctx.moveTo(x + currentCellSize * 0.2, y + currentCellSize * 0.8);
                            ctx.lineTo(x + currentCellSize * 0.2, y + currentCellSize * 0.2);
                            ctx.lineTo(x + currentCellSize * 0.8, y + currentCellSize * 0.3);
                            ctx.lineTo(x + currentCellSize * 0.2, y + currentCellSize * 0.4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 2 * scaleFactor; // Scaled line width
                            ctx.stroke();
                        }
                    }
                    ctx.strokeStyle = '#000'; // Cell borders
                    ctx.lineWidth = 1 * scaleFactor; // Scaled line width
                    ctx.strokeRect(x, y, currentCellSize, currentCellSize);
                }
            }
        }
        // --- End Minesweeper Game ---

        // --- Galactic Invaders Game ---
        // Original constants for scaling reference
        const GI_ORIGINAL_PLAYER_WIDTH = 40;
        const GI_ORIGINAL_PLAYER_HEIGHT = 20;
        const GI_ORIGINAL_PLAYER_Y_OFFSET = 50; // Distance from bottom
        const GI_ORIGINAL_PLAYER_BULLET_RADIUS = 3;
        const GI_ORIGINAL_ENEMY_WIDTH = 30;
        const GI_ORIGINAL_ENEMY_HEIGHT = 20;
        const GI_ORIGINAL_ENEMY_BULLET_RADIUS = 3;
        const GI_ORIGINAL_ENEMY_ADVANCE_Y = 20; // Original vertical drop when changing direction
        const GI_ORIGINAL_OFFSET_Y = 50; // Original vertical offset of enemy group from top
        const GI_ORIGINAL_HORIZONTAL_SPACING = 15;
        const GI_ORIGINAL_VERTICAL_SPACING = 20;

        // Speeds remain constant relative to screen size (pixels per second)
        const PLAYER_SPEED = 200; 
        const PLAYER_BULLET_SPEED = 600; 
        const PLAYER_SHOOT_COOLDOWN = 0.5;

        const ENEMY_NORMAL_SPEED_X = 50; 
        const ENEMY_NORMAL_SPEED_Y = 20; 
        const ENEMY_DIVE_SPEED = 200; 
        const ENEMY_BULLET_SPEED = 150;
        const ENEMY_BASE_SHOULD_SHOOT_CHANCE = 0.0005; 
        const ENEMY_BASE_RAM_CHANCE = 0.00005;

        function initGalacticInvaders() {
            // No direct canvas width/height assignment here, handled by resizeCanvas
            const scaleFactorX = canvas.width / 600;
            const scaleFactorY = canvas.height / 700;

            gameState = {
                player: {
                    x: canvas.width / 2,
                    y: canvas.height - (GI_ORIGINAL_PLAYER_Y_OFFSET * scaleFactorY), // Scaled
                    width: GI_ORIGINAL_PLAYER_WIDTH * scaleFactorX, // Scaled
                    height: GI_ORIGINAL_PLAYER_HEIGHT * scaleFactorY, // Scaled
                    lastShotTime: 0,
                    canShoot: true,
                    isDestroyed: false,
                    isInvincible: false,
                    invincibilityTimer: 0,
                    invincibilityDuration: 2,
                    blinkInterval: 0.1
                },
                playerBullets: [],
                enemies: [],
                enemyBullets: [],
                score: 0,
                lives: 3,
                wave: 1,
                enemyDirection: 1,
                enemyAdvanceTimer: 0,
                enemyAdvanceInterval: 2,
                waveOscillationAmplitude: 5 * scaleFactorY, // Scaled
                waveOscillationFrequency: 5,
                currentEnemyShootChance: ENEMY_BASE_SHOULD_SHOOT_CHANCE,
                currentEnemyRamChance: ENEMY_BASE_RAM_CHANCE,
                explosions: [],
                explosionDuration: 0.5
            };
            
            spawnEnemyWave();
            updateGalacticInvadersScoreAndLives(); // Initialize UI
        }

        // Draw Player Ship (more detailed, Galaga-inspired)
        function drawPlayerShip(player) {
            const currentTimeSeconds = performance.now() / 1000;
            if (player.isInvincible && Math.floor(currentTimeSeconds / player.blinkInterval) % 2 === 0) {
                return; // Don't draw if blinking during invincibility
            }

            const scaleX = player.width / GI_ORIGINAL_PLAYER_WIDTH;
            const scaleY = player.height / GI_ORIGINAL_PLAYER_HEIGHT;

            const basePlayerX = player.x;
            const basePlayerY = player.y;

            ctx.save(); // Save the current canvas state
            ctx.translate(basePlayerX, basePlayerY); // Move origin to ship's center for drawing

            // Main Body (triangle pointing up, with a wider base)
            ctx.fillStyle = '#00ff41'; // Green for the main body
            ctx.strokeStyle = '#00aa00'; // Darker green outline
            ctx.lineWidth = 2 * Math.min(scaleX, scaleY);
            ctx.beginPath();
            ctx.moveTo(0, -10 * scaleY); // Top point
            ctx.lineTo(-20 * scaleX, 10 * scaleY); // Bottom-left
            ctx.lineTo(20 * scaleX, 10 * scaleY); // Bottom-right
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Cockpit (small rectangle on top of the main body)
            ctx.fillStyle = '#00ffff'; // Cyan for cockpit
            ctx.strokeStyle = '#00aaaa';
            ctx.beginPath();
            ctx.rect(-5 * scaleX, -10 * scaleY, 10 * scaleX, 5 * scaleY);
            ctx.fill();
            ctx.stroke();

            // Left Wing
            ctx.fillStyle = '#ff0041'; // Red for wings
            ctx.strokeStyle = '#aa0022';
            ctx.beginPath();
            ctx.moveTo(-20 * scaleX, 10 * scaleY); // Connects to main body
            ctx.lineTo(-30 * scaleX, 5 * scaleY);
            ctx.lineTo(-30 * scaleX, 15 * scaleY);
            ctx.lineTo(-20 * scaleX, 15 * scaleY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Right Wing
            ctx.fillStyle = '#ff0041'; // Red for wings
            ctx.strokeStyle = '#aa0022';
            ctx.beginPath();
            ctx.moveTo(20 * scaleX, 10 * scaleY); // Connects to main body
            ctx.lineTo(30 * scaleX, 5 * scaleY);
            ctx.lineTo(30 * scaleX, 15 * scaleY);
            ctx.lineTo(20 * scaleX, 15 * scaleY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Thrusters (small rectangles at the very bottom)
            ctx.fillStyle = '#ffa500'; // Orange for thruster glow
            ctx.beginPath();
            ctx.rect(-15 * scaleX, 10 * scaleY, 10 * scaleX, 5 * scaleY);
            ctx.rect(5 * scaleX, 10 * scaleY, 10 * scaleX, 5 * scaleY);
            ctx.fill();
            ctx.strokeStyle = '#cc8800';
            ctx.strokeRect(-15 * scaleX, 10 * scaleY, 10 * scaleX, 5 * scaleY);
            ctx.strokeRect(5 * scaleX, 10 * scaleY, 10 * scaleX, 5 * scaleY);

            ctx.restore(); // Restore the canvas state
        }


        // Draw Enemy Ship (more detailed)
        function drawEnemyShip(enemy) {
            const scaleX = canvas.width / 600;
            const scaleY = canvas.height / 700;

            ctx.fillStyle = enemy.color;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1 * Math.min(scaleX, scaleY);

            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y, enemy.width / 2, enemy.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(enemy.x - enemy.width / 2, enemy.y);
            ctx.lineTo(enemy.x - enemy.width / 2 - (5 * scaleX), enemy.y + enemy.height / 3);
            ctx.lineTo(enemy.x - enemy.width / 2, enemy.y + enemy.height / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(enemy.x + enemy.width / 2, enemy.y);
            ctx.lineTo(enemy.x + enemy.width / 2 + (5 * scaleX), enemy.y + enemy.height / 3);
            ctx.lineTo(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y - enemy.height / 4, 3 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#eee';
            ctx.beginPath();
            ctx.moveTo(enemy.x - enemy.width / 4, enemy.y - enemy.height / 2);
            ctx.lineTo(enemy.x - enemy.width / 4 - (5 * scaleX), enemy.y - enemy.height / 2 - (5 * scaleY));
            ctx.moveTo(enemy.x + enemy.width / 4, enemy.y - enemy.height / 2);
            ctx.lineTo(enemy.x + enemy.width / 4 + (5 * scaleX), enemy.y - enemy.height / 2 - (5 * scaleY));
            ctx.stroke();
        }

        // New function to draw an explosion
        function drawExplosion(explosion, totalDuration) {
            if (!ctx) return;
            const progress = 1 - (explosion.timer / totalDuration);
            const maxRadius = 30 * (canvas.width / 600); // Scaled max radius
            const currentRadius = maxRadius * progress;
            const alpha = 1 - progress;

            ctx.save();
            ctx.globalAlpha = alpha;

            ctx.fillStyle = `rgba(255, ${Math.floor(165 * (1 - progress))}, 0, ${alpha})`;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = `rgba(255, 255, ${Math.floor(100 * (1 - progress))}, ${alpha * 0.8})`;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, currentRadius * 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }


        function spawnEnemyWave() {
            gameState.enemies = [];
            const baseEnemyRows = 3; 
            const maxEnemyRows = 7; 
            const baseEnemiesPerRow = 6; 
            
            const enemyRows = Math.min(baseEnemyRows + Math.floor((gameState.wave - 1) / 2), maxEnemyRows); 
            const enemiesPerRow = Math.min(baseEnemiesPerRow + Math.floor((gameState.wave - 1) * 0.75), 10);

            const scaleFactorX = canvas.width / 600;
            const scaleFactorY = canvas.height / 700;

            const enemyWidth = GI_ORIGINAL_ENEMY_WIDTH * scaleFactorX;
            const enemyHeight = GI_ORIGINAL_ENEMY_HEIGHT * scaleFactorY;
            const horizontalSpacing = GI_ORIGINAL_HORIZONTAL_SPACING * scaleFactorX;
            const verticalSpacing = GI_ORIGINAL_VERTICAL_SPACING * scaleFactorY;

            const totalGroupWidth = enemiesPerRow * enemyWidth + (enemiesPerRow - 1) * horizontalSpacing;
            const startX = (canvas.width - totalGroupWidth) / 2;
            const offsetY = GI_ORIGINAL_OFFSET_Y * scaleFactorY;

            gameState.currentEnemyShootChance = ENEMY_BASE_SHOULD_SHOOT_CHANCE * (1 + (gameState.wave - 1) * 0.1); 
            gameState.currentEnemyRamChance = ENEMY_BASE_RAM_CHANCE * (1 + (gameState.wave - 1) * 0.5); 

            for (let r = 0; r < enemyRows; r++) { 
                for (let c = 0; c < enemiesPerRow; c++) {
                    gameState.enemies.push({
                        x: startX + c * (enemyWidth + horizontalSpacing) + (Math.random() * 10 - 5) * scaleFactorX,
                        y: offsetY + r * (enemyHeight + verticalSpacing) + (Math.random() * 10 - 5) * scaleFactorY,
                        initialY: offsetY + r * (enemyHeight + verticalSpacing),
                        width: enemyWidth,
                        height: enemyHeight,
                        color: `hsl(${Math.random() * 360}, 80%, 70%)`, 
                        isDiving: false,
                        diveTargetX: 0 
                    });
                }
            }
        }

        function firePlayerBullet() {
            const currentTime = performance.now() / 1000;
            if (currentTime - gameState.player.lastShotTime > PLAYER_SHOOT_COOLDOWN) {
                const scaleFactor = canvas.width / 600;
                gameState.playerBullets.push({
                    x: gameState.player.x,
                    y: gameState.player.y - gameState.player.height / 2,
                    radius: GI_ORIGINAL_PLAYER_BULLET_RADIUS * scaleFactor,
                    vy: -PLAYER_BULLET_SPEED * (canvas.height / 700) // Scale bullet speed by Y
                });
                gameState.player.lastShotTime = currentTime;
            }
        }

        function updateGalacticInvaders(deltaTime) {
            const currentTimeSeconds = performance.now() / 1000;
            const scaleFactorX = canvas.width / 600;
            const scaleFactorY = canvas.height / 700;


            if (gameState.player.isInvincible) {
                gameState.player.invincibilityTimer -= deltaTime;
                if (gameState.player.invincibilityTimer <= 0) {
                    gameState.player.isInvincible = false;
                }
            }

            // Player movement scaled by current canvas width
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) {
                gameState.player.x -= PLAYER_SPEED * scaleFactorX * deltaTime;
            }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) {
                gameState.player.x += PLAYER_SPEED * scaleFactorX * deltaTime;
            }
            // Clamp player position
            gameState.player.x = Math.max(gameState.player.width / 2, Math.min(canvas.width - gameState.player.width / 2, gameState.player.x));

            // Player bullets update
            gameState.playerBullets = gameState.playerBullets.filter(bullet => {
                bullet.y += bullet.vy * deltaTime;
                return bullet.y > 0;
            });

            // Enemy movement and shooting/diving
            gameState.enemyAdvanceTimer += deltaTime;
            let advanceDown = false;
            let hitWallThisFrame = false;

            if (gameState.enemyAdvanceTimer >= gameState.enemyAdvanceInterval) {
                gameState.enemyAdvanceTimer = 0;
                for (const enemy of gameState.enemies) {
                    // Adjust margin from wall for check based on scaling
                    const wallMargin = 10 * scaleFactorX;
                    if (!enemy.isDiving && ((gameState.enemyDirection === 1 && enemy.x + enemy.width / 2 >= canvas.width - wallMargin) ||
                                            (gameState.enemyDirection === -1 && enemy.x - enemy.width / 2 <= wallMargin))) {
                        hitWallThisFrame = true;
                        break;
                    }
                }

                if (hitWallThisFrame) {
                    gameState.enemyDirection *= -1;
                    advanceDown = true;
                }
            }

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];

                if (enemy.isDiving) {
                    enemy.y += ENEMY_DIVE_SPEED * scaleFactorY * deltaTime; // Scale dive speed by Y
                    const dx = enemy.diveTargetX - enemy.x;
                    if (Math.abs(dx) > 5 * scaleFactorX) { // Scale closeness threshold
                        enemy.x += Math.sign(dx) * ENEMY_DIVE_SPEED * 0.5 * scaleFactorX * deltaTime; // Horizontal chase during dive, scaled
                    }
                    
                    if (enemy.y - enemy.height / 2 > canvas.height) {
                        enemy.y = -enemy.height / 2;
                        enemy.x = gameState.player.x;
                        enemy.diveTargetX = gameState.player.x;
                    }
                } else {
                    enemy.x += gameState.enemyDirection * ENEMY_NORMAL_SPEED_X * scaleFactorX * deltaTime; // Scaled normal X speed
                    if (advanceDown) {
                        enemy.initialY += ENEMY_NORMAL_SPEED_Y * scaleFactorY; // Scaled vertical drop
                    }
                    enemy.y = enemy.initialY + Math.sin(currentTimeSeconds * gameState.waveOscillationFrequency + enemy.x / (50 * scaleFactorX)) * gameState.waveOscillationAmplitude;

                    if (Math.random() < gameState.currentEnemyRamChance) {
                        enemy.isDiving = true;
                        enemy.diveTargetX = gameState.player.x;
                    } else if (Math.random() < gameState.currentEnemyShootChance) {
                        gameState.enemyBullets.push({
                            x: enemy.x,
                            y: enemy.y + enemy.height / 2,
                            radius: GI_ORIGINAL_ENEMY_BULLET_RADIUS * scaleFactorX, // Scaled
                            vy: ENEMY_BULLET_SPEED * scaleFactorY // Scaled
                        });
                    }

                    if (enemy.y + enemy.height / 2 >= canvas.height - gameState.player.height * 2) {
                        gameOver();
                        return;
                    }
                }
            }


            // Enemy bullets update
            gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                bullet.y += bullet.vy * deltaTime;
                return bullet.y < canvas.height;
            });

            // Collision detection (Player Bullets vs Enemies)
            for (let i = gameState.playerBullets.length - 1; i >= 0; i--) {
                const pBullet = gameState.playerBullets[i];
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const closestX = Math.max(enemy.x - enemy.width / 2, Math.min(pBullet.x, enemy.x + enemy.width / 2));
                    const closestY = Math.max(enemy.y - enemy.height / 2, Math.min(pBullet.y, enemy.y + pBullet.radius)); 
                    const dx = pBullet.x - closestX;
                    const dy = pBullet.y - closestY;
                    const distanceSq = (dx * dx) + (dy * dy);

                    if (distanceSq < (pBullet.radius * pBullet.radius)) { 
                        gameState.playerBullets.splice(i, 1);
                        gameState.enemies.splice(j, 1);
                        gameState.score += 100;
                        updateGalacticInvadersScoreAndLives();
                        break; 
                    }
                }
            }

            // Collision detection (Enemy Bullets/Enemies vs Player)
            if (!gameState.player.isInvincible && !gameState.player.isDestroyed) {
                for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                    const eBullet = gameState.enemyBullets[i];
                    const dx = gameState.player.x - eBullet.x;
                    const dy = gameState.player.y - eBullet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    const playerApproxRadius = Math.max(gameState.player.width, gameState.player.height) / 2;
                    const eBulletHitRadius = playerApproxRadius + eBullet.radius;
                    if (distance < eBulletHitRadius) { 
                        gameState.enemyBullets.splice(i, 1);
                        handlePlayerHit();
                        return;
                    }
                }
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    if (enemy.isDiving) { 
                        const dx = gameState.player.x - enemy.x;
                        const dy = gameState.player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        const playerApproxRadius = Math.max(gameState.player.width, gameState.player.height) / 2;
                        const enemyApproxRadius = Math.max(enemy.width, enemy.height) / 2;

                        if (distance < playerApproxRadius + enemyApproxRadius) {
                            gameState.enemies.splice(i, 1);
                            handlePlayerHit();
                            return;
                        }
                    }
                }
            }

            // Update explosions
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                explosion.timer -= deltaTime;
                if (explosion.timer <= 0) {
                    gameState.explosions.splice(i, 1);
                }
            }

            // Check if all enemies are defeated for next wave
            if (gameState.enemies.length === 0) {
                gameState.wave++;
                spawnEnemyWave();
            }
        }

        // New function to handle player getting hit
        function handlePlayerHit() {
            gameState.lives--;
            updateGalacticInvadersScoreAndLives();

            if (gameState.lives <= 0) {
                gameState.player.isDestroyed = true;
                gameState.explosions.push({ x: gameState.player.x, y: gameState.player.y, timer: gameState.explosionDuration });
                gameOver();
            } else {
                gameState.player.isDestroyed = true;
                gameState.explosions.push({ x: gameState.player.x, y: gameState.player.y, timer: gameState.explosionDuration });
                
                setTimeout(() => {
                    gameState.player.isDestroyed = false;
                    gameState.player.x = canvas.width / 2;
                    gameState.player.y = canvas.height - (GI_ORIGINAL_PLAYER_Y_OFFSET * (canvas.height / 700)); // Respawn position scaled
                    gameState.player.isInvincible = true;
                    gameState.player.invincibilityTimer = gameState.player.invincibilityDuration;
                }, gameState.explosionDuration * 1000);
            }
        }

        function drawGalacticInvaders() {
            if (!gameState.player.isDestroyed) {
                drawPlayerShip(gameState.player);
            }
            
            gameState.explosions.forEach(explosion => drawExplosion(explosion, gameState.explosionDuration));

            ctx.fillStyle = '#00ffff';
            gameState.playerBullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            gameState.enemies.forEach(enemy => {
                drawEnemyShip(enemy);
            });

            ctx.fillStyle = '#ff0041';
            gameState.enemyBullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function updateGalacticInvadersScoreAndLives() {
            document.getElementById('galacticScoreDisplay').textContent = `Score: ${gameState.score}`;
            document.getElementById('galacticLivesDisplay').textContent = `Lives: ${gameState.lives}`;
            document.getElementById('galacticWaveDisplay').textContent = `Wave: ${gameState.wave}`;
        }
        // --- End Galactic Invaders Game ---


        // Initial setup on window load
        window.addEventListener('load', () => {
            createStars();
            // Need to get canvas element here before calling resizeCanvas for the first time
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            document.getElementById('gameSelection').style.display = 'grid'; // Show game selection menu initially
            document.getElementById('gameArea').style.display = 'none'; // Hide game area initially
            document.getElementById('gameOverOverlay').classList.remove('active'); // Hide game over overlay
            document.getElementById('messageBox').style.display = 'none'; // Hide message box
            document.getElementById('mainHeader').style.display = 'block'; // Ensure header is shown on initial load
            document.getElementById('gameTitle').style.display = 'none'; 
            updateScore(); // Initial update for score display (will show Score: 0)
        });

        // Re-create stars and resize canvas on window resize to ensure full coverage and responsiveness
        window.addEventListener('resize', () => {
            createStars();
            // Call resizeCanvas only if a game is currently selected, to avoid errors before game initialization
            if (currentGame) {
                resizeCanvas();
            }
        });
    </script>
</body>
</html>
