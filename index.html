<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroArcade - Play Games Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            color: #00ff41;
            min-height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        .container {
            position: relative;
            z-index: 2;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff41;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            width: 100%;
            max-width: 650px;
        }
        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff41;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px #00ff41; }
            to { text-shadow: 0 0 20px #00ff41, 0 0 30px #00ff41; }
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
            width: 100%;
        }
        .game-card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .game-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 65, 0.1), transparent);
            transform: rotate(45deg) translateX(-100%) translateY(-100%); /* Start off-screen */
            opacity: 0;
            transition: none; /* Animation will control the visual properties */
        }
        @keyframes shine {
            0% { transform: rotate(45deg) translateX(-100%) translateY(-100%); opacity: 0; }
            1% { opacity: 1; } /* Make it visible at the start of the sweep */
            99% { opacity: 1; } /* Keep it visible during the sweep */
            100% { transform: rotate(45deg) translateX(100%) translateY(100%); opacity: 0; } /* End off-screen and fade out */
        }
        .game-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 30px rgba(0, 255, 65, 0.4);
            border-color: #00ffff;
        }
        .game-card:hover::before {
            animation: shine 1.5s linear infinite; /* Play animation continuously while hovered */
        }
        .game-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #00ffff;
        }
        .game-description {
            margin-bottom: 20px;
            opacity: 0.9;
            line-height: 1.4;
        }
        .play-btn {
            background: linear-gradient(45deg, #00ff41, #00ffff);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: #000;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.5);
        }
        .game-area {
            display: none;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            width: 100%;
            max-width: 650px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.1); 
        }
        .game-canvas {
            border: 2px solid #00ffff;
            border-radius: 10px;
            background: #000;
            margin: 20px auto;
            display: block;
        }

        .game-controls {
            margin: 20px 0;
            text-align: center;
            color: #00ff41;
        }
        .control-btn {
            background: #00ff41;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .control-btn:hover {
            background: #00ffff;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.5);
        }

        .score {
            font-size: 1.3rem;
            margin: 10px 0;
            color: #00ffff;
        }
        /* Minesweeper specific controls for flags/timer */
        #minesweeperInfo {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
            color: #00ffff;
            font-size: 1.1rem;
            margin-left: auto;
            margin-right: auto;
        }
        /* Pong Difficulty Selection */
        #pongDifficultySelection {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            margin: 20px auto;
            text-align: center;
            max-width: 400px;
            width: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #pongDifficultySelection h3 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #00ff41;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }
        #pongDifficultySelection label {
            font-size: 1.2rem;
            margin: 10px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            color: #00ffff;
        }
        #pongDifficultySelection input[type="radio"] {
            margin-right: 10px;
            transform: scale(1.5);
            accent-color: #00ff41;
            cursor: pointer;
        }
        #pongDifficultySelection button {
            margin-top: 25px;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
        }


        .action-buttons {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        .back-btn {
            background: #ff4444;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        .back-btn:hover {
            background: #ff6666;
        }
        
        /* Game Over Overlay Styles */
        .game-over-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            z-index: 100;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #00ff41;
            text-align: center;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(5px);
        }
        .game-over-overlay.active {
            display: flex;
        }
        .game-over-content {
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff0041;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 0 30px rgba(255, 0, 65, 0.6);
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .game-over-content h2 {
            font-size: 3rem;
            color: #ff0041;
            text-shadow: 0 0 15px #ff0041;
            margin-bottom: 20px;
            animation: heartbeat 1.5s infinite;
        }
        @keyframes heartbeat {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .game-over-content p {
            font-size: 1.8rem;
            margin-bottom: 10px; /* Reduced margin to make space for high score */
            color: #00ffff;
        }
        .game-over-buttons button {
            background: linear-gradient(45deg, #00ff41, #00ffff);
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            color: #000;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .game-over-buttons button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        }

        /* Message Box Style */
        .message-box {
            background: rgba(0, 0, 0, 1);
            border: 2px solid #ffeb3b;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
            font-size: 1.1rem;
            color: #ffeb3b;
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.5);
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            max-width: 80%;
        }

        /* Galactic Invaders Specific Styles */
        .galactic-invaders-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            /* min-width: 400px; */ /* Removed max-width to allow more space for wave counter */
            margin-top: 10px;
            color: #00ff41;
            font-size: 1.1rem;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>

    <div class="container">
        <header id="mainHeader">
            <h1>🎮 RETROARCADE 🎮</h1>
            <p class="subtitle">Classic Games Reimagined for the Web</p>
        </header>

        <div id="gameSelection" class="games-grid">
            <div class="game-card" onclick="startGame('dino')">
                <h3 class="game-title">🦖 Prehistoric Run</h3>
                <p class="game-description">Leap over cacti and dodge pterodactyls in this endless runner classic. How long can you survive the ancient world? Press SPACE to jump!</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('snake')">
                <h3 class="game-title">🐍 Neon Snake</h3>
                <p class="game-description">Guide the glowing serpent through the digital void. Collect energy orbs to grow longer, but don't crash into yourself! Use WASD or Arrow Keys.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('pong')">
                <h3 class="game-title">⚡ Cyber Pong</h3>
                <p class="game-description">The classic paddle game with a futuristic twist. Can you beat the AI opponent in this high-speed digital duel? Use W/S or ↑/↓ arrows.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('asteroids')">
                <h3 class="game-title">💫 Space Rocks</h3>
                <p class="game-description">Navigate your ship through a dangerous asteroid field. Blast the rocks to survive and rack up points! Use WASD to move, SPACE to shoot.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('breakout')">
                <h3 class="game-title">🧱 Block Destroyer</h3>
                <p class="game-description">Break through the neon barrier with your energy ball. Clear all blocks to advance to the next level! Use A/D or ←/→ arrows.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('tetris')">
                <h3 class="game-title">🟦 Pixel Tetris</h3>
                <p class="game-description">Arrange falling blocks to form complete lines and clear them. Don't let the stack reach the top! Use Arrow Keys or WASD to move and rotate.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('minesweeper')">
                <h3 class="game-title">💣 Hidden Grid</h3>
                <p class="game-description">Clear the minefield without detonating any hidden mines! Click to reveal a square; if a number appears, it tells you how many mines are adjacent. Right-click (or Ctrl+Click) to flag suspected mine locations. Reveal all non-mine squares to win!</p>
                <button class="play-btn">Play Now</button>
            </div>
            <!-- NEW GALAGA-LIKE GAME CARD -->
            <div class="game-card" onclick="startGame('galacticInvaders')">
                <h3 class="game-title">🚀 Galactic Invaders</h3>
                <p class="game-description">Defend your galaxy from waves of alien invaders! Move your ship left and right, and fire lasers to destroy them. Don't let them reach the bottom!</p>
                <button class="play-btn">Play Now</button>
            </div>
            <!-- END NEW GALAGA-LIKE GAME CARD -->
        </div>

        <div id="gameArea" class="game-area">
            <h2 id="gameTitle"></h2>
            <!-- Generic score display, hidden for Minesweeper/GalacticInvaders which have custom info bars -->
            <div class="score" id="scoreDisplay">Score: 0</div> 

            <!-- Minesweeper specific info display -->
            <div id="minesweeperInfo" style="display: none;">
                <span id="mineCountDisplay">Mines: 0</span>
                <span id="timerDisplay">Time: 0s</span>
            </div>

            <!-- Galactic Invaders specific info display -->
            <div id="galacticInvadersInfo" class="galactic-invaders-info" style="display: none;">
                <span id="galacticScoreDisplay">Score: 0</span>
                <span id="galacticLivesDisplay">Lives: 3</span>
                <span id="galacticWaveDisplay">Wave: 1</span>
            </div>

            <!-- Pong Difficulty Selection -->
            <div id="pongDifficultySelection">
                <h3>Choose Difficulty:</h3>
                <label>
                    <input type="radio" name="pongDifficulty" value="easy" checked> Easy
                </label>
                <label>
                    <input type="radio" name="pongDifficulty" value="hard"> Hard
                </label>
                <button class="play-btn" onclick="startSelectedPongDifficulty()">Start Cyber Pong</button>
            </div>
            <canvas id="gameCanvas" class="game-canvas" width="600" height="400"></canvas>
            <div class="game-controls" id="gameControls"></div>
            <div class="action-buttons">
                <button class="control-btn" id="restartGameButton" onclick="restartGame()" style="background: #ffaa00;">🔄 Restart Game</button>
                <button class="back-btn" id="backToMenuButton" onclick="backToMenu()">← Back to Games</button>
            </div>
        </div>
    </div>

    <!-- Message box for start instructions or in-game messages -->
    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageBoxOkBtn">OK</button>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay">
        <div class="game-over-content">
            <h2>GAME OVER!</h2>
            <p id="finalScoreDisplay">Final Score: 0</p>
            <!-- High score display removed -->
            <div class="game-over-buttons">
                <button onclick="restartGameFromGameOver()">Play Again</button>
                <button onclick="backToMenuFromGameOver()">Back to Menu</button>
            </div>
        </div>
    </div>

    <script>
        // Create animated stars background
        function createStars() {
            const starsContainer = document.getElementById('stars');
            starsContainer.innerHTML = ''; // Clear existing stars
            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = Math.random() * 3 + 1 + 'px';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        let currentGame = null;
        let animationFrameId = null; // Stores the requestAnimationFrame ID for the active game
        let canvas, ctx; // Main canvas and context

        const originalCanvasWidth = 600;
        const originalCanvasHeight = 400;

        let score = 0;
        let gameState = {}; // Holds game-specific variables for the current game

        let gameActive = false; // Global flag to control game loop

        // --- Keyboard Input Tracking (Centralized) ---
        const keysPressed = new Set(); // Tracks which keys are currently held down

        document.addEventListener('keydown', (e) => {
            // Only process input if a game is active AND the game over/start overlays are NOT active
            if (gameActive && 
                !document.getElementById('gameOverOverlay').classList.contains('active') &&
                document.getElementById('messageBox').style.display !== 'block') { 
                
                const lowerKey = e.key.toLowerCase();
                // Prevent default browser behavior for relevant keys
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd'].includes(lowerKey)) {
                    e.preventDefault();
                }
                keysPressed.add(lowerKey);

                // --- Game-specific input handling ---
                switch (currentGame) {
                    case 'dino':
                        if (lowerKey === ' ' && !gameState.dino.isJumping) {
                            gameState.dino.jump();
                        }
                        break;
                    case 'snake':
                        if (lowerKey === 'arrowup' || lowerKey === 'w') {
                            changeDirection('up');
                        } else if (lowerKey === 'arrowdown' || lowerKey === 's') {
                            changeDirection('down');
                        } else if (lowerKey === 'arrowleft' || lowerKey === 'a') {
                            changeDirection('left');
                        } else if (lowerKey === 'arrowright' || lowerKey === 'd') {
                            changeDirection('right');
                        }
                        break;
                    case 'asteroids':
                         if (lowerKey === ' ') {
                            shootBulletAsteroids();
                        }
                        break;
                    case 'tetris':
                        if (lowerKey === 'arrowup' || lowerKey === 'w') {
                            if (!e.repeat) { // Prevent multiple rotations on hold
                                rotatePiece(gameState.currentPiece, 1);
                            }
                        } else if (lowerKey === ' ') { // Hard drop
                            if (!e.repeat) {
                                while (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY + 1)) {
                                    gameState.pieceY++;
                                }
                                lockPiece();
                            }
                        }
                        break;
                    case 'galacticInvaders':
                        if (lowerKey === ' ' && gameState.player.canShoot) {
                            firePlayerBullet();
                        }
                        break;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed.delete(e.key.toLowerCase());
        });

        // --- Main Game Loop (requestAnimationFrame) ---
        let lastFrameTime = 0;
        function gameLoop(currentTime) {
            // Stop if no game is selected or if game is not active
            if (!currentGame || !gameActive) return; 

            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw specific game
            switch(currentGame) {
                case 'dino': updateDino(deltaTime); drawDino(); break;
                case 'snake': updateSnake(deltaTime); drawSnake(); break;
                case 'pong': updatePong(deltaTime); drawPong(); break;
                case 'asteroids': updateAsteroids(deltaTime); drawAsteroids(); break;
                case 'breakout': updateBreakout(deltaTime); drawBreakout(); break;
                case 'tetris': updateTetris(deltaTime); drawTetris(); break;
                case 'minesweeper': updateMinesweeper(deltaTime); drawMinesweeper(); break;
                case 'galacticInvaders': updateGalacticInvaders(deltaTime); drawGalacticInvaders(); break;
            }

            // Continue the loop only if game is active and not showing a message or game over screen
            if (gameActive && !document.getElementById('gameOverOverlay').classList.contains('active') &&
                document.getElementById('messageBox').style.display !== 'block') { // Check if messageBox is NOT visible
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function startGame(gameType, difficulty = null) {
            // Cancel any existing animation frame to prevent multiple loops
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Hide main game selection grid and the header
            document.getElementById('gameSelection').style.display = 'none'; 
            document.getElementById('mainHeader').style.display = 'none';
            
            // Hide all overlays that might be active
            document.getElementById('gameOverOverlay').classList.remove('active');
            document.getElementById('messageBox').style.display = 'none'; 

            // Initialize canvas and context
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            // Clear the canvas explicitly to remove any lingering drawings
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000'; // Fill with black for a clean background
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            canvas.width = originalCanvasWidth;
            canvas.height = originalCanvasHeight;
            // Center the canvas by making it block and auto margin
            canvas.style.marginLeft = 'auto';
            canvas.style.marginRight = 'auto';
            canvas.style.width = 'auto'; // Reset width to default for non-tetris games
            canvas.style.height = 'auto'; // Reset height to default for non-tetris games

            // Hide game specific elements initially for all games
            document.getElementById('minesweeperInfo').style.display = 'none';
            document.getElementById('scoreDisplay').style.display = 'none'; // Generic score display
            document.getElementById('galacticInvadersInfo').style.display = 'none'; // Galactic Invaders info display
            document.getElementById('restartGameButton').style.display = 'none'; 
            document.querySelector('.action-buttons').style.display = 'none'; 
            canvas.style.display = 'none'; 
            // Always hide game title until the game is actually started (not just showing instructions)
            document.getElementById('gameTitle').style.display = 'none'; 
            
            currentGame = gameType; // Set current game

            // Clear game state and input keys for a fresh start
            score = 0; // Reset score for the game that's about to start
            updateScore(); // This will update the scoreDisplay element
            keysPressed.clear();
            console.log(`[Game Start] Current score reset to: ${score}`); // Log for debugging

            // Remove previous Minesweeper-specific listeners (if any)
            canvas.removeEventListener('click', handleMinesweeperClick);
            canvas.removeEventListener('contextmenu', handleMinesweeperRightClick);


            // Game-specific initializations
            if (gameType === 'pong' && difficulty === null) {
                // For Pong, show difficulty selection first, and the gameArea frame
                document.getElementById('gameArea').style.display = 'block'; // Show game area for Pong difficulty
                document.getElementById('pongDifficultySelection').style.display = 'flex';
                // gameTitle remains hidden here. It will be shown in startSelectedPongDifficulty.
                // No need to initialize Pong game state yet, it will be done after difficulty selection
            } else {
                // For other games, show the gameArea as container for messageBox
                document.getElementById('gameArea').style.display = 'block'; 
                // gameTitle is explicitly hidden above. This will be shown when startGameFromOverlay is called.
                const controlsText = getControlsText(gameType);
                // Pass true for isStartOverlay to show 'Start Game' button
                showMessage(`**Controls:** ${controlsText}<br><br>Click 'Start Game' to begin the challenge!`, true);
                
                // Initialize game state (but don't start game loop until user clicks OK)
                gameState = {}; // Clear previous game state
                switch(gameType) {
                    case 'dino': initDino(); break;
                    case 'snake': initSnake(); break;
                    // Pong is handled above if difficulty is null
                    case 'asteroids': initAsteroids(); break;
                    case 'breakout': initBreakout(); break;
                    case 'tetris': initTetris(); break;
                    case 'minesweeper': initMinesweeper(); break;
                    case 'galacticInvaders': initGalacticInvaders(); break;
                }
            }
        }

        // Modified showMessage to distinguish start overlay messages
        function showMessage(msg, isStartOverlay = false) {
            messageText.innerHTML = msg;
            
            if (isStartOverlay) {
                messageBoxOkBtn.textContent = 'Start Game';
                messageBoxOkBtn.onclick = startGameFromOverlay; // Attach specific start function
            } else { // Regular in-game message
                messageBoxOkBtn.textContent = 'OK';
                messageBoxOkBtn.onclick = hideMessage;
            }
            messageBox.style.display = 'block'; // This makes the message box visible
            gameActive = false; // Pause game logic
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // Ensure loop stops when message is shown
                animationFrameId = null;
            }
        }
        
        function hideMessage() {
            messageBox.style.display = 'none';
            // Reset messageBoxOkBtn's onclick in case it was modified for a start overlay
            messageBoxOkBtn.onclick = hideMessage;
            messageBoxOkBtn.textContent = 'OK'; 

            gameActive = true; // Resume/start game logic
            
            // Show relevant info based on game type AFTER starting
            if (currentGame === 'minesweeper') {
                document.getElementById('minesweeperInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none'; // Minesweeper uses its own score/timer display
            } else if (currentGame === 'galacticInvaders') {
                document.getElementById('galacticInvadersInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none'; // Hide generic score
                updateGalacticInvadersScoreAndLives(); // Update specific UI
            }
            else { // For other games
                document.getElementById('minesweeperInfo').style.display = 'none';
                document.getElementById('galacticInvadersInfo').style.display = 'none';
                document.getElementById('scoreDisplay').style.display = 'block';
            }
            
            document.getElementById('gameTitle').style.display = 'block'; // Show game title now
            document.getElementById('gameArea').style.display = 'block'; // Game Area is already active and its children will be shown
            canvas.style.display = 'block'; // Show canvas now that instructions are hidden
            document.getElementById('restartGameButton').style.display = 'block'; // Show restart button
            document.querySelector('.action-buttons').style.display = 'flex'; // Show action buttons
            
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // New function to handle starting game from the overlay's "Start Game" button
        function startGameFromOverlay() {
            messageBox.style.display = 'none';
            gameActive = true; // Set unified game active flag
            
            // Now, show the actual game elements within the gameArea
            document.getElementById('gameArea').style.display = 'block'; // Game area container should already be visible
            document.getElementById('gameTitle').style.display = 'block'; // Show game title now
            document.getElementById('gameTitle').textContent = getGameTitle(currentGame); // Ensure title is set
            canvas.style.display = 'block'; 
            document.getElementById('restartGameButton').style.display = 'block'; // Show restart button
            document.querySelector('.action-buttons').style.display = 'flex'; // Show action buttons
            
            // Show relevant info based on game type AFTER starting
            if (currentGame === 'minesweeper') {
                document.getElementById('minesweeperInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none';
            } else if (currentGame === 'galacticInvaders') {
                document.getElementById('galacticInvadersInfo').style.display = 'flex';
                document.getElementById('scoreDisplay').style.display = 'none'; // Hide generic score
                updateGalacticInvadersScoreAndLives(); // Update specific UI
            }
            else { // For other games
                document.getElementById('minesweeperInfo').style.display = 'none';
                document.getElementById('galacticInvadersInfo').style.display = 'none';
                document.getElementById('scoreDisplay').style.display = 'block';
            }
            
            setupControls(currentGame); // Update controls display (now just clears the div)
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }


        function startSelectedPongDifficulty() {
            const selectedDifficulty = document.querySelector('input[name="pongDifficulty"]:checked').value;
            // Directly initialize and start Pong without the extra message box step
            initializeGame('pong', selectedDifficulty); 
            document.getElementById('pongDifficultySelection').style.display = 'none'; // Hide difficulty selection
            document.getElementById('gameTitle').style.display = 'block'; // Show game title for Pong
            document.getElementById('gameTitle').textContent = getGameTitle('pong'); // Update title
            // GameArea is already 'block' from startGame for Pong. Now show its contents.
            document.getElementById('scoreDisplay').style.display = 'block'; // Show score display
            document.getElementById('restartGameButton').style.display = 'block'; // Show restart button
            canvas.style.display = 'block'; // Show canvas now that difficulty is selected
            document.querySelector('.action-buttons').style.display = 'flex'; // Show action buttons
            setupControls('pong'); // Setup controls (now just clears the div)
            gameActive = true;
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function gameOver(status = 'lost') {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameActive = false; // Stop game logic

            // Get references to elements
            const finalScoreDisplay = document.getElementById('finalScoreDisplay');
            const gameOverH2 = document.getElementById('gameOverOverlay').querySelector('h2');
            const gameOverContent = document.getElementById('gameOverOverlay').querySelector('.game-over-content');
            // High score display element removed from HTML

            if (currentGame === 'minesweeper') {
                if (status === 'won') {
                    gameOverH2.textContent = 'YOU WON!';
                    gameOverH2.style.color = '#00ff41';
                    gameOverH2.style.textShadow = '0 0 15px #00ff41';
                    gameOverContent.style.borderColor = '#00ff41';
                    finalScoreDisplay.textContent = `Time: ${gameState.timer}s`;
                } else {
                    gameOverH2.textContent = 'GAME OVER!';
                    gameOverH2.style.color = '#ff0041';
                    gameOverH2.style.textShadow = '0 0 15px #ff0041';
                    gameOverContent.style.borderColor = '#ff0041';
                    finalScoreDisplay.textContent = `You hit a mine!`;
                }
            } else if (currentGame === 'galacticInvaders') {
                gameOverH2.textContent = 'GAME OVER!';
                gameOverH2.style.color = '#ff0077'; // Galaga-like specific color
                gameOverH2.style.textShadow = '0 0 15px #ff0077';
                gameOverContent.style.borderColor = '#ff0077';
                finalScoreDisplay.textContent = `Final Score: ${gameState.score} (Wave ${gameState.wave})`; // Include wave in final score

            }
            // For all other traditional score games
            else {
                gameOverH2.textContent = 'GAME OVER!';
                gameOverH2.style.color = '#ff0041';
                gameOverH2.style.textShadow = '0 0 15px #ff0041';
                gameOverContent.style.borderColor = '#ff0041';
                finalScoreDisplay.textContent = `Final Score: ${score}`;
            }

            document.getElementById('gameOverOverlay').classList.add('active');
        }

        function restartGame() {
            // Cancel any running game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameActive = false; // Ensure game is marked inactive before re-init

            score = 0; // Reset general score
            updateScore(); // Update generic score display
            gameState = {}; // Clear previous game state
            keysPressed.clear(); // Clear any pressed keys
            console.log(`[Game Restart] Current score reset to: ${score}`); // Log for debugging

            // Clear canvas display explicitly before re-initializing
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000'; // Fill with black
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Hide game-specific UI elements
            canvas.style.display = 'none';
            document.getElementById('restartGameButton').style.display = 'none'; 
            document.querySelector('.action-buttons').style.display = 'none'; 
            document.getElementById('scoreDisplay').style.display = 'none'; // Hide generic score
            document.getElementById('minesweeperInfo').style.display = 'none'; 
            document.getElementById('galacticInvadersInfo').style.display = 'none'; // Hide Galactic Invaders info
            document.getElementById('gameTitle').style.display = 'none'; // Explicitly hide game title on restart
            
            // Ensure gameArea is visible as container for the message/difficulty
            document.getElementById('gameArea').style.display = 'block'; 


            if (currentGame === 'pong') {
                // For Pong, go back to difficulty selection, which correctly uses gameArea styling
                startGame('pong', null); 
            } else {
                // For other games, re-initialize and show the start message again (which uses gameArea styling)
                initializeGame(currentGame); 
                const controlsText = getControlsText(currentGame);
                showMessage(`**Controls:** ${controlsText}<br><br>Click 'Start Game' to begin the challenge!`, true); 
            }
        }

        function restartGameFromGameOver() {
            document.getElementById('gameOverOverlay').classList.remove('active');
            // Call startGame for the current game, which handles all necessary resets and setup.
            startGame(currentGame);
        }


        function backToMenuFromGameOver() {
            document.getElementById('gameOverOverlay').classList.remove('active');
            backToMenu();
        }

        function backToMenu() {
            // Cancel any running game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameActive = false; // Reset gameActive when returning to menu

            // Clear canvas explicitly when going back to menu
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000'; // Fill with black
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Hide all game displays and overlays
            document.getElementById('gameArea').style.display = 'none'; // Ensure gameArea is hidden
            document.getElementById('pongDifficultySelection').style.display = 'none';
            document.getElementById('messageBox').style.display = 'none';
            document.getElementById('gameOverOverlay').classList.remove('active');

            // Show main menu and header
            document.getElementById('gameSelection').style.display = 'grid'; 
            document.getElementById('mainHeader').style.display = 'block';
            
            currentGame = null; // Clear current game selection
            score = 0; // Reset general score for the menu
            updateScore();
            keysPressed.clear(); // Clear any pressed keys

            document.getElementById('minesweeperInfo').style.display = 'none'; // Hide Minesweeper info
            document.getElementById('galacticInvadersInfo').style.display = 'none'; // Hide Galactic Invaders info
            document.getElementById('scoreDisplay').style.display = 'block'; // Ensure general score display is visible
            document.getElementById('restartGameButton').style.display = 'none'; // Hide restart button when back to menu
            document.querySelector('.action-buttons').style.display = 'none'; // Hide action buttons when back to menu
            document.getElementById('gameTitle').style.display = 'none'; // Ensure it's hidden when returning to menu


            // Ensure canvas is hidden when going back to menu
            if (canvas) {
                canvas.style.display = 'none';
            }

            // Remove Minesweeper specific listeners
            canvas.removeEventListener('click', handleMinesweeperClick);
            canvas.removeEventListener('contextmenu', handleMinesweeperRightClick);
        }

        function updateScore() {
            // This function is for traditional game scores only
            if (currentGame !== 'minesweeper' && currentGame !== 'galacticInvaders') { // Minesweeper and Galactic Invaders have their own score display
                document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
            }
        }

        // Helper function to initialize game state without starting the loop immediately
        function initializeGame(gameType, difficulty = null) {
            // This function now only handles the initial setup for traditional games
            // Canvas/context is already set up by startGame for the correct game type.

            if (ctx) { // Only clear if it's a traditional game canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            switch(gameType) {
                case 'dino': initDino(); break;
                case 'snake': initSnake(); break;
                case 'pong': initPong(difficulty); break;
                case 'asteroids': initAsteroids(); break;
                case 'breakout': initBreakout(); break;
                case 'tetris': initTetris(); break;
                case 'minesweeper': initMinesweeper(); break;
                case 'galacticInvaders': initGalacticInvaders(); break;
            }
        }

        function getGameTitle(gameType) {
            const titles = {
                dino: '🦖 Prehistoric Run',
                snake: '🐍 Neon Snake',
                pong: '⚡ Cyber Pong',
                asteroids: '💫 Space Rocks',
                breakout: '🧱 Block Destroyer',
                tetris: '🟦 Pixel Tetris',
                minesweeper: '💣 Hidden Grid',
                galacticInvaders: '🚀 Galactic Invaders'
            };
            return titles[gameType];
        }

        function getControlsText(gameType) {
            let instructions = '';
            switch (gameType) {
                case 'dino': instructions = 'Press **SPACEBAR** to jump over obstacles.'; break;
                case 'snake': instructions = 'Use **WASD** or **Arrow Keys** to change snake direction.'; break;
                case 'pong': instructions = 'Use **W** (Up) and **S** (Down) or **↑ Arrow** (Up) and **↓ Arrow** (Down) to move your paddle.'; break;
                case 'asteroids': instructions = 'Use **W** or **↑ Arrow** for thrust. Use **A** or **← Arrow** to rotate left. Use **D** (Right) or **→ Arrow** to rotate right. Press **SPACEBAR** to shoot.'; break;
                case 'breakout': instructions = 'Use **A** (Left) and **D** (Right) or **← Arrow** (Left) and **→ Arrow** (Right) to move your paddle.'; break;
                case 'tetris': instructions = 'Use **← Arrow / A** (Left), **→ Arrow / D** (Right), **↓ Arrow / S** (Soft Drop). Use **↑ Arrow / W** (Rotate). Press **SPACEBAR** for Hard Drop.'; break;
                case 'minesweeper': instructions = 'Click a square to reveal it. Right-click (or Ctrl+Click) to flag a mine. Clear all non-mine squares to win.'; break;
                case 'galacticInvaders': instructions = 'Use **A** (Left) and **D** (Right) or **← Arrow** (Left) and **→ Arrow** (Right) to move your ship. Press **SPACEBAR** to shoot.'; break;
                default: instructions = 'Keyboard controls.';
            }
            return instructions;
        }

        function setupControls(gameType) {
            const controlsDiv = document.getElementById('gameControls');
            controlsDiv.innerHTML = ''; // Clear the content of the controls div
        }


        // --- Dino Game ---
        const DINO_Y_OFFSET = 5;
        const DINO_HEIGHT_DEFAULT = 50;
        const DINO_WIDTH_DEFAULT = 30;
        const GROUND_LINE_Y = originalCanvasHeight - DINO_Y_OFFSET;

        function initDino() {
            gameState.dino = {
                x: 50, y: GROUND_LINE_Y - DINO_HEIGHT_DEFAULT, width: DINO_WIDTH_DEFAULT, height: DINO_HEIGHT_DEFAULT,
                dy: 0, gravity: 0.5, jumpStrength: -10, isJumping: false,
                draw() {
                    if (!ctx) return;
                    ctx.fillStyle = '#00ff41'; ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.beginPath(); ctx.arc(this.x + this.width, this.y + this.height * 0.2, this.width * 0.5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x + this.width + 5, this.y + this.height * 0.1, this.width * 0.3, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#1a1a2e'; ctx.beginPath(); ctx.arc(this.x + this.width + this.width * 0.4, this.y + this.height * 0.15, 2, 0, Math.PI * 2); ctx.fill();
                },
                jump() { if (!this.isJumping) { this.dy = this.jumpStrength; this.isJumping = true; } },
                update() {
                    this.dy += this.gravity; this.y += this.dy;
                    if (this.y + this.height > GROUND_LINE_Y) { this.y = GROUND_LINE_Y - this.height; this.dy = 0; this.isJumping = false; }
                }
            };
            gameState.obstacles = []; gameState.gameSpeed = 5; gameState.obstacleSpawnTimer = 0; gameState.obstacleSpawnInterval = 1500;
        }

        function createDinoObstacle() {
            const obstacleTypes = [{ width: 20, height: 40, color: '#ff0041' }, { width: 30, height: 60, color: '#ff0041' }, { width: 45, height: 25, color: '#ff0041', isFlying: true, yOffset: 100 }];
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            gameState.obstacles.push({
                x: canvas.width, y: type.isFlying ? (GROUND_LINE_Y - type.height - type.yOffset) : (GROUND_LINE_Y - type.height),
                width: type.width, height: type.height, color: type.color,
                draw() {
                    if (!ctx) return; ctx.fillStyle = this.color;
                    if (type.isFlying) {
                         ctx.beginPath(); ctx.moveTo(this.x, this.y + this.height * 0.5); ctx.lineTo(this.x + this.width, this.y); ctx.lineTo(this.x + this.width * 0.8, this.y + this.height * 0.5); ctx.lineTo(this.x + this.width, this.y + this.height); ctx.lineTo(this.x, this.y + this.height * 0.5); ctx.fill();
                    } else { ctx.fillRect(this.x, this.y, this.width, this.height); }
                }
            });
        }

        function updateDino(deltaTime) {
            for (let i = 0; i < gameState.obstacles.length; i++) {
                gameState.obstacles[i].x -= gameState.gameSpeed;
                const dino = gameState.dino; const obstacle = gameState.obstacles[i];
                if (dino.x < obstacle.x + obstacle.width && dino.x + dino.width > obstacle.x && dino.y < obstacle.y + obstacle.height && dino.y + dino.height > obstacle.y) {
                    gameOver(); return;
                }
            }
            gameState.obstacles = gameState.obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
            gameState.obstacleSpawnTimer += deltaTime * 1000;
            if (gameState.obstacleSpawnTimer > gameState.obstacleSpawnInterval && gameState.obstacles.length < 3) {
                createDinoObstacle(); gameState.obstacleSpawnTimer = 0; gameState.gameSpeed += 0.01; gameState.obstacleSpawnInterval = Math.max(800, gameState.obstacleSpawnInterval - 5);
            }
            gameState.dino.update(); score++; updateScore();
        }

        function drawDino() {
            if (!ctx) return;
            ctx.strokeStyle = '#00ff41'; ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(0, GROUND_LINE_Y); ctx.lineTo(canvas.width, GROUND_LINE_Y); ctx.stroke();
            gameState.dino.draw();
            for (let obstacle of gameState.obstacles) { obstacle.draw(); }
        }
        // --- End Dino Game ---


        // --- Snake Game ---
        function initSnake() {
            gameState = {
                snake: [{x: 10, y: 10}], food: {x: 15, y: 15}, direction: {x: 1, y: 0}, nextDirection: {x: 1, y: 0},
                gridSize: 20, speed: 10, timeSinceLastMove: 0
            };
            spawnFood();
        }

        function updateSnake(deltaTime) {
            const moveInterval = 1 / gameState.speed;
            gameState.timeSinceLastMove += deltaTime;
            if (gameState.timeSinceLastMove >= moveInterval) {
                gameState.timeSinceLastMove -= moveInterval;
                gameState.direction = gameState.nextDirection;
                const head = {x: gameState.snake[0].x + gameState.direction.x, y: gameState.snake[0].y + gameState.direction.y};
                const maxGridX = canvas.width / gameState.gridSize; const maxGridY = canvas.height / gameState.gridSize;
                if (head.x < 0 || head.x >= maxGridX || head.y < 0 || head.y >= maxGridY) { gameOver(); return; }
                for (let i = 1; i < gameState.snake.length; i++) {
                    const segment = gameState.snake[i]; if (head.x === segment.x && head.y === segment.y) { gameOver(); return; }
                }
                gameState.snake.unshift(head);
                if (head.x === gameState.food.x && head.y === gameState.food.y) {
                    score += 10; updateScore(); if (gameState.speed < 20) gameState.speed += 0.5; spawnFood();
                } else { gameState.snake.pop(); }
            }
        }

        function spawnFood() {
            const maxGridX = canvas.width / gameState.gridSize; const maxGridY = canvas.height / gameState.gridSize;
            do {
                gameState.food = {x: Math.floor(Math.random() * maxGridX), y: Math.floor(Math.random() * maxGridY)};
            } while (gameState.snake.some(segment => segment.x === gameState.food.x && segment.y === gameState.food.y));
        }

        function drawSnake() {
            if (!ctx) return;
            ctx.fillStyle = '#00ff41';
            for (let segment of gameState.snake) { ctx.fillRect(segment.x * gameState.gridSize, segment.y * gameState.gridSize, gameState.gridSize - 2, gameState.gridSize - 2); }
            ctx.fillStyle = '#ff0041';
            ctx.fillRect(gameState.food.x * gameState.gridSize, gameState.food.y * gameState.gridSize, gameState.gridSize - 2, gameState.gridSize - 2);
        }

        function changeDirection(dir) {
            if (!gameState || !gameState.direction) return;
            const directions = { up: {x: 0, y: -1}, down: {x: 0, y: 1}, left: {x: -1, y: 0}, right: {x: 1, y: 0} };
            const newDir = directions[dir];
            if (newDir && (newDir.x !== -gameState.direction.x || newDir.y !== -gameState.direction.y)) { gameState.nextDirection = newDir; }
        }
        // --- End Snake Game ---

        // --- Pong Game ---
        function initPong(difficulty) {
            gameState.difficulty = difficulty;
            const initialBallSpeed = 280; const randomXDir = Math.random() < 0.5 ? 1 : -1; const randomYDir = Math.random() < 0.5 ? 1 : -1;
            let aiPaddleSpeed;
            if (difficulty === 'easy') { aiPaddleSpeed = 220; } else { aiPaddleSpeed = 350; }
            gameState = {
                ...gameState, paddle1: {x: 10, y: canvas.height/2 - 50, width: 10, height: 100, dy: 0, speed: 200},
                paddle2: {x: canvas.width - 20, y: canvas.height/2 - 50, width: 10, height: 100, speed: aiPaddleSpeed},
                ball: { x: canvas.width/2, y: canvas.height/2, dx: initialBallSpeed * randomXDir, dy: initialBallSpeed * randomYDir, radius: 8 },
                initialBallSpeed: initialBallSpeed
            };
            score = 0; updateScore();
        }

        function updatePong(deltaTime) {
            if (keysPressed.has('arrowup') || keysPressed.has('w')) { gameState.paddle1.y = Math.max(0, gameState.paddle1.y - gameState.paddle1.speed * deltaTime); }
            if (keysPressed.has('arrowdown') || keysPressed.has('s')) { gameState.paddle1.y = Math.min(canvas.height - gameState.paddle1.height, gameState.paddle1.y + gameState.paddle1.speed * deltaTime); }
            gameState.ball.x += gameState.ball.dx * deltaTime; gameState.ball.y += gameState.ball.dy * deltaTime;
            if (gameState.ball.y - gameState.ball.radius <= 0) { gameState.ball.y = gameState.ball.radius; gameState.ball.dy = -gameState.ball.dy; }
            else if (gameState.ball.y + gameState.ball.radius >= canvas.height) { gameState.ball.y = canvas.height - gameState.ball.radius; gameState.ball.dy = -gameState.ball.dy; }
            if (gameState.ball.dx < 0 && gameState.ball.x - gameState.ball.radius <= gameState.paddle1.x + gameState.paddle1.width && gameState.ball.y >= gameState.paddle1.y && gameState.ball.y <= gameState.paddle1.y + gameState.paddle1.height) {
                gameState.ball.x = gameState.paddle1.x + gameState.paddle1.width + gameState.ball.radius; gameState.ball.dx = -gameState.ball.dx; gameState.ball.dy += (Math.random() * 50 - 25);
            }
            else if (gameState.ball.dx > 0 && gameState.ball.x + gameState.ball.radius >= gameState.paddle2.x && gameState.ball.y >= gameState.paddle2.y && gameState.ball.y <= gameState.paddle2.y + gameState.paddle2.height) {
                gameState.ball.x = gameState.paddle2.x - gameState.ball.radius; gameState.ball.dx = -gameState.ball.dx; gameState.ball.dy += (Math.random() * 50 - 25);
            }
            if (gameState.ball.x < 0) { gameOver(); return; } else if (gameState.ball.x > canvas.width) {
                 gameState.ball.x = canvas.width/2; gameState.ball.y = canvas.height/2;
                 gameState.ball.dx = (Math.random() < 0.5 ? 1 : -1) * gameState.initialBallSpeed; gameState.ball.dy = (Math.random() < 0.5 ? 1 : -1) * gameState.initialBallSpeed;
                 score += 1; updateScore();
            }
            if (gameState.difficulty === 'easy') {
                let aiTargetY = gameState.ball.y - gameState.paddle2.height / 2; aiTargetY = Math.max(0, Math.min(canvas.height - gameState.paddle2.height, aiTargetY));
                const moveAmount = gameState.paddle2.speed * deltaTime;
                if (gameState.paddle2.y < aiTargetY) { gameState.paddle2.y = Math.min(aiTargetY, gameState.paddle2.y + moveAmount); }
                else if (gameState.paddle2.y > aiTargetY) { gameState.paddle2.y = Math.max(aiTargetY, gameState.paddle2.y - moveAmount); }
            } else {
                let predictedY = gameState.ball.y;
                if (gameState.ball.dx > 0 && gameState.ball.x > canvas.width / 2) {
                    const timeToReachPaddleX = (gameState.paddle2.x - gameState.ball.x) / gameState.ball.dx;
                    if (timeToReachPaddleX > 0) { predictedY = gameState.ball.y + gameState.ball.dy * timeToReachPaddleX; predictedY = Math.max(0, Math.min(canvas.height, predictedY)); }
                }
                const humanError = (Math.random() - 0.5) * 15;
                let aiTargetY = predictedY - gameState.paddle2.height / 2 + humanError; aiTargetY = Math.max(0, Math.min(canvas.height - gameState.paddle2.height, aiTargetY));
                const moveAmount = gameState.paddle2.speed * deltaTime;
                if (gameState.paddle2.y < aiTargetY) { gameState.paddle2.y = Math.min(aiTargetY, gameState.paddle2.y + moveAmount); }
                else if (gameState.paddle2.y > aiTargetY) { gameState.paddle2.y = Math.max(aiTargetY, gameState.paddle2.y - moveAmount); }
            }
        }

        function drawPong() {
            if (!ctx) return;
            ctx.fillStyle = '#00ff41'; ctx.fillRect(gameState.paddle1.x, gameState.paddle1.y, gameState.paddle1.width, gameState.paddle1.height);
            ctx.fillStyle = '#ff0041'; ctx.fillRect(gameState.paddle2.x, gameState.paddle2.y, gameState.paddle2.width, gameState.paddle2.height);
            ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#00ff41'; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(canvas.width/2, 0); ctx.lineTo(canvas.width/2, canvas.height); ctx.stroke(); ctx.setLineDash([]);
        }
        // --- End Pong Game ---

        // --- Asteroids Game ---
        const ASTEROIDS_SHOOT_COOLDOWN = 0.2;
        let lastShotTimeAsteroids = 0;

        function initAsteroids() {
            gameState = {
                ship: {x: canvas.width/2, y: canvas.height/2, angle: -Math.PI/2, vx: 0, vy: 0, thrust: 150, rotationSpeed: 3},
                bullets: [], asteroids: []
            };
            for (let i = 0; i < 5; i++) { spawnAsteroid(3); }
            score = 0; updateScore();
        }

        function updateAsteroids(deltaTime) {
            if (keysPressed.has('arrowup') || keysPressed.has('w')) { gameState.ship.vx += Math.cos(gameState.ship.angle) * gameState.ship.thrust * deltaTime; gameState.ship.vy += Math.sin(gameState.ship.angle) * gameState.ship.thrust * deltaTime; }
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) { gameState.ship.angle -= gameState.ship.rotationSpeed * deltaTime; }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) { gameState.ship.angle += gameState.ship.rotationSpeed * deltaTime; }
            gameState.ship.x += gameState.ship.vx * deltaTime; gameState.ship.y += gameState.ship.vy * deltaTime;
            gameState.ship.vx *= (1 - 0.5 * deltaTime); gameState.ship.vy *= (1 - 0.5 * deltaTime);
            if (gameState.ship.x < 0) gameState.ship.x = canvas.width; if (gameState.ship.x > canvas.width) gameState.ship.x = 0;
            if (gameState.ship.y < 0) gameState.ship.y = canvas.height; if (gameState.ship.y > canvas.height) gameState.ship.y = 0;
            gameState.bullets = gameState.bullets.filter(bullet => {
                bullet.x += bullet.vx * deltaTime; bullet.y += bullet.vy * deltaTime;
                return bullet.x > -10 && bullet.x < canvas.width + 10 && bullet.y > -10 && bullet.y < canvas.height + 10;
            });
            gameState.asteroids.forEach(asteroid => {
                asteroid.x += asteroid.vx * deltaTime; asteroid.y += asteroid.vy * deltaTime;
                if (asteroid.x < 0) asteroid.x = canvas.width; if (asteroid.x > canvas.width) asteroid.x = 0;
                if (asteroid.y < 0) asteroid.y = canvas.height; if (asteroid.y > canvas.height) asteroid.y = 0;
            });
            for (let bIndex = gameState.bullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = gameState.bullets[bIndex];
                for (let aIndex = gameState.asteroids.length - 1; aIndex >= 0; aIndex--) {
                    const asteroid = gameState.asteroids[aIndex];
                    const dx = bullet.x - asteroid.x; const dy = bullet.y - asteroid.y;
                    if (Math.sqrt(dx * dx + dy * dy) < asteroid.radius) {
                        gameState.bullets.splice(bIndex, 1); score += 100; updateScore();
                        if (asteroid.size > 1) { spawnAsteroid(asteroid.size - 1, asteroid.x, asteroid.y); spawnAsteroid(asteroid.size - 1, asteroid.x, asteroid.y); }
                        gameState.asteroids.splice(aIndex, 1); break;
                    }
                }
            }
            for (let asteroid of gameState.asteroids) {
                const dx = gameState.ship.x - asteroid.x; const dy = gameState.ship.y - asteroid.y;
                if (Math.sqrt(dx * dx + dy * dy) < asteroid.radius + 10) { gameOver(); return; }
            }
            if (gameState.asteroids.length === 0) {
                const levelMultiplier = Math.floor(score / 500) + 1;
                for (let i = 0; i < 5 + levelMultiplier; i++) { spawnAsteroid(3); }
            }
        }

        function drawAsteroids() {
            if (!ctx) return;
            ctx.save(); ctx.translate(gameState.ship.x, gameState.ship.y); ctx.rotate(gameState.ship.angle);
            ctx.strokeStyle = '#00ff41'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, -10); ctx.lineTo(-5, 0); ctx.lineTo(-10, 10); ctx.closePath(); ctx.stroke(); ctx.restore();
            ctx.fillStyle = '#00ffff'; gameState.bullets.forEach(bullet => { ctx.beginPath(); ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2); ctx.fill(); });
            ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2; gameState.asteroids.forEach(asteroid => { ctx.beginPath(); ctx.arc(asteroid.x, asteroid.y, asteroid.radius, 0, Math.PI * 2); ctx.stroke(); });
        }

        function shootBulletAsteroids() {
            const currentTime = performance.now() / 1000;
            if (currentTime - lastShotTimeAsteroids > ASTEROIDS_SHOOT_COOLDOWN) {
                gameState.bullets.push({
                    x: gameState.ship.x + Math.cos(gameState.ship.angle) * 15, y: gameState.ship.y + Math.sin(gameState.ship.angle) * 15,
                    vx: Math.cos(gameState.ship.angle) * 300 + gameState.ship.vx, vy: Math.sin(gameState.ship.angle) * 300 + gameState.ship.vy
                });
                lastShotTimeAsteroids = currentTime;
            }
        }

        function spawnAsteroid(size, x = null, y = null) {
            const radiusMap = { 3: 40, 2: 25, 1: 15 }; const speedMap = { 3: 60, 2: 90, 1: 120 };
            const asteroidRadius = radiusMap[size]; const asteroidSpeed = speedMap[size];
            let asteroidX = x !== null ? x : Math.random() * canvas.width; let asteroidY = y !== null ? y : Math.random() * canvas.height;
            if (size === 3 && x === null && gameState.ship) {
                while (Math.sqrt(Math.pow(asteroidX - gameState.ship.x, 2) + Math.pow(asteroidY - gameState.ship.y, 2)) < 150) {
                    asteroidX = Math.random() * canvas.width; asteroidY = Math.random() * canvas.height;
                }
            }
            gameState.asteroids.push({ x: asteroidX, y: asteroidY, vx: (Math.random() - 0.5) * asteroidSpeed, vy: (Math.random() - 0.5) * asteroidSpeed, radius: asteroidRadius, size: size });
        }
        // --- End Asteroids Game ---


        // --- Breakout Game ---
        function initBreakout() {
            gameState = {
                paddle: {x: canvas.width/2 - 50, y: canvas.height - 20, width: 100, height: 10, speed: 250},
                ball: {x: canvas.width/2, y: canvas.height - 30, vx: 250, vy: -250, radius: 8, prevX: 0, prevY: 0},
                blocks: [], blocksRemaining: 0
            };
            const blockWidth = 55; const blockHeight = 15; const blockPadding = 5; const blockOffsetTop = 50; const blocksPerRow = 10;
            const blockOffsetLeft = (canvas.width - (blocksPerRow * blockWidth + (blocksPerRow - 1) * blockPadding)) / 2;
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < blocksPerRow; col++) {
                    gameState.blocks.push({ x: col * (blockWidth + blockPadding) + blockOffsetLeft, y: row * (blockHeight + blockPadding) + blockOffsetTop,
                        width: blockWidth, height: blockHeight, color: `hsl(${row * 50}, 100%, 50%)`, hits: 5 - row
                    });
                    gameState.blocksRemaining++;
                }
            }
            score = 0; updateScore();
        }

        function checkCollision(ball, rect) {
            return ball.x + ball.radius > rect.x && ball.x - ball.radius < rect.x + rect.width &&
                   ball.y + ball.radius > rect.y && ball.y - ball.radius < rect.y + rect.height;
        }
        
        function getCollisionResponse(ball, block) {
            let hitX = false; let hitY = false;
            if (ball.prevX + ball.radius <= block.x && ball.x + ball.radius > block.x) {
                ball.x = block.x - ball.radius; ball.vx *= -1; hitX = true;
            } else if (ball.prevX - ball.radius >= block.x + block.width && ball.x - ball.radius < block.x + block.width) {
                ball.x = block.x + block.width + ball.radius; ball.vx *= -1; hitX = true;
            }
            if (ball.prevY + ball.radius <= block.y && ball.y + ball.radius > block.y) {
                ball.y = block.y - ball.radius; ball.vy *= -1; hitY = true;
            } else if (ball.prevY - ball.radius >= block.y + block.height && ball.y - ball.radius < block.y + block.height) {
                ball.y = block.y + block.height + ball.radius; ball.vy *= -1; hitY = true;
            }
            return hitX || hitY;
        }
        
        function updateBreakout(deltaTime) {
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) { gameState.paddle.x = Math.max(0, gameState.paddle.x - gameState.paddle.speed * deltaTime); }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) { gameState.paddle.x = Math.min(canvas.width - gameState.paddle.width, gameState.paddle.x + gameState.paddle.speed * deltaTime); }
            gameState.ball.prevX = gameState.ball.x; gameState.ball.prevY = gameState.ball.y;
            gameState.ball.x += gameState.ball.vx * deltaTime; gameState.ball.y += gameState.ball.vy * deltaTime;
            if (gameState.ball.x - gameState.ball.radius <= 0) { gameState.ball.x = gameState.ball.radius; gameState.ball.vx = -gameState.ball.vx; }
            else if (gameState.ball.x + gameState.ball.radius >= canvas.width) { gameState.ball.x = canvas.width - gameState.ball.radius; gameState.ball.vx = -gameState.ball.vx; }
            if (gameState.ball.y - gameState.ball.radius <= 0) { gameState.ball.y = gameState.ball.radius; gameState.ball.vy = -gameState.ball.vy; }
            if (gameState.ball.vy > 0 && gameState.ball.x + gameState.ball.radius > gameState.paddle.x && gameState.ball.x - gameState.ball.radius < gameState.paddle.x + gameState.paddle.width && gameState.ball.y + gameState.ball.radius >= gameState.paddle.y && gameState.ball.prevY + gameState.ball.radius < gameState.paddle.y) {
                ball.y = gameState.paddle.y - ball.radius; ball.vy = -gameState.ball.vy;
                const hitPoint = gameState.ball.x - (gameState.paddle.x + gameState.paddle.width / 2); gameState.ball.vx = hitPoint * 2;
            }
            for (let i = gameState.blocks.length - 1; i >= 0; i--) {
                const block = gameState.blocks[i];
                if (checkCollision(gameState.ball, block)) {
                    if (getCollisionResponse(gameState.ball, block)) {
                        block.hits--;
                        if (block.hits <= 0) { score += 10; updateScore(); gameState.blocks.splice(i, 1); gameState.blocksRemaining--; }
                        break;
                    }
                }
            }
            if (gameState.ball.y - gameState.ball.radius > canvas.height) { gameOver(); return; }
            if (gameState.blocksRemaining === 0) { gameOver(); return; }
        }
        
        function drawBreakout() {
            if (!ctx) return;
            ctx.fillStyle = '#00ff41'; ctx.fillRect(gameState.paddle.x, gameState.paddle.y, gameState.paddle.width, gameState.paddle.height);
            ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2); ctx.fill();
            gameState.blocks.forEach(block => {
                ctx.fillStyle = block.color; ctx.fillRect(block.x, block.y, block.width, block.height);
                ctx.strokeStyle = '#222'; ctx.strokeRect(block.x, block.y, block.width, block.height);
            });
        }
        // --- End Breakout Game ---


        // --- Tetris Game ---
        const TETRIS_COLS = 10; const TETRIS_ROWS = 20; const TETRIS_BLOCK_SIZE = 20;

        const TETROMINOS = {
            'I': { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: '#00ffff' },
            'J': { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: '#0000ff' },
            'L': { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: '#ffa500' },
            'O': { shape: [[1, 1], [1, 1]], color: '#ffff00' },
            'S': { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: '#00ff00' },
            'T': { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: '#800080' },
            'Z': { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: '#ff0000' }
        };

        function initTetris() {
            canvas.width = TETRIS_COLS * TETRIS_BLOCK_SIZE; canvas.height = TETRIS_ROWS * TETRIS_BLOCK_SIZE;
            canvas.style.marginLeft = 'auto'; canvas.style.marginRight = 'auto';
            canvas.style.width = canvas.width + 'px'; // Set exact width for Tetris
            canvas.style.height = canvas.height + 'px'; // Set exact height for Tetris
            gameState = {
                board: Array(TETRIS_ROWS).fill(0).map(() => Array(TETRIS_COLS).fill(0)),
                currentPiece: null, nextPiece: null, pieceX: 0, pieceY: 0, currentPieceColor: '',
                dropCounter: 0, dropInterval: 1, level: 1, linesCleared: 0, score: 0, isGameOver: false, lastMoveTime: 0
            };
            generateNewPiece(); gameState.dropCounter = 0; gameState.lastMoveTime = performance.now(); score = 0; updateScore();
        }

        function generateNewPiece() {
            const pieceKeys = Object.keys(TETROMINOS);
            const randomKey = pieceKeys[Math.floor(Math.random() * pieceKeys.length)];
            const pieceData = TETROMINOS[randomKey];
            gameState.currentPiece = JSON.parse(JSON.stringify(pieceData.shape)); // Deep copy
            gameState.currentPieceColor = pieceData.color;
            gameState.pieceX = Math.floor(TETRIS_COLS / 2) - Math.floor(gameState.currentPiece[0].length / 2);
            gameState.pieceY = 0;

            // Check for game over condition immediately after spawning a new piece
            if (checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY)) {
                gameState.isGameOver = true;
                gameOver();
            }
        }

        function checkTetrisCollision(board, piece, offsetX, offsetY) {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] !== 0) { // If it's a block in the tetromino
                        const boardX = x + offsetX;
                        const boardY = y + offsetY;

                        // Check for collision with walls or bottom
                        if (boardX < 0 || boardX >= TETRIS_COLS || boardY >= TETRIS_ROWS) {
                            return true;
                        }
                        // Skip collision check for cells above the board (negative Y)
                        if (boardY < 0) {
                            continue;
                        }
                        // Check for collision with existing blocks on the board
                        if (board[boardY] && board[boardY][boardX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function rotatePiece(piece, dir) {
            // Create a new array for the rotated piece to avoid modifying the original during check
            const originalPiece = JSON.parse(JSON.stringify(piece)); // Deep copy
            let newPiece = originalPiece.map((row, y) => row.map((val, x) => originalPiece[originalPiece.length - 1 - x][y]));

            if (dir === -1) { // Rotate counter-clockwise (3 times clockwise)
                for (let i = 0; i < 3; i++) {
                    newPiece = newPiece.map((row, y) => row.map((val, x) => newPiece[newPiece.length - 1 - x][y]));
                }
            }

            // Wall kick tests (simplified for basic functionality)
            const offsets = [[0, 0], [-1, 0], [1, 0], [0, -1], [-2, 0], [2, 0]]; // Common wall kick offsets
            for (const [ox, oy] of offsets) {
                if (!checkTetrisCollision(gameState.board, newPiece, gameState.pieceX + ox, gameState.pieceY + oy)) {
                    gameState.currentPiece = newPiece;
                    gameState.pieceX += ox;
                    gameState.pieceY += oy;
                    return true; // Rotation successful
                }
            }
            return false; // Rotation failed
        }

        function lockPiece() {
            for (let y = 0; y < gameState.currentPiece.length; y++) {
                for (let x = 0; x < gameState.currentPiece[y].length; x++) {
                    if (gameState.currentPiece[y][x] !== 0) {
                        // Ensure it's within bounds before placing
                        if (gameState.pieceY + y >= 0 && gameState.pieceY + y < TETRIS_ROWS &&
                            gameState.pieceX + x >= 0 && gameState.pieceX + x < TETRIS_COLS) {
                            gameState.board[gameState.pieceY + y][gameState.pieceX + x] = gameState.currentPieceColor;
                        }
                    }
                }
            }
            clearLines();
            generateNewPiece();
        }

        function clearLines() {
            let linesClearedThisTurn = 0;
            const keptLines = [];

            for (let y = 0; y < TETRIS_ROWS; y++) {
                const isLineFull = gameState.board[y].every(block => block !== 0);
                if (!isLineFull) {
                    keptLines.push(gameState.board[y]);
                } else {
                    linesClearedThisTurn++;
                }
            }

            // Add empty rows to the top for cleared lines
            const newBoard = [];
            for (let i = 0; i < linesClearedThisTurn; i++) {
                newBoard.push(Array(TETRIS_COLS).fill(0));
            }
            // Add the lines that were not full
            keptLines.forEach(row => newBoard.push(row));

            // Adjust board size if necessary (shouldn't happen if logic is perfect, but as a safeguard)
            while (newBoard.length > TETRIS_ROWS) {
                newBoard.shift(); // Remove from top if somehow too many rows
            }
            while (newBoard.length < TETRIS_ROWS) {
                newBoard.unshift(Array(TETRIS_COLS).fill(0)); // Add empty rows to top if too few
            }
            
            gameState.board = newBoard;

            if (linesClearedThisTurn > 0) {
                const scorePerLine = [0, 100, 300, 500, 800]; // Score for 0, 1, 2, 3, 4 lines
                score += scorePerLine[linesClearedThisTurn] * gameState.level;
                gameState.linesCleared += linesClearedThisTurn;
                updateScore();
            }

            // Increase level after every 10 lines cleared (example)
            if (gameState.linesCleared >= gameState.level * 10) {
                gameState.level++;
                gameState.dropInterval = Math.max(0.1, gameState.dropInterval * 0.85); // Make it drop faster
            }
        }

        function updateTetris(deltaTime) {
            if (gameState.isGameOver) return;

            gameState.dropCounter += deltaTime;
            if (gameState.dropCounter >= gameState.dropInterval) {
                gameState.dropCounter = 0;
                dropPiece();
            }

            const currentTime = performance.now();
            const moveDelay = 100; // Milliseconds between horizontal moves on hold

            if (keysPressed.has('arrowdown') || keysPressed.has('s')) {
                gameState.dropCounter += deltaTime * 5; // Soft drop faster
            }
            
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) {
                if (currentTime - gameState.lastMoveTime > moveDelay) {
                    if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX - 1, gameState.pieceY)) {
                        gameState.pieceX--;
                        gameState.lastMoveTime = currentTime;
                    }
                }
            } else if (keysPressed.has('arrowright') || keysPressed.has('d')) {
                if (currentTime - gameState.lastMoveTime > moveDelay) {
                    if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX + 1, gameState.pieceY)) {
                        gameState.pieceX++;
                        gameState.lastMoveTime = currentTime;
                    }
                }
            } else {
                gameState.lastMoveTime = 0; // Reset last move time when no horizontal key is pressed
            }
        }

        function dropPiece() {
            if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY + 1)) {
                gameState.pieceY++;
            } else {
                lockPiece();
            }
        }

        function drawTetris() {
            if (!ctx) return;
            // Draw the fixed blocks on the board
            for (let y = 0; y < TETRIS_ROWS; y++) {
                for (let x = 0; x < TETRIS_COLS; x++) {
                    if (gameState.board[y][x] !== 0) {
                        ctx.fillStyle = gameState.board[y][x];
                        ctx.fillRect(x * TETRIS_BLOCK_SIZE, y * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
                        ctx.strokeStyle = '#000'; // Block borders
                        ctx.strokeRect(x * TETRIS_BLOCK_SIZE, y * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
                    }
                }
            }

            // Draw the current falling piece
            if (gameState.currentPiece) {
                ctx.fillStyle = gameState.currentPieceColor;
                for (let y = 0; y < gameState.currentPiece.length; y++) {
                    for (let x = 0; x < gameState.currentPiece[y].length; x++) {
                        if (gameState.currentPiece[y][x] !== 0) {
                            ctx.fillRect((gameState.pieceX + x) * TETRIS_BLOCK_SIZE, (gameState.pieceY + y) * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
                            ctx.strokeStyle = '#000'; // Block borders
                            ctx.strokeRect((gameState.pieceX + x) * TETRIS_BLOCK_SIZE, (gameState.pieceY + y) * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
                        }
                    }
                }
            }

            // Draw grid lines for visual clarity
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= TETRIS_COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * TETRIS_BLOCK_SIZE, 0);
                ctx.lineTo(i * TETRIS_BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= TETRIS_ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * TETRIS_BLOCK_SIZE);
                ctx.lineTo(canvas.width, i * TETRIS_BLOCK_SIZE);
                ctx.stroke();
            }

            // Display Level and Lines Cleared (optional, for Tetris specific)
            ctx.fillStyle = '#00ff41';
            ctx.font = '16px "Courier New", monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`Level: ${gameState.level}`, 5, 20);
            ctx.fillText(`Lines: ${gameState.linesCleared}`, 5, 40);
        }
        // --- End Tetris Game ---

        // --- Minesweeper Game ---
        const MINE_CELL_SIZE = 30;

        function initMinesweeper() {
            gameState = {
                rows: 16, // Default rows
                cols: 16, // Default columns
                mines: 40, // Default number of mines
                board: [], // -1 for mine, 0-8 for surrounding mines
                revealed: [], // true if cell is revealed
                flagged: [], // true if cell is flagged
                gameOver: false,
                gameWon: false,
                startTime: 0,
                timer: 0,
                minesRemaining: 0
            };

            // Set canvas size based on game board dimensions
            canvas.width = gameState.cols * MINE_CELL_SIZE;
            canvas.height = gameState.rows * MINE_CELL_SIZE;

            // Ensure canvas is positioned correctly for Minesweeper, if its size is different
            canvas.style.marginLeft = 'auto';
            canvas.style.marginRight = 'auto';
            canvas.style.width = canvas.width + 'px'; // Set exact width
            canvas.style.height = canvas.height + 'px'; // Set exact height

            // Initialize board, revealed, and flagged arrays
            for (let r = 0; r < gameState.rows; r++) {
                gameState.board.push(Array(gameState.cols).fill(0));
                gameState.revealed.push(Array(gameState.cols).fill(false));
                gameState.flagged.push(Array(gameState.cols).fill(false));
            }

            placeMines();
            calculateMineCounts();

            gameState.minesRemaining = gameState.mines;
            document.getElementById('mineCountDisplay').textContent = `Mines: ${gameState.minesRemaining}`;
            document.getElementById('timerDisplay').textContent = `Time: 0s`;

            // Add event listeners specific to Minesweeper
            canvas.addEventListener('click', handleMinesweeperClick);
            canvas.addEventListener('contextmenu', handleMinesweeperRightClick); // For right-click to flag

            gameState.startTime = Date.now(); // Start timer
            gameState.timer = 0;
        }

        function placeMines() {
            let minesPlaced = 0;
            while (minesPlaced < gameState.mines) {
                const r = Math.floor(Math.random() * gameState.rows);
                const c = Math.floor(Math.random() * gameState.cols);
                if (gameState.board[r][c] !== -1) { // If no mine is already there
                    gameState.board[r][c] = -1; // Place a mine
                    minesPlaced++;
                }
            }
        }

        function calculateMineCounts() {
            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] === -1) continue; // Skip if it's a mine

                    let count = 0;
                    // Check all 8 surrounding cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue; // Skip the cell itself

                            const nr = r + dr;
                            const nc = c + dc;

                            // Check bounds and if the neighbor is a mine
                            if (
                                nr >= 0 && nr < gameState.rows &&
                                nc >= 0 && nc < gameState.cols &&
                                gameState.board[nr][nc] === -1
                            ) {
                                count++;
                            }
                        }
                    }
                    gameState.board[r][c] = count;
                }
            }
        }

        function handleMinesweeperClick(event) {
            if (gameState.gameOver || gameState.gameWon || !canvas || document.getElementById('messageBox').style.display === 'block') return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const c = Math.floor(x / MINE_CELL_SIZE);
            const r = Math.floor(y / MINE_CELL_SIZE);

            // Basic bounds check
            if (r < 0 || r >= gameState.rows || c < 0 || c >= gameState.cols) {
                return;
            }

            // Left click (reveal)
            if (event.button === 0) { // 0 for left click
                if (!gameState.revealed[r][c] && !gameState.flagged[r][c]) {
                    revealCell(r, c);
                }
            }
            checkMinesweeperWin();
        }

        function handleMinesweeperRightClick(event) {
            event.preventDefault(); // Prevent context menu from appearing
            if (gameState.gameOver || gameState.gameWon || !canvas || document.getElementById('messageBox').style.display === 'block') return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const c = Math.floor(x / MINE_CELL_SIZE);
            const r = Math.floor(y / MINE_CELL_SIZE);

            // Basic bounds check
            if (r < 0 || r >= gameState.rows || c < 0 || c >= gameState.cols) {
                return;
            }

            // Right click (flag)
            if (!gameState.revealed[r][c]) { // Can only flag unrevealed cells
                gameState.flagged[r][c] = !gameState.flagged[r][c]; // Toggle flag
                gameState.minesRemaining += (gameState.flagged[r][c] ? -1 : 1); // Update mine count
                document.getElementById('mineCountDisplay').textContent = `Mines: ${gameState.minesRemaining}`;
            }
            checkMinesweeperWin();
        }


        // Recursive function to reveal cells
        function revealCell(r, c) {
            // Base cases for recursion: out of bounds, already revealed, or flagged
            if (r < 0 || r >= gameState.rows || c < 0 || c >= gameState.cols ||
                gameState.revealed[r][c] || gameState.flagged[r][c]) {
                return;
            }

            gameState.revealed[r][c] = true; // Mark as revealed

            if (gameState.board[r][c] === -1) {
                // Hit a mine! Game Over
                gameState.gameOver = true;
                gameOver('lost'); // Call the general gameOver function
                revealAllMines(); // Show all mines
                return;
            }

            if (gameState.board[r][c] === 0) {
                // If it's an empty cell (0 mines around), recursively reveal neighbors
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        revealCell(r + dr, c + dc);
                    }
                }
            }
            // If it's a numbered cell, just reveal it (recursion stops here)
        }

        function revealAllMines() {
            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] === -1) {
                        gameState.revealed[r][c] = true; // Show all mines
                        gameState.flagged[r][c] = false; // Unflag any incorrectly flagged mines for display
                    }
                }
            }
        }

        function checkMinesweeperWin() {
            let nonMineCellsRevealed = 0;
            let totalNonMineCells = (gameState.rows * gameState.cols) - gameState.mines;

            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] !== -1 && gameState.revealed[r][c]) {
                        nonMineCellsRevealed++;
                    }
                }
            }

            if (nonMineCellsRevealed === totalNonMineCells && !gameState.gameOver) {
                gameState.gameWon = true;
                gameOver('won'); // Call general gameOver function with 'won' status
                revealAllMines(); // For aesthetics, show all mines when won (they should be flagged)
            }
        }

        function updateMinesweeper(deltaTime) {
            if (!gameState.gameOver && !gameState.gameWon) {
                gameState.timer = Math.floor((Date.now() - gameState.startTime) / 1000);
                document.getElementById('timerDisplay').textContent = `Time: ${gameState.timer}s`;
            }
        }

        function drawMinesweeper() {
            if (!ctx) return;
            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    const x = c * MINE_CELL_SIZE;
                    const y = r * MINE_CELL_SIZE;

                    // Draw cell background
                    if (gameState.revealed[r][c]) {
                        ctx.fillStyle = '#333'; // Darker for revealed cells
                        ctx.fillRect(x, y, MINE_CELL_SIZE, MINE_CELL_SIZE);
                        if (gameState.board[r][c] === -1) {
                            // Draw mine (black circle with white cross)
                            ctx.fillStyle = '#ff0041'; // Red for mine
                            ctx.beginPath();
                            ctx.arc(x + MINE_CELL_SIZE / 2, y + MINE_CELL_SIZE / 2, MINE_CELL_SIZE / 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x + MINE_CELL_SIZE / 2, y + MINE_CELL_SIZE / 4);
                            ctx.lineTo(x + MINE_CELL_SIZE / 2, y + MINE_CELL_SIZE * 3 / 4);
                            ctx.moveTo(x + MINE_CELL_SIZE / 4, y + MINE_CELL_SIZE / 2);
                            ctx.lineTo(x + MINE_CELL_SIZE * 3 / 4, y + MINE_CELL_SIZE / 2);
                            ctx.stroke();
                        } else if (gameState.board[r][c] > 0) {
                            // Draw number of adjacent mines
                            const num = gameState.board[r][c];
                            const colors = ['#0000ff', '#008000', '#ff0000', '#000080', '#800000', '#008080', '#000', '#808080']; // Colors for numbers 1-8
                            ctx.fillStyle = colors[num - 1]; // Get color based on number
                            ctx.font = `${MINE_CELL_SIZE * 0.7}px 'Courier New', monospace`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(num.toString(), x + MINE_CELL_SIZE / 2, y + MINE_CELL_SIZE / 2);
                        }
                    } else {
                        // Draw unrevealed cell
                        ctx.fillStyle = '#666'; // Gray for unrevealed cells
                        ctx.fillRect(x, y, MINE_CELL_SIZE, MINE_CELL_SIZE);
                        if (gameState.flagged[r][c]) {
                            // Draw flag
                            ctx.fillStyle = '#ffff00'; // Yellow flag
                            ctx.beginPath();
                            ctx.moveTo(x + MINE_CELL_SIZE * 0.2, y + MINE_CELL_SIZE * 0.8);
                            ctx.lineTo(x + MINE_CELL_SIZE * 0.2, y + MINE_CELL_SIZE * 0.2);
                            ctx.lineTo(x + MINE_CELL_SIZE * 0.8, y + MINE_CELL_SIZE * 0.3);
                            ctx.lineTo(x + MINE_CELL_SIZE * 0.2, y + MINE_CELL_SIZE * 0.4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                    ctx.strokeStyle = '#000'; // Cell borders
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, MINE_CELL_SIZE, MINE_CELL_SIZE);
                }
            }
        }
        // --- End Minesweeper Game ---

        // --- Galactic Invaders Game ---
        const PLAYER_SPEED = 200; // Pixels per second
        const PLAYER_BULLET_SPEED = 600; 
        const PLAYER_SHOOT_COOLDOWN = 0.5; // seconds

        const ENEMY_NORMAL_SPEED_X = 50; // Horizontal speed when not diving
        const ENEMY_NORMAL_SPEED_Y = 20; // Vertical drop when changing direction
        const ENEMY_DIVE_SPEED = 200; // Faster vertical speed when diving
        const ENEMY_BULLET_SPEED = 150;
        const ENEMY_BASE_SHOULD_SHOOT_CHANCE = 0.0005; // Per enemy per frame (lower base)
        const ENEMY_BASE_RAM_CHANCE = 0.00001; // EVEN MORE SIGNIFICANTLY LOWER BASE for ramming

        function initGalacticInvaders() {
            canvas.width = 600; // Set canvas dimensions for Galactic Invaders
            canvas.height = 700;
            canvas.style.width = '600px'; // Ensure fixed size for this game
            canvas.style.height = '700px';
            canvas.style.marginLeft = 'auto';
            canvas.style.marginRight = 'auto';

            gameState = {
                player: {
                    x: canvas.width / 2,
                    y: canvas.height - 50,
                    width: 40,
                    height: 20,
                    lastShotTime: 0,
                    canShoot: true,
                    isDestroyed: false, // true when player is exploded
                    isInvincible: false, // true during invincibility period
                    invincibilityTimer: 0, // counts down invincibility time
                    invincibilityDuration: 2, // 2 seconds of invincibility after respawn
                    blinkInterval: 0.1 // For visual blinking during invincibility
                },
                playerBullets: [],
                enemies: [],
                enemyBullets: [],
                score: 0,
                lives: 3,
                wave: 1,
                enemyDirection: 1, // 1 for right, -1 for left
                enemyAdvanceTimer: 0,
                enemyAdvanceInterval: 2, // seconds
                waveOscillationAmplitude: 5, // How much enemies move up/down
                waveOscillationFrequency: 5, // How fast they oscillate
                currentEnemyShootChance: ENEMY_BASE_SHOULD_SHOOT_CHANCE,
                currentEnemyRamChance: ENEMY_BASE_RAM_CHANCE,
                explosions: [], // stores active explosion animations
                explosionDuration: 0.5 // duration of explosion animation
            };
            
            spawnEnemyWave();
            updateGalacticInvadersScoreAndLives(); // Initialize UI
        }

        // Draw Player Ship (more detailed)
        function drawPlayerShip(player) {
            // Implement blinking during invincibility
            const currentTimeSeconds = performance.now() / 1000;
            if (player.isInvincible && Math.floor(currentTimeSeconds / player.blinkInterval) % 2 === 0) {
                return; // Don't draw if blinking off
            }

            ctx.fillStyle = '#00ff41'; // Green ship body
            ctx.strokeStyle = '#00cc00'; // Darker green outline
            ctx.lineWidth = 2;

            ctx.beginPath();
            // Main body
            ctx.moveTo(player.x, player.y - player.height); // Top point
            ctx.lineTo(player.x - player.width / 2, player.y + player.height / 2); // Bottom-left
            ctx.lineTo(player.x + player.width / 2, player.y + player.height / 2); // Bottom-right
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Cockpit (small rectangle on top)
            ctx.fillStyle = '#00ffff'; // Cyan for cockpit
            ctx.fillRect(player.x - player.width / 8, player.y - player.height * 0.8, player.width / 4, player.height / 3);
            ctx.strokeStyle = '#00aaaa';
            ctx.strokeRect(player.x - player.width / 8, player.y - player.height * 0.8, player.width / 4, player.height / 3);

            // Left wing (simple triangle)
            ctx.fillStyle = '#88ff88'; // Lighter green for wings
            ctx.beginPath();
            ctx.moveTo(player.x - player.width / 2, player.y + player.height / 2);
            ctx.lineTo(player.x - player.width / 2 - 10, player.y + player.height / 2);
            ctx.lineTo(player.x - player.width / 2, player.y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Right wing
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y + player.height / 2);
            ctx.lineTo(player.x + player.width / 2 + 10, player.y + player.height / 2);
            ctx.lineTo(player.x + player.width / 2, player.y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Thrusters (rectangles at the back)
            ctx.fillStyle = '#ff8800'; // Orange for thrusters
            ctx.fillRect(player.x - player.width / 4, player.y + player.height / 2, player.width / 8, 5);
            ctx.fillRect(player.x + player.width / 8, player.y + player.height / 2, player.width / 8, 5);
        }

        // Draw Enemy Ship (more detailed)
        function drawEnemyShip(enemy) {
            ctx.fillStyle = enemy.color;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;

            ctx.beginPath();
            // Main body (oval-like or small spaceship)
            ctx.ellipse(enemy.x, enemy.y, enemy.width / 2, enemy.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Wings/Fins
            ctx.beginPath();
            ctx.moveTo(enemy.x - enemy.width / 2, enemy.y);
            ctx.lineTo(enemy.x - enemy.width / 2 - 5, enemy.y + enemy.height / 3);
            ctx.lineTo(enemy.x - enemy.width / 2, enemy.y + enemy.height / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(enemy.x + enemy.width / 2, enemy.y);
            ctx.lineTo(enemy.x + enemy.width / 2 + 5, enemy.y + enemy.height / 3);
            ctx.lineTo(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Cockpit/Eye
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y - enemy.height / 4, 3, 0, Math.PI * 2);
            ctx.fill();

            // Antennae
            ctx.strokeStyle = '#eee';
            ctx.beginPath();
            ctx.moveTo(enemy.x - enemy.width / 4, enemy.y - enemy.height / 2);
            ctx.lineTo(enemy.x - enemy.width / 4 - 5, enemy.y - enemy.height / 2 - 5);
            ctx.moveTo(enemy.x + enemy.width / 4, enemy.y - enemy.height / 2);
            ctx.lineTo(enemy.x + enemy.width / 4 + 5, enemy.y - enemy.height / 2 - 5);
            ctx.stroke();
        }

        // New function to draw an explosion
        function drawExplosion(explosion, totalDuration) {
            if (!ctx) return;
            const progress = 1 - (explosion.timer / totalDuration); // 0 (start) to 1 (end)
            const maxRadius = 30;
            const currentRadius = maxRadius * progress;
            const alpha = 1 - progress; // Fades out

            ctx.save();
            ctx.globalAlpha = alpha;

            // Outer circle (orange/red)
            ctx.fillStyle = `rgba(255, ${Math.floor(165 * (1 - progress))}, 0, ${alpha})`;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();

            // Inner circle (yellow/white)
            ctx.fillStyle = `rgba(255, 255, ${Math.floor(100 * (1 - progress))}, ${alpha * 0.8})`;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, currentRadius * 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }


        function spawnEnemyWave() {
            gameState.enemies = [];
            const baseEnemyRows = 3; 
            const maxEnemyRows = 7; 
            const baseEnemiesPerRow = 6; 
            
            // Calculate actual rows and enemies per row, increasing with wave
            const enemyRows = Math.min(baseEnemyRows + Math.floor((gameState.wave - 1) / 2), maxEnemyRows); 
            const enemiesPerRow = Math.min(baseEnemiesPerRow + Math.floor((gameState.wave - 1) * 0.75), 10); // More enemies per wave, up to max 10

            const enemyWidth = 30;
            const enemyHeight = 20;
            const horizontalSpacing = 15; // Increased spacing
            const verticalSpacing = 20; // Spacing between rows

            // Calculate total width of the enemy group
            const totalGroupWidth = enemiesPerRow * enemyWidth + (enemiesPerRow - 1) * horizontalSpacing;
            // Calculate starting X to center the entire group of enemies
            const startX = (canvas.width - totalGroupWidth) / 2;
            const offsetY = 50;

            // Increase ramming and shooting chances with each wave
            gameState.currentEnemyShootChance = ENEMY_BASE_SHOULD_SHOOT_CHANCE * (1 + (gameState.wave - 1) * 0.1); 
            // Significantly increase ram chance with each wave for a more aggressive feel
            gameState.currentEnemyRamChance = ENEMY_BASE_RAM_CHANCE * (1 + (gameState.wave - 1) * 0.5); 

            for (let r = 0; r < enemyRows; r++) { 
                for (let c = 0; c < enemiesPerRow; c++) {
                    gameState.enemies.push({
                        x: startX + c * (enemyWidth + horizontalSpacing) + (Math.random() * 10 - 5), // Add small random offset
                        y: offsetY + r * (enemyHeight + verticalSpacing) + (Math.random() * 10 - 5), // Add small random offset
                        initialY: offsetY + r * (enemyHeight + verticalSpacing), // Store initial Y for oscillation
                        width: enemyWidth,
                        height: enemyHeight,
                        color: `hsl(${Math.random() * 360}, 80%, 70%)`, 
                        isDiving: false,
                        diveTargetX: 0 
                    });
                }
            }
        }

        function firePlayerBullet() {
            const currentTime = performance.now() / 1000;
            if (currentTime - gameState.player.lastShotTime > PLAYER_SHOOT_COOLDOWN) {
                gameState.playerBullets.push({
                    x: gameState.player.x,
                    y: gameState.player.y - gameState.player.height / 2,
                    radius: 3,
                    vy: -PLAYER_BULLET_SPEED
                });
                gameState.player.lastShotTime = currentTime;
            }
        }

        function updateGalacticInvaders(deltaTime) {
            const currentTimeSeconds = performance.now() / 1000;

            // Update player invincibility
            if (gameState.player.isInvincible) {
                gameState.player.invincibilityTimer -= deltaTime;
                if (gameState.player.invincibilityTimer <= 0) {
                    gameState.player.isInvincible = false;
                }
            }

            // Player movement
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) {
                gameState.player.x -= PLAYER_SPEED * deltaTime;
            }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) {
                gameState.player.x += PLAYER_SPEED * deltaTime;
            }
            // Clamp player position
            gameState.player.x = Math.max(gameState.player.width / 2, Math.min(canvas.width - gameState.player.width / 2, gameState.player.x));

            // Player bullets update
            gameState.playerBullets = gameState.playerBullets.filter(bullet => {
                bullet.y += bullet.vy * deltaTime;
                return bullet.y > 0;
            });

            // Enemy movement and shooting/diving
            gameState.enemyAdvanceTimer += deltaTime;
            let advanceDown = false;
            let hitWallThisFrame = false;

            if (gameState.enemyAdvanceTimer >= gameState.enemyAdvanceInterval) {
                gameState.enemyAdvanceTimer = 0;
                // Check if enemies hit side walls for group movement
                for (const enemy of gameState.enemies) {
                    if (!enemy.isDiving && ((gameState.enemyDirection === 1 && enemy.x + enemy.width / 2 >= canvas.width - 10) ||
                                            (gameState.enemyDirection === -1 && enemy.x - enemy.width / 2 <= 10))) {
                        hitWallThisFrame = true;
                        break;
                    }
                }

                if (hitWallThisFrame) {
                    gameState.enemyDirection *= -1; // Reverse global direction
                    advanceDown = true; // Signal for all non-diving enemies to move down
                }
            }

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];

                if (enemy.isDiving) {
                    // Diving behavior
                    enemy.y += ENEMY_DIVE_SPEED * deltaTime;
                    // Move towards dive target X
                    const dx = enemy.diveTargetX - enemy.x;
                    if (Math.abs(dx) > 5) { // Only adjust X if not very close
                        enemy.x += Math.sign(dx) * ENEMY_DIVE_SPEED * 0.5 * deltaTime; // Horizontal chase during dive
                    }
                    
                    // If diving enemy goes below the canvas, reset to top and continue dive
                    if (enemy.y - enemy.height / 2 > canvas.height) {
                        enemy.y = -enemy.height / 2; // Reset to just above top
                        enemy.x = gameState.player.x; // Target player's current X for the new dive
                        enemy.diveTargetX = gameState.player.x; // Update target for next dive
                    }
                } else {
                    // Normal formation movement
                    enemy.x += gameState.enemyDirection * ENEMY_NORMAL_SPEED_X * deltaTime;
                    if (advanceDown) {
                        enemy.initialY += ENEMY_NORMAL_SPEED_Y; // Update base Y for next oscillation cycle
                    }
                    // Apply oscillation based on current time and initial Y
                    enemy.y = enemy.initialY + Math.sin(currentTimeSeconds * gameState.waveOscillationFrequency + enemy.x / 50) * gameState.waveOscillationAmplitude;

                    // Enemy decision: Dive or Shoot
                    if (Math.random() < gameState.currentEnemyRamChance) { // Use dynamic ram chance
                        enemy.isDiving = true;
                        enemy.diveTargetX = gameState.player.x; // Set target X when dive starts
                    } else if (Math.random() < gameState.currentEnemyShootChance) { // Use dynamic shoot chance
                        gameState.enemyBullets.push({
                            x: enemy.x,
                            y: enemy.y + enemy.height / 2,
                            radius: 3,
                            vy: ENEMY_BULLET_SPEED
                        });
                    }

                    // Enemy reaches player's base line - game over (if not already handled by collision)
                    if (enemy.y + enemy.height / 2 >= canvas.height - gameState.player.height * 2) {
                        gameOver();
                        return;
                    }
                }
            }


            // Enemy bullets update
            gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                bullet.y += bullet.vy * deltaTime;
                return bullet.y < canvas.height;
            });

            // Collision detection (Player Bullets vs Enemies)
            for (let i = gameState.playerBullets.length - 1; i >= 0; i--) {
                const pBullet = gameState.playerBullets[i];
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    // Simple AABB (Axis-Aligned Bounding Box) collision for rect vs circle approx
                    const closestX = Math.max(enemy.x - enemy.width / 2, Math.min(pBullet.x, enemy.x + enemy.width / 2));
                    const closestY = Math.max(enemy.y - enemy.height / 2, Math.min(pBullet.y, enemy.y + pBullet.radius)); 
                    const dx = pBullet.x - closestX;
                    const dy = pBullet.y - closestY;
                    const distanceSq = (dx * dx) + (dy * dy);

                    if (distanceSq < (pBullet.radius * pBullet.radius)) { // Collision detected
                        gameState.playerBullets.splice(i, 1);
                        gameState.enemies.splice(j, 1);
                        gameState.score += 100;
                        updateGalacticInvadersScoreAndLives();
                        break; 
                    }
                }
            }

            // Collision detection (Enemy Bullets/Enemies vs Player)
            // Only check collision if player is not invincible or already destroyed
            if (!gameState.player.isInvincible && !gameState.player.isDestroyed) {
                // Enemy Bullets vs Player
                for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                    const eBullet = gameState.enemyBullets[i];
                    const dx = gameState.player.x - eBullet.x;
                    const dy = gameState.player.y - eBullet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < gameState.player.width / 2 + eBullet.radius) { 
                        gameState.enemyBullets.splice(i, 1); // Remove bullet
                        handlePlayerHit();
                        return; // Exit loop after hit
                    }
                }
                // Ramming Enemy collisions with player
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    if (enemy.isDiving) { 
                        const dx = gameState.player.x - enemy.x;
                        const dy = gameState.player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        const playerApproxRadius = Math.max(gameState.player.width, gameState.player.height) / 2;
                        const enemyApproxRadius = Math.max(enemy.width, enemy.height) / 2;

                        if (distance < playerApproxRadius + enemyApproxRadius) {
                            gameState.enemies.splice(i, 1); // Remove enemy on collision
                            handlePlayerHit();
                            return; // Exit loop after hit
                        }
                    }
                }
            }

            // Update explosions
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                explosion.timer -= deltaTime;
                if (explosion.timer <= 0) {
                    gameState.explosions.splice(i, 1);
                }
            }

            // Check if all enemies are defeated for next wave
            if (gameState.enemies.length === 0) {
                gameState.wave++;
                spawnEnemyWave();
            }
        }

        // New function to handle player getting hit
        function handlePlayerHit() {
            gameState.lives--;
            updateGalacticInvadersScoreAndLives();

            if (gameState.lives <= 0) {
                gameState.player.isDestroyed = true; // Ensure player is hidden for game over explosion
                gameState.explosions.push({ x: gameState.player.x, y: gameState.player.y, timer: gameState.explosionDuration });
                gameOver();
            } else {
                gameState.player.isDestroyed = true; // Hide player ship
                gameState.explosions.push({ x: gameState.player.x, y: gameState.player.y, timer: gameState.explosionDuration });
                
                // Set a timeout to respawn the player after the explosion animation
                setTimeout(() => {
                    gameState.player.isDestroyed = false; // Make player visible again
                    gameState.player.x = canvas.width / 2; // Respawn at center
                    gameState.player.y = canvas.height - 50;
                    gameState.player.isInvincible = true; // Start invincibility
                    gameState.player.invincibilityTimer = gameState.player.invincibilityDuration;
                }, gameState.explosionDuration * 1000); // Convert seconds to milliseconds
            }
        }

        function drawGalacticInvaders() {
            // Player Ship (only draw if not destroyed and handling blinking)
            if (!gameState.player.isDestroyed) {
                drawPlayerShip(gameState.player);
            }
            
            // Draw explosions
            gameState.explosions.forEach(explosion => drawExplosion(explosion, gameState.explosionDuration));

            // Player Bullets
            ctx.fillStyle = '#00ffff'; // Cyan bullets
            gameState.playerBullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Enemies
            gameState.enemies.forEach(enemy => {
                drawEnemyShip(enemy);
            });

            // Enemy Bullets
            ctx.fillStyle = '#ff0041'; // Red bullets
            gameState.enemyBullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function updateGalacticInvadersScoreAndLives() {
            document.getElementById('galacticScoreDisplay').textContent = `Score: ${gameState.score}`;
            document.getElementById('galacticLivesDisplay').textContent = `Lives: ${gameState.lives}`;
            document.getElementById('galacticWaveDisplay').textContent = `Wave: ${gameState.wave}`; // Update wave display
        }
        // --- End Galactic Invaders Game ---


        // Initial setup on window load
        window.addEventListener('load', () => {
            createStars();
            document.getElementById('gameSelection').style.display = 'grid'; // Show game selection menu initially
            document.getElementById('gameArea').style.display = 'none'; // Hide game area initially
            document.getElementById('gameOverOverlay').classList.remove('active'); // Hide game over overlay
            document.getElementById('messageBox').style.display = 'none'; // Hide message box
            document.getElementById('mainHeader').style.display = 'block'; // Ensure header is shown on initial load
            // Explicitly hide game title on initial load until a game starts
            document.getElementById('gameTitle').style.display = 'none'; 
            updateScore(); // Initial update for score display (will show Score: 0)
        });

        // Re-create stars on window resize to ensure full coverage
        window.addEventListener('resize', createStars);
    </script>
</body>
</html>
