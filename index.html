<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroArcade - Play Games Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            color: #00ff41;
            min-height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        .container {
            position: relative;
            z-index: 2;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff41;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            width: 100%;
            max-width: 650px;
        }
        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff41;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px #00ff41; }
            to { text-shadow: 0 0 20px #00ff41, 0 0 30px #00ff41; }
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
            width: 100%;
        }
        .game-card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .game-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 65, 0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }
        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
        }
        .game-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 30px rgba(0, 255, 65, 0.4);
            border-color: #00ffff;
        }
        .game-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #00ffff;
        }
        .game-description {
            margin-bottom: 20px;
            opacity: 0.9;
            line-height: 1.4;
        }
        .play-btn {
            background: linear-gradient(45deg, #00ff41, #00ffff);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: #000;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.5);
        }
        .game-area {
            display: none;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            width: 100%;
            max-width: 650px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .game-canvas {
            border: 2px solid #00ffff;
            border-radius: 10px;
            background: #000;
            margin: 20px auto;
            display: block;
        }

        .game-controls {
            margin: 20px 0;
            text-align: center;
        }
        .control-btn {
            background: #00ff41;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .control-btn:hover {
            background: #00ffff;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.5);
        }

        .score {
            font-size: 1.3rem;
            margin: 10px 0;
            color: #00ffff;
        }
        .action-buttons {
            margin-top: 15px;
        }
        .back-btn {
            background: #ff4444;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
        }
        .back-btn:hover {
            background: #ff6666;
        }
        
        /* Game Over Overlay Styles */
        .game-over-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #00ff41;
            text-align: center;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(5px);
        }
        .game-over-overlay.active {
            display: flex;
        }
        .game-over-content {
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff0041;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 0 30px rgba(255, 0, 65, 0.6);
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes heartbeat {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .game-over-content p {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #00ffff;
        }
        .game-over-buttons button {
            background: linear-gradient(45deg, #00ff41, #00ffff);
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            color: #000;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .game-over-buttons button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .games-grid { grid-template-columns: 1fr; }
            .game-canvas { width: 100%; max-width: 350px; }
            .game-over-content {
                padding: 20px;
                margin: 0 15px;
            }
            .game-over-content h2 {
                font-size: 2rem;
            }
            .game-over-content p {
                font-size: 1.2rem;
            }
            .game-over-buttons button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>

    <div class="container">
        <header>
            <h1>üéÆ RETROARCADE üéÆ</h1>
            <p class="subtitle">Classic Games Reimagined for the Web</p>
        </header>

        <div id="gameSelection" class="games-grid">
            <div class="game-card" onclick="startGame('dino')">
                <h3 class="game-title">ü¶ñ Prehistoric Run</h3>
                <p class="game-description">Leap over cacti and dodge pterodactyls in this endless runner classic. How long can you survive the ancient world? Press SPACE to jump!</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('snake')">
                <h3 class="game-title">üêç Neon Snake</h3>
                <p class="game-description">Guide the glowing serpent through the digital void. Collect energy orbs to grow longer, but don't crash into yourself! Use WASD or Arrow Keys.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('pong')">
                <h3 class="game-title">‚ö° Cyber Pong</h3>
                <p class="game-description">The classic paddle game with a futuristic twist. Can you beat the AI opponent in this high-speed digital duel? Use W/S or ‚Üë/‚Üì arrows.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('asteroids')">
                <h3 class="game-title">üí´ Space Rocks</h3>
                <p class="game-description">Navigate your ship through a dangerous asteroid field. Blast the rocks to survive and rack up points! Use WASD to move, SPACE to shoot.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('breakout')">
                <h3 class="game-title">üß± Block Destroyer</h3>
                <p class="game-description">Break through the neon barrier with your energy ball. Clear all blocks to advance to the next level! Use A/D or ‚Üê/‚Üí arrows.</p>
                <button class="play-btn">Play Now</button>
            </div>
            <div class="game-card" onclick="startGame('tetris')">
                <h3 class="game-title">üü¶ Pixel Tetris</h3>
                <p class="game-description">Arrange falling blocks to form complete lines and clear them. Don't let the stack reach the top! Use Arrow Keys or WASD to move and rotate.</p>
                <button class="play-btn">Play Now</button>
            </div>
        </div>

        <div id="gameArea" class="game-area">
            <h2 id="gameTitle"></h2>
            <div class="score" id="scoreDisplay">Score: 0</div>
            <canvas id="gameCanvas" class="game-canvas" width="600" height="400"></canvas>
            <div class="game-controls" id="gameControls"></div>
            <div class="action-buttons">
                <button class="control-btn" id="restartGameButton" onclick="restartGame()" style="background: #ffaa00; margin-right: 10px;">üîÑ Restart Game</button>
                <button class="back-btn" id="backToMenuButton" onclick="backToMenu()">‚Üê Back to Games</button>
            </div>
        </div>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay">
        <div class="game-over-content">
            <h2>GAME OVER!</h2>
            <p id="finalScoreDisplay">Final Score: 0</p>
            <div class="game-over-buttons">
                <button onclick="restartGameFromGameOver()">Play Again</button>
                <button onclick="backToMenuFromGameOver()">Back to Menu</button>
            </div>
        </div>
    </div>

    <script>
        // Create animated stars background
        function createStars() {
            const starsContainer = document.getElementById('stars');
            starsContainer.innerHTML = ''; // Clear existing stars
            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = Math.random() * 3 + 1 + 'px';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        let currentGame = null;
        let animationFrameId = null; // Stores the requestAnimationFrame ID
        let canvas, ctx;
        const originalCanvasWidth = 600;
        const originalCanvasHeight = 400; // Updated to match your canvas size

        let score = 0;
        let gameState = {}; // Holds game-specific variables for the current game

        // --- Keyboard Input Tracking ---
        const keysPressed = new Set(); // Tracks which keys are currently held down

        document.addEventListener('keydown', (e) => {
            if (currentGame && !document.getElementById('gameOverOverlay').classList.contains('active')) {
                const lowerKey = e.key.toLowerCase();
                // Prevent default browser behavior for relevant keys
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd'].includes(lowerKey)) {
                    e.preventDefault();
                }
                keysPressed.add(lowerKey);

                // --- Game-specific input handling ---
                switch (currentGame) {
                    case 'snake':
                        if (lowerKey === 'arrowup' || lowerKey === 'w') {
                            changeDirection('up');
                        } else if (lowerKey === 'arrowdown' || lowerKey === 's') {
                            changeDirection('down');
                        } else if (lowerKey === 'arrowleft' || lowerKey === 'a') {
                            changeDirection('left');
                        } else if (lowerKey === 'arrowright' || lowerKey === 'd') {
                            changeDirection('right');
                        }
                        break;
                    case 'dino':
                        if (lowerKey === ' ' && !gameState.dino.isJumping) {
                            gameState.dino.jump();
                        }
                        break;
                    case 'pong':
                        // Pong movement is continuous, controlled by keysPressed in updatePong
                        break;
                    case 'asteroids': // Asteroids input
                         if (lowerKey === ' ') {
                            // lastShotTimeAsteroids is used in shootBulletAsteroids to handle cooldown
                            // shootBulletAsteroids will check cooldown internally
                            shootBulletAsteroids();
                        }
                        // Thrust and rotation are handled by checking keysPressed in updateAsteroids
                        break;
                    case 'breakout': // Breakout input
                        // Paddle movement handled by keysPressed in updateBreakout
                        break;
                    case 'tetris': // Tetris input
                        // Logic for Tetris input handling is largely within updateTetris,
                        // but hard drop and rotate are triggered on keydown to prevent continuous action.
                        if (lowerKey === 'arrowup' || lowerKey === 'w') {
                            // Check if the key was just pressed, not held down
                            if (!e.repeat) {
                                rotatePiece(gameState.currentPiece, 1);
                            }
                        } else if (lowerKey === ' ') {
                            if (!e.repeat) {
                                // Hard drop: instantly move piece down as far as it can go
                                while (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY + 1)) {
                                    gameState.pieceY++;
                                }
                                lockPiece();
                            }
                        }
                        break;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed.delete(e.key.toLowerCase());
        });

        // --- Main Game Loop (requestAnimationFrame) ---
        let lastFrameTime = 0;
        function gameLoop(currentTime) {
            if (!currentGame) return; // Stop loop if no game is active

            const deltaTime = (currentTime - lastFrameTime) / 1000; // Delta time in seconds
            lastFrameTime = currentTime;

            // Clear canvas at the beginning of each frame
            ctx.fillStyle = '#000'; // Default background for all games
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw specific game
            switch(currentGame) {
                case 'dino': updateDino(deltaTime); drawDino(); break;
                case 'snake': updateSnake(deltaTime); drawSnake(); break;
                case 'pong': updatePong(deltaTime); drawPong(); break;
                case 'asteroids': updateAsteroids(deltaTime); drawAsteroids(); break;
                case 'breakout': updateBreakout(deltaTime); drawBreakout(); break;
                case 'tetris': updateTetris(deltaTime); drawTetris(); break;
            }

            // Continue the loop
            if (currentGame && !document.getElementById('gameOverOverlay').classList.contains('active')) {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function startGame(gameType) {
            // Stop any existing animation frame loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            document.getElementById('gameSelection').style.display = 'none';
            document.getElementById('gameArea').style.display = 'flex';
            document.getElementById('gameOverOverlay').classList.remove('active');

            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Reset canvas width/height to original for games that don't need specific sizes
            // This needs to happen BEFORE game-specific init, as init functions might set their own sizes.
            canvas.width = originalCanvasWidth;
            canvas.height = originalCanvasHeight;
            canvas.style.marginLeft = 'auto'; // Default to center
            canvas.style.marginRight = 'auto'; // Default to center
            canvas.style.width = 'auto'; // Reset custom width from Tetris if coming from it
            canvas.style.height = 'auto'; // Reset custom height from Tetris if coming from it


            document.getElementById('gameTitle').textContent = getGameTitle(gameType);
            setupControls(gameType); // Call setupControls to set specific instructions

            // Reset score for new game
            score = 0;
            updateScore();
            keysPressed.clear(); // Clear any lingering key states
            
            // Initialize game state specific to each game type
            gameState = {}; // Clear previous game state
            currentGame = gameType; // Set current game before initializing
            switch(gameType) {
                case 'dino': initDino(); break;
                case 'snake': initSnake(); break;
                case 'pong': initPong(); break;
                case 'asteroids': initAsteroids(); break;
                case 'breakout': initBreakout(); break;
                case 'tetris': initTetris(); break;
            }

            lastFrameTime = performance.now(); // Initialize for the first frame
            animationFrameId = requestAnimationFrame(gameLoop); // Start the new game loop
        }

        function gameOver() {
            // Stop the game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Show game over overlay
            document.getElementById('gameOverOverlay').classList.add('active');
            document.getElementById('finalScoreDisplay').textContent = `Final Score: ${score}`;

            // Optional: Handle high score for individual games if desired
            if (currentGame === 'dino') {
                let dinoHighScore = localStorage.getItem('dinoHighScore') || 0;
                if (score > dinoHighScore) {
                    localStorage.setItem('dinoHighScore', score);
                }
            } else if (currentGame === 'pong') {
                let pongHighScore = localStorage.getItem('pongHighScore') || 0;
                if (score > pongHighScore) {
                    localStorage.setItem('pongHighScore', score);
                }
            } else if (currentGame === 'asteroids') {
                let asteroidsHighScore = localStorage.getItem('asteroidsHighScore') || 0;
                if (score > asteroidsHighScore) {
                    localStorage.setItem('asteroidsHighScore', score);
                }
            } else if (currentGame === 'breakout') {
                let breakoutHighScore = localStorage.getItem('breakoutHighScore') || 0;
                if (score > breakoutHighScore) {
                    localStorage.setItem('breakoutHighScore', score);
                }
            } else if (currentGame === 'tetris') { // New: Tetris high score
                let tetrisHighScore = localStorage.getItem('tetrisHighScore') || 0;
                if (score > tetrisHighScore) {
                    localStorage.setItem('tetrisHighScore', score);
                }
            }
        }


        function restartGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            score = 0;
            updateScore();
            gameState = {}; // Reset game-specific state
            keysPressed.clear(); // Clear key states on restart

            // Clear canvas visual immediately
            if (ctx) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            initializeGame(currentGame); // Re-initialize the specific game
            lastFrameTime = performance.now(); // Reset time for smooth restart
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function restartGameFromGameOver() {
            document.getElementById('gameOverOverlay').classList.remove('active');
            document.getElementById('gameArea').style.display = 'flex';
            restartGame();
        }

        function backToMenuFromGameOver() {
            document.getElementById('gameOverOverlay').classList.remove('active');
            backToMenu();
        }

        function backToMenu() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            document.getElementById('gameArea').style.display = 'none';
            document.getElementById('gameSelection').style.display = 'grid';
            currentGame = null;
            score = 0; // Reset score when going back to menu
            updateScore();
            keysPressed.clear();
        }

        function updateScore() {
            document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
        }

        function initializeGame(gameType) {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            // Canvas width/height might be overridden by game's init function
            canvas.width = originalCanvasWidth;
            canvas.height = originalCanvasHeight;
            canvas.style.marginLeft = 'auto'; // Default to center
            canvas.style.marginRight = 'auto'; // Default to center
            canvas.style.width = 'auto'; // Reset custom width from Tetris if coming from it
            canvas.style.height = 'auto'; // Reset custom height from Tetris if coming from it


            document.getElementById('gameTitle').textContent = getGameTitle(gameType);
            setupControls(gameType); // Call setupControls to set specific instructions

            // Initialize game state specific to each game type
            switch(gameType) {
                case 'dino': initDino(); break;
                case 'snake': initSnake(); break;
                case 'pong': initPong(); break;
                case 'asteroids': initAsteroids(); break;
                case 'breakout': initBreakout(); break;
                case 'tetris': initTetris(); break;
            }
        }

        function getGameTitle(gameType) {
            const titles = {
                dino: 'ü¶ñ Prehistoric Run',
                snake: 'üêç Neon Snake',
                pong: '‚ö° Cyber Pong',
                asteroids: 'üí´ Space Rocks',
                breakout: 'üß± Block Destroyer',
                tetris: 'üü¶ Pixel Tetris'
            };
            return titles[gameType];
        }

        // Updated setupControls to provide specific keyboard instructions
        function setupControls(gameType) {
            const controlsDiv = document.getElementById('gameControls');
            controlsDiv.innerHTML = ''; // Clear previous controls

            let instructions = '';
            switch (gameType) {
                case 'dino':
                    instructions = 'Press **SPACEBAR** to jump over obstacles.';
                    break;
                case 'snake':
                    instructions = 'Use **WASD** or **Arrow Keys** to change snake direction.';
                    break;
                case 'pong':
                    instructions = 'Use **W** (Up) and **S** (Down) or **‚Üë Arrow** (Up) and **‚Üì Arrow** (Down) to move your paddle.';
                    break;
                case 'asteroids':
                    instructions = 'Use **W** or **‚Üë Arrow** for thrust. Use **A** or **‚Üê Arrow** to rotate left. Use **D** or **‚Üí Arrow** to rotate right. Press **SPACEBAR** to shoot.';
                    break;
                case 'breakout':
                    instructions = 'Use **A** (Left) and **D** (Right) or **‚Üê Arrow** (Left) and **‚Üí Arrow** (Right) to move your paddle.';
                    break;
                case 'tetris':
                    instructions = 'Use **‚Üê Arrow / A** (Left), **‚Üí Arrow / D** (Right), **‚Üì Arrow / S** (Soft Drop). Use **‚Üë Arrow / W** (Rotate). Press **SPACEBAR** for Hard Drop.';
                    break;
                default:
                    instructions = 'Keyboard controls.';
            }
            controlsDiv.innerHTML = `<p>${instructions}</p>`;
        }


        // --- Dino Game ---
        // Constants for Dino game rendering
        const DINO_Y_OFFSET = 5; // Distance from the bottom of the canvas for ground line
        const DINO_HEIGHT_DEFAULT = 50; // Dino default height on the 400px canvas
        const DINO_WIDTH_DEFAULT = 30; // Dino default width
        const GROUND_LINE_Y = originalCanvasHeight - DINO_Y_OFFSET;


        function initDino() {
            // Adjust dino initial position for the 400px height canvas
            gameState.dino = {
                x: 50,
                y: GROUND_LINE_Y - DINO_HEIGHT_DEFAULT,
                width: DINO_WIDTH_DEFAULT,
                height: DINO_HEIGHT_DEFAULT,
                dy: 0,
                gravity: 0.5,
                jumpStrength: -10,
                isJumping: false,
                draw() {
                    ctx.fillStyle = '#00ff41'; // Bright green for dino
                    ctx.fillRect(this.x, this.y, this.width, this.height);

                    // Simple dino head/neck for character
                    ctx.beginPath();
                    ctx.arc(this.x + this.width, this.y + this.height * 0.2, this.width * 0.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(this.x + this.width + 5, this.y + this.height * 0.1, this.width * 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#1a1a2e'; // Eye color
                    ctx.beginPath();
                    ctx.arc(this.x + this.width + this.width * 0.4, this.y + this.height * 0.15, 2, 0, Math.PI * 2);
                    ctx.fill();
                },
                jump() {
                    if (!this.isJumping) {
                        this.dy = this.jumpStrength;
                        this.isJumping = true;
                    }
                },
                update() {
                    this.dy += this.gravity;
                    this.y += this.dy;

                    if (this.y + this.height > GROUND_LINE_Y) {
                        this.y = GROUND_LINE_Y - this.height;
                        this.dy = 0;
                        this.isJumping = false;
                    }
                }
            };

            gameState.obstacles = [];
            gameState.gameSpeed = 5;
            gameState.obstacleSpawnTimer = 0;
            gameState.obstacleSpawnInterval = 1500; // milliseconds

            // High score is now shown by the game selection page, but we store it.
            // localStorage.setItem('dinoHighScore', localStorage.getItem('dinoHighScore') || 0);
        }

        function createDinoObstacle() {
            const obstacleTypes = [
                { width: 20, height: 40, color: '#ff0041' }, // Cactus 1
                { width: 30, height: 60, color: '#ff0041' }, // Cactus 2
                { width: 45, height: 25, color: '#ff0041', isFlying: true, yOffset: 100 } // Pterodactyl-like
            ];
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];

            gameState.obstacles.push({
                x: canvas.width,
                y: type.isFlying ? (GROUND_LINE_Y - type.height - type.yOffset) : (GROUND_LINE_Y - type.height),
                width: type.width,
                height: type.height,
                color: type.color,
                draw() {
                    ctx.fillStyle = this.color;
                    // For pterodactyl, draw a simple shape
                    if (type.isFlying) {
                         ctx.beginPath();
                         ctx.moveTo(this.x, this.y + this.height * 0.5);
                         ctx.lineTo(this.x + this.width, this.y);
                         ctx.lineTo(this.x + this.width * 0.8, this.y + this.height * 0.5);
                         ctx.lineTo(this.x + this.width, this.y + this.height);
                         ctx.lineTo(this.x, this.y + this.height * 0.5);
                         ctx.fill();
                    } else {
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                }
            });
        }

        function updateDino(deltaTime) {
            // Update obstacles
            for (let i = 0; i < gameState.obstacles.length; i++) {
                gameState.obstacles[i].x -= gameState.gameSpeed;

                // Collision detection
                const dino = gameState.dino;
                const obstacle = gameState.obstacles[i];

                if (
                    dino.x < obstacle.x + obstacle.width &&
                    dino.x + dino.width > obstacle.x &&
                    dino.y < obstacle.y + obstacle.height &&
                    dino.y + dino.height > obstacle.y
                ) {
                    gameOver();
                    return; // Stop update if game over
                }
            }

            // Filter out off-screen obstacles
            gameState.obstacles = gameState.obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

            // Spawn new obstacles
            gameState.obstacleSpawnTimer += deltaTime * 1000; // Convert to milliseconds
            if (gameState.obstacleSpawnTimer > gameState.obstacleSpawnInterval && gameState.obstacles.length < 3) {
                createDinoObstacle();
                gameState.obstacleSpawnTimer = 0;
                // Gradually increase game speed and decrease spawn interval
                gameState.gameSpeed += 0.01;
                gameState.obstacleSpawnInterval = Math.max(800, gameState.obstacleSpawnInterval - 5);
            }

            // Update dino physics
            gameState.dino.update();

            // Update score
            score++;
            updateScore(); // Use the global updateScore function
        }

        function drawDino() {
            // Draw ground line
            ctx.strokeStyle = '#00ff41'; // Green ground line
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(0, GROUND_LINE_Y);
            ctx.lineTo(canvas.width, GROUND_LINE_Y);
            ctx.stroke();

            // Draw dino
            gameState.dino.draw();

            // Draw obstacles
            for (let obstacle of gameState.obstacles) {
                obstacle.draw();
            }
        }
        // --- End Dino Game ---


        // --- Snake Game ---
        function initSnake() {
            gameState = {
                snake: [{x: 10, y: 10}],
                food: {x: 15, y: 15},
                direction: {x: 1, y: 0},
                nextDirection: {x: 1, y: 0}, // For smooth input queueing
                gridSize: 20,
                speed: 10, // Grid units per second
                timeSinceLastMove: 0 // Initialize this for Snake game
            };
            spawnFood();
        }

        function updateSnake(deltaTime) {
            const moveInterval = 1 / gameState.speed; // Time in seconds for one grid unit move
            gameState.timeSinceLastMove += deltaTime;

            if (gameState.timeSinceLastMove >= moveInterval) {
                gameState.timeSinceLastMove -= moveInterval;

                gameState.direction = gameState.nextDirection;
                
                const head = {
                    x: gameState.snake[0].x + gameState.direction.x,
                    y: gameState.snake[0].y + gameState.direction.y
                };

                const maxGridX = canvas.width / gameState.gridSize;
                const maxGridY = canvas.height / gameState.gridSize;

                if (head.x < 0 || head.x >= maxGridX ||
                    head.y < 0 || head.y >= maxGridY) {
                    gameOver();
                    return;
                }

                for (let i = 1; i < gameState.snake.length; i++) {
                    const segment = gameState.snake[i];
                    if (head.x === segment.x && head.y === segment.y) {
                        gameOver();
                        return;
                    }
                }

                gameState.snake.unshift(head);

                if (head.x === gameState.food.x && head.y === gameState.food.y) {
                    score += 10;
                    updateScore();
                    // Increase speed slightly with score
                    if (gameState.speed < 20) gameState.speed += 0.5;
                    spawnFood();
                } else {
                    gameState.snake.pop();
                }
            }
        }

        function spawnFood() {
            const maxGridX = canvas.width / gameState.gridSize;
            const maxGridY = canvas.height / gameState.gridSize;
            do {
                gameState.food = {
                    x: Math.floor(Math.random() * maxGridX),
                    y: Math.floor(Math.random() * maxGridY)
                };
            } while (gameState.snake.some(segment =>
                segment.x === gameState.food.x && segment.y === gameState.food.y));
        }

        function drawSnake() {
            ctx.fillStyle = '#00ff41';
            for (let segment of gameState.snake) {
                ctx.fillRect(segment.x * gameState.gridSize, segment.y * gameState.gridSize,
                             gameState.gridSize - 2, gameState.gridSize - 2);
            }

            ctx.fillStyle = '#ff0041';
            ctx.fillRect(gameState.food.x * gameState.gridSize, gameState.food.y * gameState.gridSize,
                             gameState.gridSize - 2, gameState.gridSize - 2);
        }

        function changeDirection(dir) {
            if (!gameState || !gameState.direction) return;

            const directions = {
                up: {x: 0, y: -1},
                down: {x: 0, y: 1},
                left: {x: -1, y: 0},
                right: {x: 1, y: 0}
            };

            const newDir = directions[dir];
            if (newDir && (newDir.x !== -gameState.direction.x || newDir.y !== -gameState.direction.y)) {
                gameState.nextDirection = newDir;
            }
        }
        // --- End Snake Game ---

        // --- Pong Game ---
        function initPong() {
            gameState = {
                paddle1: {x: 10, y: canvas.height/2 - 50, width: 10, height: 100, dy: 0, speed: 200}, // speed in pixels/sec
                paddle2: {x: canvas.width - 20, y: canvas.height/2 - 50, width: 10, height: 100, speed: 150},
                ball: {x: canvas.width/2, y: canvas.height/2, dx: 275, dy: 275, radius: 8} // speed in pixels/sec
            };
            score = 0; // Reset score for Pong game
            updateScore();
        }

        function updatePong(deltaTime) {
            // Player paddle movement
            if (keysPressed.has('arrowup') || keysPressed.has('w')) {
                gameState.paddle1.y = Math.max(0, gameState.paddle1.y - gameState.paddle1.speed * deltaTime);
            }
            if (keysPressed.has('arrowdown') || keysPressed.has('s')) {
                gameState.paddle1.y = Math.min(canvas.height - gameState.paddle1.height, gameState.paddle1.y + gameState.paddle1.speed * deltaTime);
            }

            // Ball movement
            gameState.ball.x += gameState.ball.dx * deltaTime;
            gameState.ball.y += gameState.ball.dy * deltaTime;

            // Ball collision with top/bottom walls
            if (gameState.ball.y - gameState.ball.radius <= 0) {
                gameState.ball.y = gameState.ball.radius; // Reposition to avoid sticking
                gameState.ball.dy = -gameState.ball.dy;
                // Removed playSound('bounce');
            } else if (gameState.ball.y + gameState.ball.radius >= canvas.height) {
                gameState.ball.y = canvas.height - gameState.ball.radius; // Reposition to avoid sticking
                gameState.ball.dy = -gameState.ball.dy;
                // Removed playSound('bounce');
            }

            // Ball collision with paddles
            // Paddle 1 (player)
            if (gameState.ball.dx < 0 && // Moving left
                gameState.ball.x - gameState.ball.radius <= gameState.paddle1.x + gameState.paddle1.width &&
                gameState.ball.y >= gameState.paddle1.y &&
                gameState.ball.y <= gameState.paddle1.y + gameState.paddle1.height) {
                
                // Reposition the ball to prevent sticking
                gameState.ball.x = gameState.paddle1.x + gameState.paddle1.width + gameState.ball.radius;
                
                gameState.ball.dx = -gameState.ball.dx;
                gameState.ball.dy += (Math.random() * 50 - 25); // Slight random vertical deflection
                // Removed playSound('bounce');
            }
            // Paddle 2 (AI)
            else if (gameState.ball.dx > 0 && // Moving right
                gameState.ball.x + gameState.ball.radius >= gameState.paddle2.x &&
                gameState.ball.y >= gameState.paddle2.y &&
                gameState.ball.y <= gameState.paddle2.y + gameState.paddle2.height) {
                
                // Reposition the ball to prevent sticking
                gameState.ball.x = gameState.paddle2.x - gameState.ball.radius;

                gameState.ball.dx = -gameState.ball.dx;
                gameState.ball.dy += (Math.random() * 50 - 25);
                // Removed playSound('bounce');
            }

            // Ball out of bounds (score for AI or game over for player)
            if (gameState.ball.x < 0) {
                gameOver(); // Player loses a life or game over
                return;
            } else if (gameState.ball.x > canvas.width) {
                 gameState.ball.x = canvas.width/2;
                 gameState.ball.y = canvas.height/2;
                 gameState.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 180; // Reset speed and direction
                 gameState.ball.dy = (Math.random() > 0.5 ? 1 : -1) * 180;
                 score += 1; // AI scores
                 updateScore();
                 // Removed playSound('score');
            }

            // Simple AI for Paddle 2 (more responsive with deltaTime)
            const paddleCenter = gameState.paddle2.y + gameState.paddle2.height/2;
            if (gameState.ball.y < paddleCenter) {
                gameState.paddle2.y = Math.max(0, gameState.paddle2.y - gameState.paddle2.speed * deltaTime);
            } else {
                gameState.paddle2.y = Math.min(canvas.height - gameState.paddle2.height, gameState.paddle2.y + gameState.paddle2.speed * deltaTime);
            }
        }

        function drawPong() {
            ctx.fillStyle = '#00ff41'; // Player paddle color
            ctx.fillRect(gameState.paddle1.x, gameState.paddle1.y,
                         gameState.paddle1.width, gameState.paddle1.height);
            ctx.fillStyle = '#ff0041'; // AI paddle color
            ctx.fillRect(gameState.paddle2.x, gameState.paddle2.y,
                         gameState.paddle2.width, gameState.paddle2.height);

            ctx.fillStyle = '#00ffff'; // Ball color
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw center dashed line
            ctx.strokeStyle = '#00ff41';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash to avoid affecting other drawings
        }
        // --- End Pong Game ---

        // --- Asteroids Game ---
        const ASTEROIDS_SHOOT_COOLDOWN = 0.2; // seconds
        let lastShotTimeAsteroids = 0; // Global variable to track last shot time for asteroids

        function initAsteroids() {
            gameState = {
                ship: {x: canvas.width/2, y: canvas.height/2, angle: -Math.PI/2, vx: 0, vy: 0, thrust: 150, rotationSpeed: 3}, // Thrust & rotation in units/sec
                bullets: [],
                asteroids: []
            };

            for (let i = 0; i < 5; i++) {
                spawnAsteroid(3); // Start with large asteroids
            }
            score = 0; // Reset score for Asteroids game
            updateScore();
        }

        function updateAsteroids(deltaTime) {
            // Apply keyboard inputs for movement and rotation
            if (keysPressed.has('arrowup') || keysPressed.has('w')) {
                gameState.ship.vx += Math.cos(gameState.ship.angle) * gameState.ship.thrust * deltaTime;
                gameState.ship.vy += Math.sin(gameState.ship.angle) * gameState.ship.thrust * deltaTime;
            }
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) {
                gameState.ship.angle -= gameState.ship.rotationSpeed * deltaTime;
            }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) {
                gameState.ship.angle += gameState.ship.rotationSpeed * deltaTime;
            }
            // For desktop spacebar, shoot still
            // The actual shootBulletAsteroids function is called from keydown, but we keep this here
            // in case continuous firing is desired by holding down space.
            // However, current implementation calls shootBulletAsteroids on keydown only.

            // Update ship position and apply friction
            gameState.ship.x += gameState.ship.vx * deltaTime;
            gameState.ship.y += gameState.ship.vy * deltaTime;
            gameState.ship.vx *= (1 - 0.5 * deltaTime); // Friction, adjust factor as needed
            gameState.ship.vy *= (1 - 0.5 * deltaTime);

            // Wrap ship around screen edges
            if (gameState.ship.x < 0) gameState.ship.x = canvas.width;
            if (gameState.ship.x > canvas.width) gameState.ship.x = 0;
            if (gameState.ship.y < 0) gameState.ship.y = canvas.height;
            if (gameState.ship.y > canvas.height) gameState.ship.y = 0;

            // Update bullet positions and filter out-of-bounds bullets
            gameState.bullets = gameState.bullets.filter(bullet => {
                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;
                return bullet.x > -10 && bullet.x < canvas.width + 10 && bullet.y > -10 && bullet.y < canvas.height + 10;
            });

            // Update asteroid positions
            gameState.asteroids.forEach(asteroid => {
                asteroid.x += asteroid.vx * deltaTime;
                asteroid.y += asteroid.vy * deltaTime;

                if (asteroid.x < 0) asteroid.x = canvas.width;
                if (asteroid.x > canvas.width) asteroid.x = 0;
                if (asteroid.y < 0) asteroid.y = canvas.height;
                if (asteroid.y > canvas.height) asteroid.y = 0;
            });

            // Bullet-Asteroid Collision Detection
            for (let bIndex = gameState.bullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = gameState.bullets[bIndex];
                for (let aIndex = gameState.asteroids.length - 1; aIndex >= 0; aIndex--) {
                    const asteroid = gameState.asteroids[aIndex];

                    const dx = bullet.x - asteroid.x;
                    const dy = bullet.y - asteroid.y;
                    if (Math.sqrt(dx * dx + dy * dy) < asteroid.radius) {
                        gameState.bullets.splice(bIndex, 1);
                        score += 100;
                        updateScore();

                        if (asteroid.size > 1) { // Break larger asteroids into smaller ones
                            spawnAsteroid(asteroid.size - 1, asteroid.x, asteroid.y);
                            spawnAsteroid(asteroid.size - 1, asteroid.x, asteroid.y);
                        }
                        gameState.asteroids.splice(aIndex, 1);
                        break; // Break from inner loop as bullet is destroyed
                    }
                }
            }

            // Ship-Asteroid Collision Detection
            for (let asteroid of gameState.asteroids) {
                const dx = gameState.ship.x - asteroid.x;
                const dy = gameState.ship.y - asteroid.y;
                if (Math.sqrt(dx * dx + dy * dy) < asteroid.radius + 10) { // +10 for ship's rough radius
                    gameOver();
                    return; // Stop update if game over
                }
            }

            // Respawn asteroids if all are destroyed
            if (gameState.asteroids.length === 0) {
                const levelMultiplier = Math.floor(score / 500) + 1; // Increase difficulty
                for (let i = 0; i < 5 + levelMultiplier; i++) {
                    spawnAsteroid(3); // Spawn large asteroids
                }
            }
        }

        function drawAsteroids() {
            // Draw Ship
            ctx.save();
            ctx.translate(gameState.ship.x, gameState.ship.y);
            ctx.rotate(gameState.ship.angle);
            ctx.strokeStyle = '#00ff41'; // Ship color
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(15, 0);      // Nose
            ctx.lineTo(-10, -10);   // Back left
            ctx.lineTo(-5, 0);      // Middle back (for gap)
            ctx.lineTo(-10, 10);    // Back right
            ctx.closePath();
            ctx.stroke();
            ctx.restore();

            // Draw Bullets
            ctx.fillStyle = '#00ffff'; // Bullet color
            gameState.bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw Asteroids
            ctx.strokeStyle = '#ff4444'; // Asteroid color
            ctx.lineWidth = 2;
            gameState.asteroids.forEach(asteroid => {
                ctx.beginPath();
                ctx.arc(asteroid.x, asteroid.y, asteroid.radius, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        function shootBulletAsteroids() {
            const currentTime = performance.now() / 1000; // Time in seconds
            if (currentTime - lastShotTimeAsteroids > ASTEROIDS_SHOOT_COOLDOWN) {
                gameState.bullets.push({
                    x: gameState.ship.x + Math.cos(gameState.ship.angle) * 15,
                    y: gameState.ship.y + Math.sin(gameState.ship.angle) * 15,
                    vx: Math.cos(gameState.ship.angle) * 300 + gameState.ship.vx, // Bullet speed (pixels/sec) + ship's current velocity
                    vy: Math.sin(gameState.ship.angle) * 300 + gameState.ship.vy
                });
                lastShotTimeAsteroids = currentTime; // Update last shot time
            }
        }

        // Helper to spawn asteroids with different sizes
        function spawnAsteroid(size, x = null, y = null) {
            const radiusMap = {
                3: 40, // Large
                2: 25, // Medium
                1: 15  // Small
            };
            const speedMap = {
                3: 60,
                2: 90,
                1: 120
            };

            const asteroidRadius = radiusMap[size];
            const asteroidSpeed = speedMap[size];

            // If x, y are not provided (initial spawn), place randomly, avoiding ship
            let asteroidX = x !== null ? x : Math.random() * canvas.width;
            let asteroidY = y !== null ? y : Math.random() * canvas.height;

            // Ensure initial large asteroids don't spawn too close to the ship (only for initial spawn, not for broken pieces)
            if (size === 3 && x === null && gameState.ship) { // Check gameState.ship exists for first spawn
                while (Math.sqrt(Math.pow(asteroidX - gameState.ship.x, 2) + Math.pow(asteroidY - gameState.ship.y, 2)) < 150) {
                    asteroidX = Math.random() * canvas.width;
                    asteroidY = Math.random() * canvas.height;
                }
            }


            gameState.asteroids.push({
                x: asteroidX,
                y: asteroidY,
                vx: (Math.random() - 0.5) * asteroidSpeed, // Random direction
                vy: (Math.random() - 0.5) * asteroidSpeed, // Random direction
                radius: asteroidRadius,
                size: size // 3: large, 2: medium, 1: small
            });
        }
        // --- End Asteroids Game ---


        // --- Breakout Game ---
        function initBreakout() {
            gameState = {
                paddle: {x: canvas.width/2 - 50, y: canvas.height - 20, width: 100, height: 10, speed: 250}, // Pixels/sec
                ball: {x: canvas.width/2, y: canvas.height - 30, vx: 180, vy: -180, radius: 8, prevX: 0, prevY: 0}, // Added prevX, prevY
                blocks: [],
                blocksRemaining: 0
            };
            
            const blockWidth = 55;
            const blockHeight = 15;
            const blockPadding = 5;
            const blockOffsetTop = 50;
            const blocksPerRow = 10;
            const blockOffsetLeft = (canvas.width - (blocksPerRow * blockWidth + (blocksPerRow - 1) * blockPadding)) / 2;
            
            for (let row = 0; row < 5; row++) { // 'row' goes from 0 to 4
                for (let col = 0; col < blocksPerRow; col++) {
                    gameState.blocks.push({
                        x: col * (blockWidth + blockPadding) + blockOffsetLeft,
                        y: row * (blockHeight + blockPadding) + blockOffsetTop,
                        width: blockWidth,
                        height: blockHeight,
                        color: `hsl(${row * 50}, 100%, 50%)`,
                        // hits property for multi-hit blocks:
                        // For row 0 (front): 5 - 0 = 5 hits
                        // For row 1: 5 - 1 = 4 hits
                        // For row 2: 5 - 2 = 3 hits
                        // For row 3: 5 - 3 = 2 hits
                        // For row 4 (back): 5 - 4 = 1 hit
                        hits: 5 - row 
                    });
                    gameState.blocksRemaining++;
                }
            }
            score = 0; // Reset score for Breakout game
            updateScore();
        }

        // Helper function to check AABB collision
        function checkCollision(ball, rect) {
            // Check if ball is touching or overlapping rect
            return ball.x + ball.radius > rect.x &&
                   ball.x - ball.radius < rect.x + rect.width &&
                   ball.y + ball.radius > rect.y &&
                   ball.y - ball.radius < rect.y + rect.height;
        }
        
        // Helper function to get point of impact and normal
        function getCollisionResponse(ball, block) {
            let hitX = false; // Did it hit horizontally?
            let hitY = false; // Did it hit vertically?
        
            // Determine if horizontal or vertical collision occurred
            // Check if ball was outside horizontally and moved inside
            if (ball.prevX + ball.radius <= block.x && ball.x + ball.radius > block.x) { // Hit left side of block
                ball.x = block.x - ball.radius; // Reposition
                ball.vx *= -1;
                hitX = true;
            } else if (ball.prevX - ball.radius >= block.x + block.width && ball.x - ball.radius < block.x + block.width) { // Hit right side
                ball.x = block.x + block.width + ball.radius; // Reposition
                ball.vx *= -1;
                hitX = true;
            }
        
            // Check if ball was outside vertically and moved inside
            if (ball.prevY + ball.radius <= block.y && ball.y + ball.radius > block.y) { // Hit top side
                ball.y = block.y - ball.radius; // Reposition
                ball.vy *= -1;
                hitY = true;
            } else if (ball.prevY - ball.radius >= block.y + block.height && ball.y - ball.radius < block.y + block.height) { // Hit bottom side
                ball.y = block.y + block.height + ball.radius; // Reposition
                ball.vy *= -1;
                hitY = true;
            }
        
            // If it hit a corner, both hitX and hitY could be true, but prioritize the stronger axis of penetration
            // For simplicity in Breakout, usually one axis dominates.
            // This basic logic handles the most common cases correctly.
            
            return hitX || hitY; // Return true if any collision occurred
        }
        
        
        function updateBreakout(deltaTime) {
            // Paddle movement
            if (keysPressed.has('arrowleft') || keysPressed.has('a')) {
                gameState.paddle.x = Math.max(0, gameState.paddle.x - gameState.paddle.speed * deltaTime);
            }
            if (keysPressed.has('arrowright') || keysPressed.has('d')) {
                gameState.paddle.x = Math.min(canvas.width - gameState.paddle.width, gameState.paddle.x + gameState.paddle.speed * deltaTime);
            }
        
            // Store previous ball position for more accurate collision detection
            gameState.ball.prevX = gameState.ball.x;
            gameState.ball.prevY = gameState.ball.y;
        
            // Ball movement
            gameState.ball.x += gameState.ball.vx * deltaTime;
            gameState.ball.y += gameState.ball.vy * deltaTime;
        
            // Ball collision with walls
            if (gameState.ball.x - gameState.ball.radius <= 0) {
                gameState.ball.x = gameState.ball.radius; // Reposition
                gameState.ball.vx = -gameState.ball.vx;
                // Removed playSound('bounce');
            } else if (gameState.ball.x + gameState.ball.radius >= canvas.width) {
                gameState.ball.x = canvas.width - gameState.ball.radius; // Reposition
                ball.vx = -gameState.ball.vx;
                // Removed playSound('bounce');
            }
        
            if (gameState.ball.y - gameState.ball.radius <= 0) {
                gameState.ball.y = gameState.ball.radius; // Reposition
                gameState.ball.vy = -gameState.ball.vy;
                // Removed playSound('bounce');
            }
        
            // Ball collision with paddle
            // Check if ball hit the paddle from above (moving downwards)
            if (gameState.ball.vy > 0 &&
                gameState.ball.x + gameState.ball.radius > gameState.paddle.x &&
                gameState.ball.x - gameState.ball.radius < gameState.paddle.x + gameState.paddle.width &&
                gameState.ball.y + gameState.ball.radius >= gameState.paddle.y &&
                gameState.ball.prevY + gameState.ball.radius < gameState.paddle.y) // Ensure it crossed the top edge
            {
                // Reposition the ball on top of the paddle to prevent sticking
                gameState.ball.y = gameState.paddle.y - gameState.ball.radius;
            
                gameState.ball.vy = -gameState.ball.vy;
                const hitPoint = gameState.ball.x - (gameState.paddle.x + gameState.paddle.width / 2);
                gameState.ball.vx = hitPoint * 2; // Adjust X velocity based on hit location
                // Removed playSound('bounce');
            }
        
            // Ball collision with blocks
            // Iterate backwards to safely remove elements during iteration
            for (let i = gameState.blocks.length - 1; i >= 0; i--) {
                const block = gameState.blocks[i];
            
                if (checkCollision(gameState.ball, block)) {
                    // This is a collision! Now handle the bounce and update block hits.
                    if (getCollisionResponse(gameState.ball, block)) {
                        block.hits--; // Decrease the hits property
                        if (block.hits <= 0) { // Only remove if hits are 0 or less
                            score += 10;
                            updateScore();
                            gameState.blocks.splice(i, 1);
                            gameState.blocksRemaining--;
                            // Removed playSound('block_break');
                        }
                        // If the block is not destroyed, its color might change based on hits remaining
                        // This logic could be added in drawBreakout based on block.hits

                        break; // Stop after hitting one block to prevent multiple deletions
                    }
                }
            }
        
            // Game over if ball goes below paddle
            if (gameState.ball.y - gameState.ball.radius > canvas.height) {
                gameOver();
                return;
            }
        
            // Win condition
            if (gameState.blocksRemaining === 0) {
                // Removed alert, now it will just trigger the standard gameOver overlay
                gameOver(); // Call game over to stop loop and show overlay
                return;
            }
        }
        
        function drawBreakout() {
            ctx.fillStyle = '#00ff41'; // Paddle color
            ctx.fillRect(gameState.paddle.x, gameState.paddle.y,
                         gameState.paddle.width, gameState.paddle.height);
        
            ctx.fillStyle = '#00ffff'; // Ball color
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
            ctx.fill();
        
            gameState.blocks.forEach(block => {
                // You could also change the color based on the remaining hits here for visual feedback
                // For example, make it darker or a different shade with fewer hits remaining.
                ctx.fillStyle = block.color;
                ctx.fillRect(block.x, block.y, block.width, block.height);
                ctx.strokeStyle = '#222'; // Block border
                ctx.strokeRect(block.x, block.y, block.width, block.height);
            });
        }
        // --- End Breakout Game ---


        // --- Tetris Game ---
        const TETRIS_COLS = 10;
        const TETRIS_ROWS = 20;
        const TETRIS_BLOCK_SIZE = 20; // Size of each square block in pixels

        // Tetromino shapes and their colors (relative coordinates)
        const TETROMINOS = {
            'I': {
                shape: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                color: '#00ffff' // Cyan
            },
            'J': {
                shape: [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#0000ff' // Blue
            },
            'L': {
                shape: [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#ffa500' // Orange
            },
            'O': {
                shape: [
                    [1, 1],
                    [1, 1]
                ],
                color: '#ffff00' // Yellow
            },
            'S': {
                shape: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ],
                color: '#00ff00' // Green
            },
            'T': {
                shape: [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#800080' // Purple
            },
            'Z': {
                shape: [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ],
                color: '#ff0000' // Red
            }
        };

        function initTetris() {
            // Adjust canvas size for Tetris
            canvas.width = TETRIS_COLS * TETRIS_BLOCK_SIZE; // 10 * 20 = 200
            canvas.height = TETRIS_ROWS * TETRIS_BLOCK_SIZE; // 20 * 20 = 400

            // Center the canvas in the game area
            canvas.style.marginLeft = 'auto';
            canvas.style.marginRight = 'auto';
            // Explicitly set style width/height to prevent scaling issues if canvas.width/height is smaller than container
            canvas.style.width = canvas.width + 'px';
            canvas.style.height = canvas.height + 'px';


            gameState = {
                board: Array(TETRIS_ROWS).fill(0).map(() => Array(TETRIS_COLS).fill(0)), // 0 for empty, values for colors
                currentPiece: null,
                nextPiece: null, // Future feature: next piece display
                pieceX: 0,
                pieceY: 0,
                currentPieceColor: '', // Store the color for the current piece
                dropCounter: 0,
                dropInterval: 1, // seconds
                level: 1,
                linesCleared: 0,
                score: 0, // Tetris specific score, but it feeds into global score
                isGameOver: false,
                lastMoveTime: 0 // To prevent rapid horizontal movement
            };

            generateNewPiece();
            // Start the drop process
            gameState.dropCounter = 0;
            gameState.lastMoveTime = performance.now(); // Initialize for input handling
            score = 0; // Reset global score for Tetris game
            updateScore();
        }

        function generateNewPiece() {
            const pieceKeys = Object.keys(TETROMINOS);
            const randomKey = pieceKeys[Math.floor(Math.random() * pieceKeys.length)];
            const pieceData = TETROMINOS[randomKey];

            gameState.currentPiece = JSON.parse(JSON.stringify(pieceData.shape)); // Deep copy the shape
            gameState.currentPieceColor = pieceData.color;
            gameState.pieceX = Math.floor(TETRIS_COLS / 2) - Math.floor(gameState.currentPiece[0].length / 2);
            gameState.pieceY = 0; // Start at the very top

            if (checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY)) {
                // Game Over if new piece can't be placed
                gameState.isGameOver = true;
                gameOver(); // Trigger the global game over
            }
        }

        // --- Tetris Collision Detection ---
        function checkTetrisCollision(board, piece, offsetX, offsetY) {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] !== 0) { // If it's a solid block of the piece
                        const boardX = x + offsetX;
                        const boardY = y + offsetY;

                        if (boardX < 0 || boardX >= TETRIS_COLS || boardY >= TETRIS_ROWS) {
                            return true; // Collision with walls or floor
                        }
                        if (boardY < 0) { // Above board (starting position), no collision check with existing blocks
                            continue;
                        }
                        if (board[boardY] && board[boardY][boardX] !== 0) {
                            return true; // Collision with another placed block
                        }
                    }
                }
            }
            return false;
        }

        // --- Tetris Piece Rotation ---
        function rotatePiece(piece, dir) {
            // dir = 1 for clockwise, -1 for counter-clockwise (not fully implemented for -1)
            // Clockwise rotation by transposing and reversing rows
            const originalPiece = JSON.parse(JSON.stringify(piece)); // Keep original for rollback
            let newPiece = originalPiece.map((row, y) => row.map((val, x) => originalPiece[originalPiece.length - 1 - x][y]));

            // If dir is -1 (counter-clockwise), rotate 3 times clockwise
            if (dir === -1) {
                for (let i = 0; i < 3; i++) {
                    newPiece = newPiece.map((row, y) => row.map((val, x) => newPiece[newPiece.length - 1 - x][y]));
                }
            }

            // Basic Wall Kick / Collision Avoidance
            const offsets = [
                [0, 0],   // Try no offset
                [-1, 0],  // Try moving left
                [1, 0],   // Try moving right
                [0, -1],  // Try moving down (for T, J, L, S, Z where vertical space is needed)
                [-2, 0],  // For I-piece edge cases
                [2, 0]    // For I-piece edge cases
            ];

            for (const [ox, oy] of offsets) {
                if (!checkTetrisCollision(gameState.board, newPiece, gameState.pieceX + ox, gameState.pieceY + oy)) {
                    gameState.currentPiece = newPiece;
                    gameState.pieceX += ox;
                    gameState.pieceY += oy;
                    return true;
                }
            }
            return false; // Could not rotate
        }

        // --- Tetris Lock Piece ---
        function lockPiece() {
            for (let y = 0; y < gameState.currentPiece.length; y++) {
                for (let x = 0; x < gameState.currentPiece[y].length; x++) {
                    if (gameState.currentPiece[y][x] !== 0) { // If it's a solid block of the piece
                        // Check if it's within bounds before assigning to prevent errors on game over condition
                        if (gameState.pieceY + y >= 0 && gameState.pieceY + y < TETRIS_ROWS &&
                            gameState.pieceX + x >= 0 && gameState.pieceX + x < TETRIS_COLS) {
                            gameState.board[gameState.pieceY + y][gameState.pieceX + x] = gameState.currentPieceColor; // Store the color with the block
                        }
                    }
                }
            }
            clearLines();
            generateNewPiece();
        }

        // --- Tetris Clear Lines (Refactored for robustness) ---
        function clearLines() {
            let linesClearedThisTurn = 0;
            const linesToKeep = []; // Will store only the rows that are NOT full

            // Iterate from the bottom of the board upwards
            for (let y = TETRIS_ROWS - 1; y >= 0; y--) {
                // Check if the current row 'y' is full (contains no empty blocks)
                const isLineFull = gameState.board[y].every(block => block !== 0);

                if (!isLineFull) {
                    // If the line is not full, add it to our list of lines to keep
                    linesToKeep.push(gameState.board[y]);
                } else {
                    // If the line is full, it's cleared
                    linesClearedThisTurn++;
                }
            }

            // `linesToKeep` now contains non-full lines in reverse order (bottom to top).
            // We need to reverse it to get them in the correct visual order (top to bottom).
            linesToKeep.reverse();

            // Create a new board by first adding the necessary empty rows at the top
            const newBoard = [];
            for (let i = 0; i < linesClearedThisTurn; i++) {
                newBoard.push(Array(TETRIS_COLS).fill(0)); // Add empty rows
            }

            // Then, append the lines that were kept (which are now in correct order)
            linesToKeep.forEach(row => newBoard.push(row));

            // Ensure the new board is exactly TETRIS_ROWS high
            // This loop should ideally not be needed if calculation is correct, but as a safeguard:
            while (newBoard.length < TETRIS_ROWS) {
                newBoard.unshift(Array(TETRIS_COLS).fill(0)); // Add remaining empty rows to the very top if needed
            }
            // If newBoard is somehow too long, trim from the top (shouldn't happen with correct logic)
            if (newBoard.length > TETRIS_ROWS) {
                newBoard.splice(0, newBoard.length - TETRIS_ROWS);
            }
            
            // Replace the old board with the newly constructed board
            gameState.board = newBoard;

            if (linesClearedThisTurn > 0) {
                // Basic Tetris scoring (can be made more complex)
                const scorePerLine = [0, 100, 300, 500, 800]; // 0, single, double, triple, tetris
                score += scorePerLine[linesClearedThisTurn] * gameState.level;
                gameState.linesCleared += linesClearedThisTurn;
                updateScore();
                // No sounds
            }
            // Increase level after a certain number of lines cleared
            if (gameState.linesCleared >= gameState.level * 10) { // Clear 10 lines per level increase
                gameState.level++;
                gameState.dropInterval = Math.max(0.1, gameState.dropInterval * 0.85); // Make it drop faster
                // console.log(`Level Up! New level: ${gameState.level}, Drop Interval: ${gameState.dropInterval.toFixed(2)}s`);
            }
        }

        // --- Tetris Update Logic ---
        function updateTetris(deltaTime) {
            if (gameState.isGameOver) return;

            gameState.dropCounter += deltaTime;
            if (gameState.dropCounter >= gameState.dropInterval) {
                gameState.dropCounter = 0;
                dropPiece();
            }

            // Input handling for Tetris - horizontal movement (continuous if key held)
            const currentTime = performance.now();
            const moveDelay = 100; // milliseconds between horizontal moves for held keys

            // Soft drop (hold down S or ArrowDown)
            if (keysPressed.has('arrowdown') || keysPressed.has('s')) {
                // Accelerate drop speed while held
                gameState.dropCounter += deltaTime * 5; 
            }

            if (keysPressed.has('arrowleft') || keysPressed.has('a')) {
                if (currentTime - gameState.lastMoveTime > moveDelay) {
                    if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX - 1, gameState.pieceY)) {
                        gameState.pieceX--;
                        gameState.lastMoveTime = currentTime;
                    }
                }
            } else if (keysPressed.has('arrowright') || keysPressed.has('d')) {
                if (currentTime - gameState.lastMoveTime > moveDelay) {
                    if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX + 1, gameState.pieceY)) {
                        gameState.pieceX++;
                        gameState.lastMoveTime = currentTime;
                    }
                }
            } else {
                // Reset lastMoveTime when no horizontal key is pressed, allows immediate next move
                gameState.lastMoveTime = 0;
            }
        }

        function dropPiece() {
            if (!checkTetrisCollision(gameState.board, gameState.currentPiece, gameState.pieceX, gameState.pieceY + 1)) {
                gameState.pieceY++;
            } else {
                lockPiece();
            }
        }

        // --- Tetris Drawing Logic ---
        function drawTetris() {
            // Draw the fixed blocks on the board
            for (let y = 0; y < TETRIS_ROWS; y++) {
                for (let x = 0; x < TETRIS_COLS; x++) {
                    if (gameState.board[y][x] !== 0) {
                        ctx.fillStyle = gameState.board[y][x]; // Use the stored color
                        ctx.fillRect(x * TETRIS_BLOCK_SIZE, y * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
                        ctx.strokeStyle = '#000'; // Block borders
                        ctx.strokeRect(x * TETRIS_BLOCK_SIZE, y * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
                    }
                }
            }

            // Draw the current falling piece
            if (gameState.currentPiece) {
                ctx.fillStyle = gameState.currentPieceColor;
                for (let y = 0; y < gameState.currentPiece.length; y++) {
                    for (let x = 0; x < gameState.currentPiece[y].length; x++) {
                        if (gameState.currentPiece[y][x] !== 0) {
                            ctx.fillRect((gameState.pieceX + x) * TETRIS_BLOCK_SIZE,
                                         (gameState.pieceY + y) * TETRIS_BLOCK_SIZE,
                                         TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
                            ctx.strokeStyle = '#000'; // Block borders
                            ctx.strokeRect((gameState.pieceX + x) * TETRIS_BLOCK_SIZE,
                                           (gameState.pieceY + y) * TETRIS_BLOCK_SIZE,
                                           TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
                        }
                    }
                }
            }

            // Draw grid lines (optional, can be done with fillRect above for outlines too)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= TETRIS_COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * TETRIS_BLOCK_SIZE, 0);
                ctx.lineTo(i * TETRIS_BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= TETRIS_ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * TETRIS_BLOCK_SIZE);
                ctx.lineTo(canvas.width, i * TETRIS_BLOCK_SIZE);
                ctx.stroke();
            }

            // Display level/lines cleared
            ctx.fillStyle = '#00ff41';
            ctx.font = '16px "Courier New", monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`Level: ${gameState.level}`, 5, 20);
            ctx.fillText(`Lines: ${gameState.linesCleared}`, 5, 40);

            // Game Over text is handled by the overlay now
        }
        // --- End Tetris Game ---


        // Initial setup on window load
        window.addEventListener('load', () => {
            createStars(); // Populate stars on load
            // Ensure initial display state is correct
            document.getElementById('gameSelection').style.display = 'grid';
            document.getElementById('gameArea').style.display = 'none';
            document.getElementById('gameOverOverlay').classList.remove('active');
            updateScore(); // Initialize score display
        });
        window.addEventListener('resize', createStars); // Re-populate stars on resize for responsiveness
    </script>
</body>
</html>
